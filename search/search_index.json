{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"configuration/","text":"Configuration Tomo is configured via a .tomo/config.rb file. This configuration file defines what tasks to run when executing a setup or deploy , the settings that affect the behavior of those tasks, and the remote host or hosts where those tasks will be run. The format of tomo\u2019s configuration file is designed to be simple and concise for basic deployments, with the flexibility to scale to more advanced setups that involve multiple roles, environments, and hosts. A basic deployment will typically use these configuration directives: plugin host set setup deploy Here\u2019s an abbreviated example: plugin \"git\" plugin \"bundler\" plugin \"rails\" # ... host \"deployer@app.example.com\" set application: \"my-rails-app\" set deploy_to: \"/var/www/%<application>\" set git_url: \"git@github.com:my-username/my-rails-app.git\" set git_branch: \"master\" # ... setup do run \"git:clone\" run \"git:create_release\" run \"bundler:install\" run \"rails:db_schema_load\" # ... end deploy do run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" run \"core:symlink_current\" # ... end A more complex deployment may make use of these additional directives: environment role batch plugin(name_or_relative_path) Load a tomo plugin by name or from a Ruby file by a relative path. Several plugins are built into tomo: bundler , env , git , nvm , puma , rails , and rbenv . If you want to use the tasks provided by one of these plugins, load it by name, like this: plugin \"git\" Plugins can also be provided by gems installed on your system. For example, the tomo-plugin-rollbar gem provides the \u201crollbar\u201d plugin. Make sure the gem is installed (e.g. in your Gemfile) and then reference the plugin by name to load it: plugin \"rollbar\" Note that the name of the plugin may not necessarily match the name of the gem. Refer to the gem\u2019s documentation for installation instructions. Finally, if the argument to plugin starts with a dot ( . ) it is considered a relative path to a custom plugin. By convention, custom plugins are stored in .tomo/plugins/ within the project that tomo is deploying. The name of the plugin is inferred from its file name. So for example, if the plugin is loaded from a file named foo.rb , then the name of the plugin is \u201cfoo\u201d and all tasks it defines will be given the foo: namespace: plugin \"./plugins/foo.rb\" host(address, **options) Specify the SSH host address that tomo will connect to. The address can contain username, host name or IP address, and optionally a port number. For example: host \"deployer@app.example.com\" # port 22 is implied host \"admin@192.168.1.50:8022\" # port 8022 The following advanced options are supported: Name Purpose Default roles An array of String roles to assign to this host. Used with the role directive for specifying which tasks should run on this host. [] log_prefix A String prefix to print next to all log output for this host. nil privileged_user The SSH user to connect as when running privileged tasks. See setup for an example. \"root\" set(hash) Specify a value for a tomo setting. For example, to change the number of releases that tomo retains when pruning old releases: set keep_releases: 5 For a full list of settings that affect tomo\u2019s core behavior, refer to the core plugin documentation . Each plugin such as bundler and git also has its own specialized list of settings. Refer to the each plugin\u2019s documentation for a full reference. Interpolation It is possible to reference other settings when specifying a value. The format of a reference string is %<name> where name is the name of another setting. This is often used to build paths that are relative to the release that is being deployed, or for paths relative to tomo\u2019s shared directory. In this example, the value will be interpolated to contain the release that is being deployed: set release_json_path: \"%<release_path>/.tomo_release.json\" # => \"/var/www/my-app/20190523234156/.tomo_release.json\" Another common use case is the shared directory: set bundler_path: \"%<shared_path>/bundle\" # => \"/var/www/my-app/shared/bundle\" Interpolation takes place after tomo has loaded all configuration, plugins, and overrides, just before tasks are run. Custom settings set will define a setting if it does not already exist. This means you can create arbitrarily-named settings for your own purposes, such as for use within custom tasks. set my_setting_i_just_made_up: \"great\" In practice most settings are strings, but any Ruby value is possible. set some_double: 0.57 set my_hash: { urgent: true, message: \"hello\" } Overrides Settings defined by set can be overridden when running a tomo command, e.g. tomo deploy , by way of environment variables and command-line arguments. Environment variable overrides take the form of TOMO_* . For example, this will override the :git_branch setting to be \u201cdevelop\u201d: $ export TOMO_GIT_BRANCH=develop $ tomo deploy On the command line, -s or --setting can be used. For example: $ tomo deploy -s git_branch=develop The precedence of overrides is as follows (higher in the list have higher precedence): Command-line overrides Environment variable overrides set Defaults (specified by plugins) setup(&block) Define the list of tasks that will be run by the tomo setup command, by providing a block containing run directives, like this: setup do run \"env:setup\" run \"core:setup_directories\" run \"git:clone\" run \"git:create_release\" run \"core:symlink_shared\" run \"nvm:install\" run \"rbenv:install\" run \"bundler:upgrade_bundler\" run \"bundler:install\" run \"rails:db_create\" run \"rails:db_schema_load\" run \"rails:db_seed\" end Each run can optionally take a privileged: true option. When specified, the task will be run using the \u201croot\u201d user instead of the default user specified for each host . setup do run \"apt:install\", privileged: true end deploy(&block) Define the list of tasks that will be run by the tomo deploy command, by providing a block containing run directives, like this: deploy do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:db_migrate\" run \"rails:db_seed\" run \"rails:assets_precompile\" run \"core:symlink_current\" run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end environment(name, &block) Define an environment so that tomo can be used to deploy the same project with more than one set of configuration. Each environment must have a unique name and can contain its own host and set directives. For example: # Top-level config is shared by both environments set git_url: \"git@github.com:username/repo.git\" environment :staging do host \"deployer@staging.example.com\" set git_branch: \"develop\" end environment :production do host \"deployer@app.example.com\" set git_branch: \"master\" end Use the -e or --environment option when running tomo to select which environment to use. role(name, runs:) Specify that certain task(s) are only allowed to run on hosts that have the role name . The runs option must be an array of Strings representing task names. Simple wildcards (glob rules using * ) can be used to match multiple tasks. By default, every task that is listed in setup and deploy blocks is run on every host. In a multi-host deployment this is not always desirable. For example, the rails:db_seed and rails:db_migrate tasks should only be run once per deployment (i.e. on one host). To accomplish this, we can define a role named \u201cdb\u201d that is responsible for running these tasks, like this: role \"db\", runs: [\"rails:db_*\"] host \"deployer@app1.example.com\", roles: [\"db\"] host \"deployer@app2.example.com\", roles: [] The role directive in the example above tells tomo that any task matching the glob pattern rails:db_* should only run on hosts that are assigned the \u201cdb\u201d role. That means that app1.example.com will run rails:db_seed and rails:db_migrate , but app2.example.com will not. batch(&block) Define a group tasks to run in parallel during a multi-host deploy. This allows one host to \u201crace ahead\u201d of other hosts and leads to potentially faster deployments. In a multi-host deployment, by default each task in a setup and deploy must complete on all hosts before tomo will move onto the next task. This means a deployment is limited by its slowest host. If a task is configured via role to run on only one host (e.g. rails:db_migrate ), other hosts must wait until the task is done. We can speed this up by using batch , as in this example: deploy do # All tasks in this batch must complete before tomo will move onto # core:symlink_current, but within the batch each host can \"race ahead\" # independently in parallel. batch do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" end # This task must complete on all hosts before moving onto the next batch. run \"core:symlink_current\" # The tasks within this batch can run independently in parallel on each host. batch do run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end end In the above configuration, we care that core:symlink_current is executed at the same time on all hosts, but before and after that, the other tasks can be executed out of sync.","title":"Configuration"},{"location":"configuration/#configuration","text":"Tomo is configured via a .tomo/config.rb file. This configuration file defines what tasks to run when executing a setup or deploy , the settings that affect the behavior of those tasks, and the remote host or hosts where those tasks will be run. The format of tomo\u2019s configuration file is designed to be simple and concise for basic deployments, with the flexibility to scale to more advanced setups that involve multiple roles, environments, and hosts. A basic deployment will typically use these configuration directives: plugin host set setup deploy Here\u2019s an abbreviated example: plugin \"git\" plugin \"bundler\" plugin \"rails\" # ... host \"deployer@app.example.com\" set application: \"my-rails-app\" set deploy_to: \"/var/www/%<application>\" set git_url: \"git@github.com:my-username/my-rails-app.git\" set git_branch: \"master\" # ... setup do run \"git:clone\" run \"git:create_release\" run \"bundler:install\" run \"rails:db_schema_load\" # ... end deploy do run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" run \"core:symlink_current\" # ... end A more complex deployment may make use of these additional directives: environment role batch","title":"Configuration"},{"location":"configuration/#pluginname_or_relative_path","text":"Load a tomo plugin by name or from a Ruby file by a relative path. Several plugins are built into tomo: bundler , env , git , nvm , puma , rails , and rbenv . If you want to use the tasks provided by one of these plugins, load it by name, like this: plugin \"git\" Plugins can also be provided by gems installed on your system. For example, the tomo-plugin-rollbar gem provides the \u201crollbar\u201d plugin. Make sure the gem is installed (e.g. in your Gemfile) and then reference the plugin by name to load it: plugin \"rollbar\" Note that the name of the plugin may not necessarily match the name of the gem. Refer to the gem\u2019s documentation for installation instructions. Finally, if the argument to plugin starts with a dot ( . ) it is considered a relative path to a custom plugin. By convention, custom plugins are stored in .tomo/plugins/ within the project that tomo is deploying. The name of the plugin is inferred from its file name. So for example, if the plugin is loaded from a file named foo.rb , then the name of the plugin is \u201cfoo\u201d and all tasks it defines will be given the foo: namespace: plugin \"./plugins/foo.rb\"","title":"plugin(name_or_relative_path)"},{"location":"configuration/#hostaddress-4242options","text":"Specify the SSH host address that tomo will connect to. The address can contain username, host name or IP address, and optionally a port number. For example: host \"deployer@app.example.com\" # port 22 is implied host \"admin@192.168.1.50:8022\" # port 8022 The following advanced options are supported: Name Purpose Default roles An array of String roles to assign to this host. Used with the role directive for specifying which tasks should run on this host. [] log_prefix A String prefix to print next to all log output for this host. nil privileged_user The SSH user to connect as when running privileged tasks. See setup for an example. \"root\"","title":"host(address, **options)"},{"location":"configuration/#sethash","text":"Specify a value for a tomo setting. For example, to change the number of releases that tomo retains when pruning old releases: set keep_releases: 5 For a full list of settings that affect tomo\u2019s core behavior, refer to the core plugin documentation . Each plugin such as bundler and git also has its own specialized list of settings. Refer to the each plugin\u2019s documentation for a full reference.","title":"set(hash)"},{"location":"configuration/#interpolation","text":"It is possible to reference other settings when specifying a value. The format of a reference string is %<name> where name is the name of another setting. This is often used to build paths that are relative to the release that is being deployed, or for paths relative to tomo\u2019s shared directory. In this example, the value will be interpolated to contain the release that is being deployed: set release_json_path: \"%<release_path>/.tomo_release.json\" # => \"/var/www/my-app/20190523234156/.tomo_release.json\" Another common use case is the shared directory: set bundler_path: \"%<shared_path>/bundle\" # => \"/var/www/my-app/shared/bundle\" Interpolation takes place after tomo has loaded all configuration, plugins, and overrides, just before tasks are run.","title":"Interpolation"},{"location":"configuration/#custom-settings","text":"set will define a setting if it does not already exist. This means you can create arbitrarily-named settings for your own purposes, such as for use within custom tasks. set my_setting_i_just_made_up: \"great\" In practice most settings are strings, but any Ruby value is possible. set some_double: 0.57 set my_hash: { urgent: true, message: \"hello\" }","title":"Custom settings"},{"location":"configuration/#overrides","text":"Settings defined by set can be overridden when running a tomo command, e.g. tomo deploy , by way of environment variables and command-line arguments. Environment variable overrides take the form of TOMO_* . For example, this will override the :git_branch setting to be \u201cdevelop\u201d: $ export TOMO_GIT_BRANCH=develop $ tomo deploy On the command line, -s or --setting can be used. For example: $ tomo deploy -s git_branch=develop The precedence of overrides is as follows (higher in the list have higher precedence): Command-line overrides Environment variable overrides set Defaults (specified by plugins)","title":"Overrides"},{"location":"configuration/#setupblock","text":"Define the list of tasks that will be run by the tomo setup command, by providing a block containing run directives, like this: setup do run \"env:setup\" run \"core:setup_directories\" run \"git:clone\" run \"git:create_release\" run \"core:symlink_shared\" run \"nvm:install\" run \"rbenv:install\" run \"bundler:upgrade_bundler\" run \"bundler:install\" run \"rails:db_create\" run \"rails:db_schema_load\" run \"rails:db_seed\" end Each run can optionally take a privileged: true option. When specified, the task will be run using the \u201croot\u201d user instead of the default user specified for each host . setup do run \"apt:install\", privileged: true end","title":"setup(&amp;block)"},{"location":"configuration/#deployblock","text":"Define the list of tasks that will be run by the tomo deploy command, by providing a block containing run directives, like this: deploy do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:db_migrate\" run \"rails:db_seed\" run \"rails:assets_precompile\" run \"core:symlink_current\" run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end","title":"deploy(&amp;block)"},{"location":"configuration/#environmentname-block","text":"Define an environment so that tomo can be used to deploy the same project with more than one set of configuration. Each environment must have a unique name and can contain its own host and set directives. For example: # Top-level config is shared by both environments set git_url: \"git@github.com:username/repo.git\" environment :staging do host \"deployer@staging.example.com\" set git_branch: \"develop\" end environment :production do host \"deployer@app.example.com\" set git_branch: \"master\" end Use the -e or --environment option when running tomo to select which environment to use.","title":"environment(name, &amp;block)"},{"location":"configuration/#rolename-runs","text":"Specify that certain task(s) are only allowed to run on hosts that have the role name . The runs option must be an array of Strings representing task names. Simple wildcards (glob rules using * ) can be used to match multiple tasks. By default, every task that is listed in setup and deploy blocks is run on every host. In a multi-host deployment this is not always desirable. For example, the rails:db_seed and rails:db_migrate tasks should only be run once per deployment (i.e. on one host). To accomplish this, we can define a role named \u201cdb\u201d that is responsible for running these tasks, like this: role \"db\", runs: [\"rails:db_*\"] host \"deployer@app1.example.com\", roles: [\"db\"] host \"deployer@app2.example.com\", roles: [] The role directive in the example above tells tomo that any task matching the glob pattern rails:db_* should only run on hosts that are assigned the \u201cdb\u201d role. That means that app1.example.com will run rails:db_seed and rails:db_migrate , but app2.example.com will not.","title":"role(name, runs:)"},{"location":"configuration/#batchblock","text":"Define a group tasks to run in parallel during a multi-host deploy. This allows one host to \u201crace ahead\u201d of other hosts and leads to potentially faster deployments. In a multi-host deployment, by default each task in a setup and deploy must complete on all hosts before tomo will move onto the next task. This means a deployment is limited by its slowest host. If a task is configured via role to run on only one host (e.g. rails:db_migrate ), other hosts must wait until the task is done. We can speed this up by using batch , as in this example: deploy do # All tasks in this batch must complete before tomo will move onto # core:symlink_current, but within the batch each host can \"race ahead\" # independently in parallel. batch do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" end # This task must complete on all hosts before moving onto the next batch. run \"core:symlink_current\" # The tasks within this batch can run independently in parallel on each host. batch do run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end end In the above configuration, we care that core:symlink_current is executed at the same time on all hosts, but before and after that, the other tasks can be executed out of sync.","title":"batch(&amp;block)"},{"location":"api/Host/","text":"Tomo::Host Represents a remote SSH host. host.address # => \"example.com\" host.port # => 22 host.user # => \"deployer\" host.roles # => [\"app\", \"db\"] host.to_s # => \"deployer@example.com\" A Host is always frozen and cannot be modified. Instance methods address \u2192 String The host name or IP address. port \u2192 Integer The SSH port, usually 22. user \u2192 String The username used when connecting to the host via SSH. roles \u2192 [String] An array of roles that are assigned to this host. Roles are used in multi-host deployments to control which tasks are run on which hosts. to_s \u2192 String A representation of host in the form of user@address:port . If the port is 22, that portion is omitted.","title":"Tomo::Host"},{"location":"api/Host/#tomohost","text":"Represents a remote SSH host. host.address # => \"example.com\" host.port # => 22 host.user # => \"deployer\" host.roles # => [\"app\", \"db\"] host.to_s # => \"deployer@example.com\" A Host is always frozen and cannot be modified.","title":"Tomo::Host"},{"location":"api/Host/#instance-methods","text":"","title":"Instance methods"},{"location":"api/Host/#address-string","text":"The host name or IP address.","title":"address \u2192 String"},{"location":"api/Host/#port-integer","text":"The SSH port, usually 22.","title":"port \u2192 Integer"},{"location":"api/Host/#user-string","text":"The username used when connecting to the host via SSH.","title":"user \u2192 String"},{"location":"api/Host/#roles-string","text":"An array of roles that are assigned to this host. Roles are used in multi-host deployments to control which tasks are run on which hosts.","title":"roles \u2192 [String]"},{"location":"api/Host/#to_s-string","text":"A representation of host in the form of user@address:port . If the port is 22, that portion is omitted.","title":"to_s \u2192 String"},{"location":"api/Logger/","text":"Tomo::Logger Provides a simple interface for logging messages to stdout and stderr. In multi-host deployments, messages are automatically prefixed with [1] , [2] , etc. based on current host. This makes it easier to distinguish where log messages are coming from. $ tomo run bundler:clean tomo run v0.1.0 [1] \u2192 Connecting to deployer@web1.example.com [2] \u2192 Connecting to deployer@web2.example.com [1] \u2022 bundler:clean [2] \u2022 bundler:clean [1] cd /home/deployer/apps/my-app/current && bundle clean [2] cd /home/deployer/apps/my-app/current && bundle clean \u2714 Ran bundler:clean on deployer@web1.example.com and deployer@web2.example.com If tomo is run in --dry-run mode, log messages are prefixed with a * to indicate the commands are being simulated. $ tomo run bundler:clean --dry-run tomo run v0.1.0 * [1] \u2192 Connecting to deployer@web1.example.com * [2] \u2192 Connecting to deployer@web2.example.com * [1] \u2022 bundler:clean * [2] \u2022 bundler:clean * [1] cd /home/deployer/apps/my-app/current && bundle clean * [2] cd /home/deployer/apps/my-app/current && bundle clean * Simulated bundler:clean on deployer@web1.example.com and deployer@web2.example.com (dry run) Instance methods debug(message) \u2192 nil Prints a message to stderr in gray with a DEBUG: prefix. Debug messages are only shown if tomo is run with the --debug option. Otherwise this is a no-op. info(message) \u2192 nil Prints a message to stdout . warn(message) \u2192 nil Prints a message to stderr with a red WARNING: prefix. error(message) \u2192 nil Prints a message to stderr with a red ERROR: prefix, indented, and with leading and trailing blank lines for extra emphasis.","title":"Tomo::Logger"},{"location":"api/Logger/#tomologger","text":"Provides a simple interface for logging messages to stdout and stderr. In multi-host deployments, messages are automatically prefixed with [1] , [2] , etc. based on current host. This makes it easier to distinguish where log messages are coming from. $ tomo run bundler:clean tomo run v0.1.0 [1] \u2192 Connecting to deployer@web1.example.com [2] \u2192 Connecting to deployer@web2.example.com [1] \u2022 bundler:clean [2] \u2022 bundler:clean [1] cd /home/deployer/apps/my-app/current && bundle clean [2] cd /home/deployer/apps/my-app/current && bundle clean \u2714 Ran bundler:clean on deployer@web1.example.com and deployer@web2.example.com If tomo is run in --dry-run mode, log messages are prefixed with a * to indicate the commands are being simulated. $ tomo run bundler:clean --dry-run tomo run v0.1.0 * [1] \u2192 Connecting to deployer@web1.example.com * [2] \u2192 Connecting to deployer@web2.example.com * [1] \u2022 bundler:clean * [2] \u2022 bundler:clean * [1] cd /home/deployer/apps/my-app/current && bundle clean * [2] cd /home/deployer/apps/my-app/current && bundle clean * Simulated bundler:clean on deployer@web1.example.com and deployer@web2.example.com (dry run)","title":"Tomo::Logger"},{"location":"api/Logger/#instance-methods","text":"","title":"Instance methods"},{"location":"api/Logger/#debugmessage-nil","text":"Prints a message to stderr in gray with a DEBUG: prefix. Debug messages are only shown if tomo is run with the --debug option. Otherwise this is a no-op.","title":"debug(message) \u2192 nil"},{"location":"api/Logger/#infomessage-nil","text":"Prints a message to stdout .","title":"info(message) \u2192 nil"},{"location":"api/Logger/#warnmessage-nil","text":"Prints a message to stderr with a red WARNING: prefix.","title":"warn(message) \u2192 nil"},{"location":"api/Logger/#errormessage-nil","text":"Prints a message to stderr with a red ERROR: prefix, indented, and with leading and trailing blank lines for extra emphasis.","title":"error(message) \u2192 nil"},{"location":"api/Paths/","text":"Tomo::Paths Provides syntactic sugar for accessing settings that represent file system paths. For every tomo setting in the form :<name>_path , Paths will expose a method of that name that behaves like a Ruby Pathname object. As a special exception, the :deploy_to setting is also exposed even though it does not follow the same naming convention. In tomo the following path settings are always available: settings[:deploy_to] # => \"/var/www/my-app\" settings[:current_path] # => \"/var/www/my-app/current\" settings[:release_path] # => \"/var/www/my-app/releases/20190531164322\" settings[:releases_path] # => \"/var/www/my-app/releases\" settings[:shared_path] # => \"/var/www/my-app/shared\" Using Paths, these same settings can be accessed like this: paths.deploy_to # => \"/var/www/my-app\" paths.current # => \"/var/www/my-app/current\" paths.release # => \"/var/www/my-app/releases/20190531164322\" paths.releases # => \"/var/www/my-app/releases\" paths.shared # => \"/var/www/my-app/shared\" More powerfully, the values returned by Paths respond to join and dirname , so you can easily compose them: paths.current.dirname # => \"/var/www/my-app\" paths.release.join(\"tmp\") # => \"/var/www/my-app/releases/20190531164322/tmp\" paths.shared.join(\"bundle\") # => \"/var/www/my-app/shared/bundle\" Paths can be used wherever a path string is expected, like chdir : remote.chdir(paths.current) do remote.run(\"bundle\", \"exec\", \"puma\", \"--daemon\") end # $ cd /var/www/my-app/current && bundle exec puma --daemon If a plugin defines a setting with the suffix _path or if you create your own setting with that suffix, it automatically will be exposed via the Paths object: # .tomo/config.rb set my_custom_path: \"/opt/custom\" paths.my_custom.join(\"var\") # => \"/opt/custom/var\"","title":"Tomo::Paths"},{"location":"api/Paths/#tomopaths","text":"Provides syntactic sugar for accessing settings that represent file system paths. For every tomo setting in the form :<name>_path , Paths will expose a method of that name that behaves like a Ruby Pathname object. As a special exception, the :deploy_to setting is also exposed even though it does not follow the same naming convention. In tomo the following path settings are always available: settings[:deploy_to] # => \"/var/www/my-app\" settings[:current_path] # => \"/var/www/my-app/current\" settings[:release_path] # => \"/var/www/my-app/releases/20190531164322\" settings[:releases_path] # => \"/var/www/my-app/releases\" settings[:shared_path] # => \"/var/www/my-app/shared\" Using Paths, these same settings can be accessed like this: paths.deploy_to # => \"/var/www/my-app\" paths.current # => \"/var/www/my-app/current\" paths.release # => \"/var/www/my-app/releases/20190531164322\" paths.releases # => \"/var/www/my-app/releases\" paths.shared # => \"/var/www/my-app/shared\" More powerfully, the values returned by Paths respond to join and dirname , so you can easily compose them: paths.current.dirname # => \"/var/www/my-app\" paths.release.join(\"tmp\") # => \"/var/www/my-app/releases/20190531164322/tmp\" paths.shared.join(\"bundle\") # => \"/var/www/my-app/shared/bundle\" Paths can be used wherever a path string is expected, like chdir : remote.chdir(paths.current) do remote.run(\"bundle\", \"exec\", \"puma\", \"--daemon\") end # $ cd /var/www/my-app/current && bundle exec puma --daemon If a plugin defines a setting with the suffix _path or if you create your own setting with that suffix, it automatically will be exposed via the Paths object: # .tomo/config.rb set my_custom_path: \"/opt/custom\" paths.my_custom.join(\"var\") # => \"/opt/custom/var\"","title":"Tomo::Paths"},{"location":"api/PluginDSL/","text":"Tomo::PluginDSL A tomo plugin is defined by a Ruby module that extends Tomo::PluginDSL. A plugin definition can specify three things: Default settings Tasks Helpers Here is the bundler plugin as an example: require_relative \"bundler/helpers\" require_relative \"bundler/tasks\" module Tomo::Plugin::Bundler extend Tomo::PluginDSL tasks Tomo::Plugin::Bundler::Tasks helpers Tomo::Plugin::Bundler::Helpers defaults bundler_install_flags: [\"--deployment\"], bundler_gemfile: nil, bundler_jobs: \"4\", bundler_path: \"%<shared_path>/bundle\", bundler_without: %w[development test] end The above plugin defines several default settings, defines tasks using a TaskLibrary named Tomo::Plugin::Bundler::Tasks , and defines helpers in a module named Tomo::Plugin::Bundler::Helpers . Refer to the Publishing a Plugin tutorial for more information about packaging and distributing tomo plugins. Instance methods defaults(hash) Specify default settings that will be applied when this plugin is loaded. Although not strictly necessary, it is best practice to list all required and optional settings that are used by the plugin, even if the default values are nil . This lets other developers know what setting names are expected when using the plugin. Settings must use symbol keys and typically String values, although any Ruby type is possible. Strings can contain interpolated values . module Tomo::Plugin::Bundler extend Tomo::PluginDSL defaults bundler_install_flags: [\"--deployment\"], bundler_gemfile: nil, bundler_jobs: \"4\", bundler_path: \"%<shared_path>/bundle\", bundler_without: %w[development test] end tasks(*task_library_class) Specify the tasks that will be defined by this plugin by supplying one or more TaskLibrary classes. The public instance methods of each class will be turned into tomo tasks. class Tomo::Plugin::Git::Tasks < Tomo::TaskLibrary def clone # ... end def create_release # ... end end class Tomo::Plugin::Git extend Tomo::PluginDSL tasks Tomo::Plugin::Git::Tasks end You can use self to define a plugin and its tasks together as a single class: class Tomo::Plugin::Git < Tomo::TaskLibrary extend Tomo::PluginDSL tasks self def clone # ... end def create_release # ... end end helpers(*module) Specify the helpers that will be defined by this plugin by supplying one or more plain Ruby modules. The modules will be mixed in at runtime to extend the Remote interface with additional methods. module Tomo::Plugin::Core::Helpers def ln_sf(target, link, **run_opts) # ... end def mkdir_p(*directories, **run_opts) # ... end end module Tomo::Plugin::Core extend Tomo::PluginDSL helpers Tomo::Plugin::Core::Helpers end","title":"Tomo::PluginDSL"},{"location":"api/PluginDSL/#tomoplugindsl","text":"A tomo plugin is defined by a Ruby module that extends Tomo::PluginDSL. A plugin definition can specify three things: Default settings Tasks Helpers Here is the bundler plugin as an example: require_relative \"bundler/helpers\" require_relative \"bundler/tasks\" module Tomo::Plugin::Bundler extend Tomo::PluginDSL tasks Tomo::Plugin::Bundler::Tasks helpers Tomo::Plugin::Bundler::Helpers defaults bundler_install_flags: [\"--deployment\"], bundler_gemfile: nil, bundler_jobs: \"4\", bundler_path: \"%<shared_path>/bundle\", bundler_without: %w[development test] end The above plugin defines several default settings, defines tasks using a TaskLibrary named Tomo::Plugin::Bundler::Tasks , and defines helpers in a module named Tomo::Plugin::Bundler::Helpers . Refer to the Publishing a Plugin tutorial for more information about packaging and distributing tomo plugins.","title":"Tomo::PluginDSL"},{"location":"api/PluginDSL/#instance-methods","text":"","title":"Instance methods"},{"location":"api/PluginDSL/#defaultshash","text":"Specify default settings that will be applied when this plugin is loaded. Although not strictly necessary, it is best practice to list all required and optional settings that are used by the plugin, even if the default values are nil . This lets other developers know what setting names are expected when using the plugin. Settings must use symbol keys and typically String values, although any Ruby type is possible. Strings can contain interpolated values . module Tomo::Plugin::Bundler extend Tomo::PluginDSL defaults bundler_install_flags: [\"--deployment\"], bundler_gemfile: nil, bundler_jobs: \"4\", bundler_path: \"%<shared_path>/bundle\", bundler_without: %w[development test] end","title":"defaults(hash)"},{"location":"api/PluginDSL/#tasks42task_library_class","text":"Specify the tasks that will be defined by this plugin by supplying one or more TaskLibrary classes. The public instance methods of each class will be turned into tomo tasks. class Tomo::Plugin::Git::Tasks < Tomo::TaskLibrary def clone # ... end def create_release # ... end end class Tomo::Plugin::Git extend Tomo::PluginDSL tasks Tomo::Plugin::Git::Tasks end You can use self to define a plugin and its tasks together as a single class: class Tomo::Plugin::Git < Tomo::TaskLibrary extend Tomo::PluginDSL tasks self def clone # ... end def create_release # ... end end","title":"tasks(*task_library_class)"},{"location":"api/PluginDSL/#helpers42module","text":"Specify the helpers that will be defined by this plugin by supplying one or more plain Ruby modules. The modules will be mixed in at runtime to extend the Remote interface with additional methods. module Tomo::Plugin::Core::Helpers def ln_sf(target, link, **run_opts) # ... end def mkdir_p(*directories, **run_opts) # ... end end module Tomo::Plugin::Core extend Tomo::PluginDSL helpers Tomo::Plugin::Core::Helpers end","title":"helpers(*module)"},{"location":"api/Remote/","text":"Tomo::Remote A Remote represents an SSH connection to a remote host and provides a fa\u00e7ade for building and running shell scripts on that host. A Remote instance is always implicitly available within the context of a task implementation as remote . The tomo framework takes care of initializing the SSH connection and setting this reference. The most basic use of Remote is the run method, which executes a script on the remote host: remote.run \"echo\", \"hello world\" For building more complex scripts, Remote offers a variety of builder methods: chdir , env , prepend , and umask . Here is an example of some of them: remote.chdir(paths.current) do remote.prepend(\"bundle exec\") do remote.env(DISABLE_SPRING: \"1\") do remote.run(\"rails\", \"db:prepare\") end end end # $ cd /var/www/my-app/current && export DISABLE_SPRING=1 && bundle exec rails db:prepare Instance methods run(*command, **options) \u2192 Tomo::Result Runs a shell script on the remote host via SSH. The command can take one of two forms. If given as a single string, the command is executed as a shell script directly; no escaping is performed. This is useful if your script needs to specify output redirection ( > or >> ), pipes, or other shell logic ( && or || ). For example: remote.run \"bundle exec rails db:prepare > /dev/null && echo 'All set!'\" # $ bundle exec rails db:prepare > /dev/null && echo 'All set!' If the command is given as multiple string arguments, then each argument is individually shell-escaped and then assembled into a shell script. This is the preferred way to safely run scripts, especially if the script relies on settings or other user input. For example: settings[:greeting] # => \"<this> is safe & easy\" remote.run \"echo\", settings[:greeting] # $ echo \\<this\\>\\ is\\ safe\\ \\&\\ easy When a script is run it is first echoed to the console and all of its output (stdout and stderr) is streamed to the console as well. If the script fails then an exception will be raised. If the script succeeds, a Result object will be returned. This behavior can be customized by specifying options , which can include: Name Purpose Default :echo Similar to -x in bash, setting echo: true will cause the script to be printed to the logger before it is run. If false , the script will be run without being printed. If a string is provided, the string will be printed instead of the actual script. This can be useful for redacting or abbreviating sensitive or very long scripts. true :silent Normally stdout and stderr of the remote script are printed to the logger. Setting silent: true will silence this output. Note that even if silenced, the output can still be accessed via the Result . false :raise_on_error By default, if the remote script fails (i.e. returns an exit status other than 0), tomo will raise an exception, stopping execution. If the script being executed is expected to fail, or you would like to take action based on failure, set raise_on_error: false . In this case a failed script will return a Result with failure? set to true . true :default_chdir The working directory where the script will be run by default, if chdir is not used. If not specified, the working directory is based on the SSH server\u2019s default login directory (almost always this is the user\u2019s home directory). nil :attach Setting attach: true will cause the script to be run as if attach had been called instead. false :pty Setting pty: true will instruct the SSH client to allocate a pseudo-tty when running the script. false attach(*command, **options) Runs a script on the remote host via SSH, just like run , except the Ruby process will be replaced with the SSH process and control completely handed over to SSH (this is done via Process.exec ). In other words, tomo will immediately stop and it will be like you had run SSH directly. This is useful for things like running a Rails console, where you would like to \u201cattach\u201d stdin/stdout to the remote process. Typically pty: true is used in these situations to force a tty. remote.attach \"bundle exec rails console\", pty: true attach accepts the same options as run (except for :attach , which is redundant). chdir(dir, &block) \u2192 obj Changes into the specified dir when executing a script via run or attach . Must be used with a block. This causes cd <dir> && to be prepended to the script. remote.chdir \"/opt/data\" do remote.run \"ls -al\" end # $ cd /opt/data && ls -al chdir returns the value of its block. env(hash, &block) \u2192 obj Sets environment variables when executing a script via run or attach . Must be used with a block. This causes export VAR1=value VAR2=value ... && to be prepended to the script. The environment variables are specified as a Ruby hash. remote.env(CLICOLOR_FORCE: \"1\", RAILS_ENV: \"production\") do remote.run \"bundle exec sidekiq\" end # $ export CLICOLOR_FORCE=1 RAILS_ENV=production && bundle exec sidekiq env returns the value of its block. prepend(*command, &block) \u2192 obj Prepends an arbitrary command when executing a script via run or attach . Must be used with a block. remote.prepend \"bundle\", \"exec\" do remote.run \"rails routes\" end # $ bundle exec rails routes prepend returns the value of its block. umask(mask, &block) \u2192 obj Sets a umask when executing a script via run or attach . Must be used with a block. This causes umask ... && to be prepended to the script. The mask can be an Integer (typically expressed in octal) or a String. remote.umask 0o077 do remote.run \"touch a_file\" end # $ umask 0077 && touch a_file umask returns the value of its block. host \u2192 Tomo::Host The remote SSH host that scripts will be run on. release \u2192 Hash A mutable Hash that can be used to share data about the release that is being deployed. Data stored in this Hash can be read by other tasks. In practice this is used by the git:create_release task to store the branch, author, SHA, date, etc. of the release. This data can then be accessed by other tasks that are interested in this information. result = remote.run('git log -n1 --pretty=format:\"%ae\"') remote.release[:author] = result.stdout.chomp # remote.release[:author] can now be read by other tasks that connect to this host","title":"Tomo::Remote"},{"location":"api/Remote/#tomoremote","text":"A Remote represents an SSH connection to a remote host and provides a fa\u00e7ade for building and running shell scripts on that host. A Remote instance is always implicitly available within the context of a task implementation as remote . The tomo framework takes care of initializing the SSH connection and setting this reference. The most basic use of Remote is the run method, which executes a script on the remote host: remote.run \"echo\", \"hello world\" For building more complex scripts, Remote offers a variety of builder methods: chdir , env , prepend , and umask . Here is an example of some of them: remote.chdir(paths.current) do remote.prepend(\"bundle exec\") do remote.env(DISABLE_SPRING: \"1\") do remote.run(\"rails\", \"db:prepare\") end end end # $ cd /var/www/my-app/current && export DISABLE_SPRING=1 && bundle exec rails db:prepare","title":"Tomo::Remote"},{"location":"api/Remote/#instance-methods","text":"","title":"Instance methods"},{"location":"api/Remote/#run42command-4242options-tomoresult","text":"Runs a shell script on the remote host via SSH. The command can take one of two forms. If given as a single string, the command is executed as a shell script directly; no escaping is performed. This is useful if your script needs to specify output redirection ( > or >> ), pipes, or other shell logic ( && or || ). For example: remote.run \"bundle exec rails db:prepare > /dev/null && echo 'All set!'\" # $ bundle exec rails db:prepare > /dev/null && echo 'All set!' If the command is given as multiple string arguments, then each argument is individually shell-escaped and then assembled into a shell script. This is the preferred way to safely run scripts, especially if the script relies on settings or other user input. For example: settings[:greeting] # => \"<this> is safe & easy\" remote.run \"echo\", settings[:greeting] # $ echo \\<this\\>\\ is\\ safe\\ \\&\\ easy When a script is run it is first echoed to the console and all of its output (stdout and stderr) is streamed to the console as well. If the script fails then an exception will be raised. If the script succeeds, a Result object will be returned. This behavior can be customized by specifying options , which can include: Name Purpose Default :echo Similar to -x in bash, setting echo: true will cause the script to be printed to the logger before it is run. If false , the script will be run without being printed. If a string is provided, the string will be printed instead of the actual script. This can be useful for redacting or abbreviating sensitive or very long scripts. true :silent Normally stdout and stderr of the remote script are printed to the logger. Setting silent: true will silence this output. Note that even if silenced, the output can still be accessed via the Result . false :raise_on_error By default, if the remote script fails (i.e. returns an exit status other than 0), tomo will raise an exception, stopping execution. If the script being executed is expected to fail, or you would like to take action based on failure, set raise_on_error: false . In this case a failed script will return a Result with failure? set to true . true :default_chdir The working directory where the script will be run by default, if chdir is not used. If not specified, the working directory is based on the SSH server\u2019s default login directory (almost always this is the user\u2019s home directory). nil :attach Setting attach: true will cause the script to be run as if attach had been called instead. false :pty Setting pty: true will instruct the SSH client to allocate a pseudo-tty when running the script. false","title":"run(*command, **options) \u2192 Tomo::Result"},{"location":"api/Remote/#attach42command-4242options","text":"Runs a script on the remote host via SSH, just like run , except the Ruby process will be replaced with the SSH process and control completely handed over to SSH (this is done via Process.exec ). In other words, tomo will immediately stop and it will be like you had run SSH directly. This is useful for things like running a Rails console, where you would like to \u201cattach\u201d stdin/stdout to the remote process. Typically pty: true is used in these situations to force a tty. remote.attach \"bundle exec rails console\", pty: true attach accepts the same options as run (except for :attach , which is redundant).","title":"attach(*command, **options)"},{"location":"api/Remote/#chdirdir-block-obj","text":"Changes into the specified dir when executing a script via run or attach . Must be used with a block. This causes cd <dir> && to be prepended to the script. remote.chdir \"/opt/data\" do remote.run \"ls -al\" end # $ cd /opt/data && ls -al chdir returns the value of its block.","title":"chdir(dir, &amp;block) \u2192 obj"},{"location":"api/Remote/#envhash-block-obj","text":"Sets environment variables when executing a script via run or attach . Must be used with a block. This causes export VAR1=value VAR2=value ... && to be prepended to the script. The environment variables are specified as a Ruby hash. remote.env(CLICOLOR_FORCE: \"1\", RAILS_ENV: \"production\") do remote.run \"bundle exec sidekiq\" end # $ export CLICOLOR_FORCE=1 RAILS_ENV=production && bundle exec sidekiq env returns the value of its block.","title":"env(hash, &amp;block) \u2192 obj"},{"location":"api/Remote/#prepend42command-block-obj","text":"Prepends an arbitrary command when executing a script via run or attach . Must be used with a block. remote.prepend \"bundle\", \"exec\" do remote.run \"rails routes\" end # $ bundle exec rails routes prepend returns the value of its block.","title":"prepend(*command, &amp;block) \u2192 obj"},{"location":"api/Remote/#umaskmask-block-obj","text":"Sets a umask when executing a script via run or attach . Must be used with a block. This causes umask ... && to be prepended to the script. The mask can be an Integer (typically expressed in octal) or a String. remote.umask 0o077 do remote.run \"touch a_file\" end # $ umask 0077 && touch a_file umask returns the value of its block.","title":"umask(mask, &amp;block) \u2192 obj"},{"location":"api/Remote/#host-tomohost","text":"The remote SSH host that scripts will be run on.","title":"host \u2192 Tomo::Host"},{"location":"api/Remote/#release-hash","text":"A mutable Hash that can be used to share data about the release that is being deployed. Data stored in this Hash can be read by other tasks. In practice this is used by the git:create_release task to store the branch, author, SHA, date, etc. of the release. This data can then be accessed by other tasks that are interested in this information. result = remote.run('git log -n1 --pretty=format:\"%ae\"') remote.release[:author] = result.stdout.chomp # remote.release[:author] can now be read by other tasks that connect to this host","title":"release \u2192 Hash"},{"location":"api/Result/","text":"Tomo::Result Represents the result of a remote SSH script. result = remote.run(\"echo\", \"hello world\") result.success? # => true result.failure? # => false result.exit_status # => 0 result.stdout # => \"hello world\\n\" result.stderr # => \"\" result.output # => \"hello world\\n\" A Result is always frozen and cannot be modified. Instance methods success? \u2192 true or false Whether the remote SSH script executed successfully. An exit status of 0 is considered success. failure? \u2192 true or false Whether the remote SSH script failed to execute. An non-zero exit status is considered a failure. exit_status \u2192 Integer The exit status returned by the remote SSH script. A status of 0 is considered success. stdout \u2192 String All data that was written to stdout by the remote SSH script. Empty string if nothing was written. stderr \u2192 String All data that was written to stderr by the remote SSH script. Empty string if nothing was written. output \u2192 String All data that was written by the remote SSH script: stdout and stderr combined, in that order. Empty string if nothing was written.","title":"Tomo::Result"},{"location":"api/Result/#tomoresult","text":"Represents the result of a remote SSH script. result = remote.run(\"echo\", \"hello world\") result.success? # => true result.failure? # => false result.exit_status # => 0 result.stdout # => \"hello world\\n\" result.stderr # => \"\" result.output # => \"hello world\\n\" A Result is always frozen and cannot be modified.","title":"Tomo::Result"},{"location":"api/Result/#instance-methods","text":"","title":"Instance methods"},{"location":"api/Result/#success-true-or-false","text":"Whether the remote SSH script executed successfully. An exit status of 0 is considered success.","title":"success? \u2192 true or false"},{"location":"api/Result/#failure-true-or-false","text":"Whether the remote SSH script failed to execute. An non-zero exit status is considered a failure.","title":"failure? \u2192 true or false"},{"location":"api/Result/#exit_status-integer","text":"The exit status returned by the remote SSH script. A status of 0 is considered success.","title":"exit_status \u2192 Integer"},{"location":"api/Result/#stdout-string","text":"All data that was written to stdout by the remote SSH script. Empty string if nothing was written.","title":"stdout \u2192 String"},{"location":"api/Result/#stderr-string","text":"All data that was written to stderr by the remote SSH script. Empty string if nothing was written.","title":"stderr \u2192 String"},{"location":"api/Result/#output-string","text":"All data that was written by the remote SSH script: stdout and stderr combined, in that order. Empty string if nothing was written.","title":"output \u2192 String"},{"location":"api/TaskLibrary/","text":"Tomo::TaskLibrary This is the primary public API for extending tomo. A TaskLibrary defines tasks. Every public instance method of a TaskLibrary becomes accessible to tomo as a task of the same name, prefixed by the name of its plugin. For example, this is how the git:clone task is defined: module Tomo::Plugin::Git class Tasks < Tomo::TaskLibrary # This becomes the implementation of the git:clone task def clone require_setting :git_url # ... end end end The TaskLibrary base class provides several useful private methods (detailed below) that allow task authors to run commands on the remote host, access tomo settings, and more. For more information on writing tasks, refer to the Writing Custom Tasks tutorial. Instance methods paths \u2192 Tomo::Paths Returns a Paths object that provides convenient access to settings representing file system paths. paths.current.join(\"lib\") # => \"/var/www/my-app/current/lib\" # ...which is syntactic sugar for: Pathname.new(settings[:current_path]).join(\"lib\") settings \u2192 Hash Returns a frozen (i.e. read-only) Hash containing all of tomo\u2019s settings. Any string interpolations will have already been applied. The keys representing the setting names are always symbols. settings[:application] # => \"my-app\" settings[:deploy_to] # => \"/var/www/my-app\" settings[:non_existing] # => nil settings.fetch(:non_existing) # => KeyError settings[:foo] = \"bar\" # => FrozenError settings.key?(:application) # => true settings.key?(:non_existing) # => false remote \u2192 Tomo::Remote Returns the Remote fa\u00e7ade that allows scripts to be run on the remote host. remote.run(\"echo\", \"hello world\") require_setting(name) \u2192 nil Raises an exception if a setting with the given name is not present. In other words, it will raise if settings[name] is nil . This can be used as a guard clause to ensure that users provide all necessary settings before a task can be run. def clone require_setting :git_url remote.run \"git\", \"clone\", settings[:git_url] end require_settings(*names) \u2192 nil Like require_setting , except it accepts an arbitrary number of setting names. Raises if any of the settings are nil . require_settings :puma_control_token, :puma_control_url dry_run? \u2192 true or false Returns true if tomo was started with the --dry-run option. This is useful if there are certain code paths you want to ensure are taken during a dry run. def install return if remote.bundle?(\"check\", *check_options) && !dry_run? remote.bundle(\"install\", *install_options) end logger \u2192 Tomo::Logger Returns the global Logger object that can be used to write messages to tomo\u2019s output. logger.debug \"got here\" logger.info \"hi!\" logger.warn \"uh oh\" die(reason) Immediately halt task execution by raising an exception. This will automatically print information to stderr about what task failed, on which host, and the reason for the failure. raw(string) \u2192 String Mark a string as a \u201craw\u201d value so that it is not automatically escaped. By default tomo applies shell escaping rules for safety. If you explicitly want to invoke shell behavior, use raw to prevent these escaping rules. remote.run \"ls\", \"$HOME/.bashrc\" # $ ls $\\HOME/.bashrc # \"$HOME/.bashrc\": No such file or directory (os error 2) remote.run \"ls\", raw(\"$HOME/.bashrc\") # $ ls $HOME/.bashrc # /home/deployer/.bashrc","title":"Tomo::TaskLibrary"},{"location":"api/TaskLibrary/#tomotasklibrary","text":"This is the primary public API for extending tomo. A TaskLibrary defines tasks. Every public instance method of a TaskLibrary becomes accessible to tomo as a task of the same name, prefixed by the name of its plugin. For example, this is how the git:clone task is defined: module Tomo::Plugin::Git class Tasks < Tomo::TaskLibrary # This becomes the implementation of the git:clone task def clone require_setting :git_url # ... end end end The TaskLibrary base class provides several useful private methods (detailed below) that allow task authors to run commands on the remote host, access tomo settings, and more. For more information on writing tasks, refer to the Writing Custom Tasks tutorial.","title":"Tomo::TaskLibrary"},{"location":"api/TaskLibrary/#instance-methods","text":"","title":"Instance methods"},{"location":"api/TaskLibrary/#paths-tomopaths","text":"Returns a Paths object that provides convenient access to settings representing file system paths. paths.current.join(\"lib\") # => \"/var/www/my-app/current/lib\" # ...which is syntactic sugar for: Pathname.new(settings[:current_path]).join(\"lib\")","title":"paths \u2192 Tomo::Paths"},{"location":"api/TaskLibrary/#settings-hash","text":"Returns a frozen (i.e. read-only) Hash containing all of tomo\u2019s settings. Any string interpolations will have already been applied. The keys representing the setting names are always symbols. settings[:application] # => \"my-app\" settings[:deploy_to] # => \"/var/www/my-app\" settings[:non_existing] # => nil settings.fetch(:non_existing) # => KeyError settings[:foo] = \"bar\" # => FrozenError settings.key?(:application) # => true settings.key?(:non_existing) # => false","title":"settings \u2192 Hash"},{"location":"api/TaskLibrary/#remote-tomoremote","text":"Returns the Remote fa\u00e7ade that allows scripts to be run on the remote host. remote.run(\"echo\", \"hello world\")","title":"remote \u2192 Tomo::Remote"},{"location":"api/TaskLibrary/#require_settingname-nil","text":"Raises an exception if a setting with the given name is not present. In other words, it will raise if settings[name] is nil . This can be used as a guard clause to ensure that users provide all necessary settings before a task can be run. def clone require_setting :git_url remote.run \"git\", \"clone\", settings[:git_url] end","title":"require_setting(name) \u2192 nil"},{"location":"api/TaskLibrary/#require_settings42names-nil","text":"Like require_setting , except it accepts an arbitrary number of setting names. Raises if any of the settings are nil . require_settings :puma_control_token, :puma_control_url","title":"require_settings(*names) \u2192 nil"},{"location":"api/TaskLibrary/#dry_run-true-or-false","text":"Returns true if tomo was started with the --dry-run option. This is useful if there are certain code paths you want to ensure are taken during a dry run. def install return if remote.bundle?(\"check\", *check_options) && !dry_run? remote.bundle(\"install\", *install_options) end","title":"dry_run? \u2192 true or false"},{"location":"api/TaskLibrary/#logger-tomologger","text":"Returns the global Logger object that can be used to write messages to tomo\u2019s output. logger.debug \"got here\" logger.info \"hi!\" logger.warn \"uh oh\"","title":"logger \u2192 Tomo::Logger"},{"location":"api/TaskLibrary/#diereason","text":"Immediately halt task execution by raising an exception. This will automatically print information to stderr about what task failed, on which host, and the reason for the failure.","title":"die(reason)"},{"location":"api/TaskLibrary/#rawstring-string","text":"Mark a string as a \u201craw\u201d value so that it is not automatically escaped. By default tomo applies shell escaping rules for safety. If you explicitly want to invoke shell behavior, use raw to prevent these escaping rules. remote.run \"ls\", \"$HOME/.bashrc\" # $ ls $\\HOME/.bashrc # \"$HOME/.bashrc\": No such file or directory (os error 2) remote.run \"ls\", raw(\"$HOME/.bashrc\") # $ ls $HOME/.bashrc # /home/deployer/.bashrc","title":"raw(string) \u2192 String"},{"location":"api/testing/DockerPluginTester/","text":"Tomo::Testing::DockerPluginTester Similar to MockPluginTester , DockerPluginTester is a helper object that allows tasks and helpers provided by plugins to be easily tested. A real SSH connection is used and no mocking is performed. Instead, DockerPluginTester builds a Docker image containing a real SSH server and runs it, sending all remote SSH scripts to that Docker container. This allows for true end-to-end testing. The Docker image is based on Ubuntu 18.04. The first time DockerPluginTester is used, the base image will be downloaded and a tomo-specific image will be created, which can take a few minutes. Because of the overhead involved, Docker-based tests should be used sparingly and only when they provide high value over much faster unit tests. Note that you must require \"tomo/testing\" to use DockerPluginTester. Class methods new(*plugin_names, settings: {}) \u2192 new_tester Build a new DockerPluginTester that loads the given list of plugin_names . The resulting tester object can be used to execute any tasks or helpers that are provided by these plugins. Note that the \u201ccore\u201d plugin is always loaded implicitly and does not need to be specified. Creating a new DockerPluginTester will implicitly build and run a Docker image containing an SSH server. This can take a few minutes the first time the image is built. Make sure to call teardown after you are done using the tester. Instance methods run_task(task, *args) \u2192 nil Run the given task by its fully qualified name (the namespace is required). Any args , if specified, are passed to the task via settings[:run_args] . Any remote SSH scripts run by the task will be executed via an SSH connection to the Docker container. call_helper(helper, *args, **kwargs) \u2192 obj Invoke the specified helper method name with the optional positional args and keyword kwargs . Returns the return value of the helper. Any remote SSH scripts run by the task will be executed via an SSH connection to the Docker container. teardown \u2192 nil Stop the underlying Docker container associated with this tester. Be sure to call teardown after the test(s) that use the tester are finished. stdout \u2192 String Everything that was written to stdout during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned. stderr \u2192 String Everything that was written to stderr during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"Tomo::Testing::DockerPluginTester"},{"location":"api/testing/DockerPluginTester/#tomotestingdockerplugintester","text":"Similar to MockPluginTester , DockerPluginTester is a helper object that allows tasks and helpers provided by plugins to be easily tested. A real SSH connection is used and no mocking is performed. Instead, DockerPluginTester builds a Docker image containing a real SSH server and runs it, sending all remote SSH scripts to that Docker container. This allows for true end-to-end testing. The Docker image is based on Ubuntu 18.04. The first time DockerPluginTester is used, the base image will be downloaded and a tomo-specific image will be created, which can take a few minutes. Because of the overhead involved, Docker-based tests should be used sparingly and only when they provide high value over much faster unit tests. Note that you must require \"tomo/testing\" to use DockerPluginTester.","title":"Tomo::Testing::DockerPluginTester"},{"location":"api/testing/DockerPluginTester/#class-methods","text":"","title":"Class methods"},{"location":"api/testing/DockerPluginTester/#new42plugin_names-settings-new_tester","text":"Build a new DockerPluginTester that loads the given list of plugin_names . The resulting tester object can be used to execute any tasks or helpers that are provided by these plugins. Note that the \u201ccore\u201d plugin is always loaded implicitly and does not need to be specified. Creating a new DockerPluginTester will implicitly build and run a Docker image containing an SSH server. This can take a few minutes the first time the image is built. Make sure to call teardown after you are done using the tester.","title":"new(*plugin_names, settings: {}) \u2192 new_tester"},{"location":"api/testing/DockerPluginTester/#instance-methods","text":"","title":"Instance methods"},{"location":"api/testing/DockerPluginTester/#run_tasktask-42args-nil","text":"Run the given task by its fully qualified name (the namespace is required). Any args , if specified, are passed to the task via settings[:run_args] . Any remote SSH scripts run by the task will be executed via an SSH connection to the Docker container.","title":"run_task(task, *args) \u2192 nil"},{"location":"api/testing/DockerPluginTester/#call_helperhelper-42args-4242kwargs-obj","text":"Invoke the specified helper method name with the optional positional args and keyword kwargs . Returns the return value of the helper. Any remote SSH scripts run by the task will be executed via an SSH connection to the Docker container.","title":"call_helper(helper, *args, **kwargs) \u2192 obj"},{"location":"api/testing/DockerPluginTester/#teardown-nil","text":"Stop the underlying Docker container associated with this tester. Be sure to call teardown after the test(s) that use the tester are finished.","title":"teardown \u2192 nil"},{"location":"api/testing/DockerPluginTester/#stdout-string","text":"Everything that was written to stdout during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"stdout \u2192 String"},{"location":"api/testing/DockerPluginTester/#stderr-string","text":"Everything that was written to stderr during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"stderr \u2192 String"},{"location":"api/testing/MockPluginTester/","text":"Tomo::Testing::MockPluginTester MockPluginTester is a helper object that allows tasks and helpers provided by plugins to be easily unit tested. It has no test framework dependencies so it can be used in Minitest, RSpec, or the testing framework of your choice. MockPluginTester works by mocking the underlying SSH connection so that no actual remote SSH scripts are run. By default, the tester will simulate that the script runs successfully (exit status of 0) with empty stdout and stderr. You can then write assertions verifying that the script was run as expected. For example: require \"tomo/testing\" def test_setup_directories tester = Tomo::Testing::MockPluginTester.new(settings: { deploy_to: \"/app\" }) tester.run_task(\"core:setup_directories\") assert_equal(\"mkdir -p /app /app/releases /app/shared\", tester.executed_script) end You can change the default mocking behavior by using mock_script_result , like this: require \"tomo/testing\" def setup @tester = Tomo::Testing::MockPluginTester.new( \"bundler\", \"puma\", settings: { current_path: \"/app/current\", puma_control_url: \"tcp://127.0.0.1:9293\", puma_control_token: \"test\" } ) end def test_restart_starts_puma_if_pumactl_fails @tester.mock_script_result(/pumactl/, exit_status: 1) @tester.run_task(\"puma:restart\") assert_equal( \"cd /app/current && bundle exec puma --daemon \"\\ \"--control-url tcp://127.0.0.1:9293 --control-token test\", @tester.executed_scripts.last ) end Every MockPluginTester instance loads a fresh, independent tomo environment, so mocks, plugins, settings, etc. specified in one tester will not affect any other tests. Note that you must require \"tomo/testing\" to use MockPluginTester. Class methods new(*plugin_names, settings: {}) \u2192 new_tester Build a new MockPluginTester that loads the given list of plugin_names . The resulting tester object can be used to simulate any tasks or helpers that are provided by these plugins. Note that the \u201ccore\u201d plugin is always loaded implicitly and does not need to be specified. Any settings that are specified will be applied after the defaults settings provided by the plugins have been defined. These settings can use template strings just like set . require \"tomo/testing\" tester = Tomo::Testing::MockPluginTester.new( \"bundler\", \"puma\", settings: { current_path: \"/app/current\", puma_control_url: \"tcp://127.0.0.1:9293\", puma_control_token: \"test\" } ) Instance methods run_task(task, *args) \u2192 nil Run the given task by its fully qualified name (the namespace is required). Any args , if specified, are passed to the task via settings[:run_args] . Any remote SSH scripts run by the task (e.g. via remote.run ) will be mocked according to rules previously supplied to mock_script_result . If a mock result has not been explicitly supplied, the script will use a default mock that returns a successful result with no output. require \"tomo/testing\" tester = Tomo::Testing::MockPluginTester.new(\"rails\") tester.run_task(\"rails:log_tail\", \"-F\") assert_equal( \"tail -F /var/www/testing/current/log/${RAILS_ENV}.log\", tester.executed_script ) call_helper(helper, *args, **kwargs) \u2192 obj Invoke the specified helper method name with the optional positional args and keyword kwargs . Returns the return value of the helper. Remote SSH scripts are mocked as explained in run_task . require \"tomo/testing\" def test_capture_returns_stdout_not_stderr tester = Tomo::Testing::MockPluginTester.new tester.mock_script_result(stderr: \"oh no\", stdout: \"hello world\\n\") captured = tester.call_helper(:capture, \"greet\") assert_equal(\"hello world\\n\", captured) end mock_script_result(script=/.*/, stdout: \u201c\u201d, stderr: \u201c\u201d, exit_status: 0) \u2192 self Mock the return value of remote SSH scripts that match the given script . If script is a String, the mock rule will apply only to scripts that match this String exactly. If script is Regexp, the mock rule will apply to any scripts that match that pattern. If script is omitted, the mock rule will apply always. In this example, any task or helper invoked via this tester that runs readline /app/current will receive the given mock stdout response: tester.mock_script_result(\"readlink /app/current\", stdout: <<~OUT) /app/releases/20190420203028 OUT Here, any script that includes pumactl will fail with an exit status of 1: tester.mock_script_result(/pumactl/, exit_status: 1) This mocks all scripts to fail with exit status of 255 and stderr of \u201coh no!\u201d: tester.mock_script_result(exit_status: 255, stderr: \"oh no!\") executed_script \u2192 String The remote SSH script that was run by a previous invocation of run_task or call_helper . If no script was run, then nil is returned. If more that one script was run, this will raise a RuntimeError . executed_scripts \u2192 [String] All remote SSH scripts that were run by a previous invocation of run_task or call_helper . If no script was run, then an empty array is returned. stdout \u2192 String Everything that was written to stdout during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned. stderr \u2192 String Everything that was written to stderr during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"Tomo::Testing::MockPluginTester"},{"location":"api/testing/MockPluginTester/#tomotestingmockplugintester","text":"MockPluginTester is a helper object that allows tasks and helpers provided by plugins to be easily unit tested. It has no test framework dependencies so it can be used in Minitest, RSpec, or the testing framework of your choice. MockPluginTester works by mocking the underlying SSH connection so that no actual remote SSH scripts are run. By default, the tester will simulate that the script runs successfully (exit status of 0) with empty stdout and stderr. You can then write assertions verifying that the script was run as expected. For example: require \"tomo/testing\" def test_setup_directories tester = Tomo::Testing::MockPluginTester.new(settings: { deploy_to: \"/app\" }) tester.run_task(\"core:setup_directories\") assert_equal(\"mkdir -p /app /app/releases /app/shared\", tester.executed_script) end You can change the default mocking behavior by using mock_script_result , like this: require \"tomo/testing\" def setup @tester = Tomo::Testing::MockPluginTester.new( \"bundler\", \"puma\", settings: { current_path: \"/app/current\", puma_control_url: \"tcp://127.0.0.1:9293\", puma_control_token: \"test\" } ) end def test_restart_starts_puma_if_pumactl_fails @tester.mock_script_result(/pumactl/, exit_status: 1) @tester.run_task(\"puma:restart\") assert_equal( \"cd /app/current && bundle exec puma --daemon \"\\ \"--control-url tcp://127.0.0.1:9293 --control-token test\", @tester.executed_scripts.last ) end Every MockPluginTester instance loads a fresh, independent tomo environment, so mocks, plugins, settings, etc. specified in one tester will not affect any other tests. Note that you must require \"tomo/testing\" to use MockPluginTester.","title":"Tomo::Testing::MockPluginTester"},{"location":"api/testing/MockPluginTester/#class-methods","text":"","title":"Class methods"},{"location":"api/testing/MockPluginTester/#new42plugin_names-settings-new_tester","text":"Build a new MockPluginTester that loads the given list of plugin_names . The resulting tester object can be used to simulate any tasks or helpers that are provided by these plugins. Note that the \u201ccore\u201d plugin is always loaded implicitly and does not need to be specified. Any settings that are specified will be applied after the defaults settings provided by the plugins have been defined. These settings can use template strings just like set . require \"tomo/testing\" tester = Tomo::Testing::MockPluginTester.new( \"bundler\", \"puma\", settings: { current_path: \"/app/current\", puma_control_url: \"tcp://127.0.0.1:9293\", puma_control_token: \"test\" } )","title":"new(*plugin_names, settings: {}) \u2192 new_tester"},{"location":"api/testing/MockPluginTester/#instance-methods","text":"","title":"Instance methods"},{"location":"api/testing/MockPluginTester/#run_tasktask-42args-nil","text":"Run the given task by its fully qualified name (the namespace is required). Any args , if specified, are passed to the task via settings[:run_args] . Any remote SSH scripts run by the task (e.g. via remote.run ) will be mocked according to rules previously supplied to mock_script_result . If a mock result has not been explicitly supplied, the script will use a default mock that returns a successful result with no output. require \"tomo/testing\" tester = Tomo::Testing::MockPluginTester.new(\"rails\") tester.run_task(\"rails:log_tail\", \"-F\") assert_equal( \"tail -F /var/www/testing/current/log/${RAILS_ENV}.log\", tester.executed_script )","title":"run_task(task, *args) \u2192 nil"},{"location":"api/testing/MockPluginTester/#call_helperhelper-42args-4242kwargs-obj","text":"Invoke the specified helper method name with the optional positional args and keyword kwargs . Returns the return value of the helper. Remote SSH scripts are mocked as explained in run_task . require \"tomo/testing\" def test_capture_returns_stdout_not_stderr tester = Tomo::Testing::MockPluginTester.new tester.mock_script_result(stderr: \"oh no\", stdout: \"hello world\\n\") captured = tester.call_helper(:capture, \"greet\") assert_equal(\"hello world\\n\", captured) end","title":"call_helper(helper, *args, **kwargs) \u2192 obj"},{"location":"api/testing/MockPluginTester/#mock_script_resultscript42-stdout-stderr-exit_status-0-self","text":"Mock the return value of remote SSH scripts that match the given script . If script is a String, the mock rule will apply only to scripts that match this String exactly. If script is Regexp, the mock rule will apply to any scripts that match that pattern. If script is omitted, the mock rule will apply always. In this example, any task or helper invoked via this tester that runs readline /app/current will receive the given mock stdout response: tester.mock_script_result(\"readlink /app/current\", stdout: <<~OUT) /app/releases/20190420203028 OUT Here, any script that includes pumactl will fail with an exit status of 1: tester.mock_script_result(/pumactl/, exit_status: 1) This mocks all scripts to fail with exit status of 255 and stderr of \u201coh no!\u201d: tester.mock_script_result(exit_status: 255, stderr: \"oh no!\")","title":"mock_script_result(script=/.*/, stdout: \"\", stderr: \"\", exit_status: 0) \u2192 self"},{"location":"api/testing/MockPluginTester/#executed_script-string","text":"The remote SSH script that was run by a previous invocation of run_task or call_helper . If no script was run, then nil is returned. If more that one script was run, this will raise a RuntimeError .","title":"executed_script \u2192 String"},{"location":"api/testing/MockPluginTester/#executed_scripts-string","text":"All remote SSH scripts that were run by a previous invocation of run_task or call_helper . If no script was run, then an empty array is returned.","title":"executed_scripts \u2192 [String]"},{"location":"api/testing/MockPluginTester/#stdout-string","text":"Everything that was written to stdout during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"stdout \u2192 String"},{"location":"api/testing/MockPluginTester/#stderr-string","text":"Everything that was written to stderr during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"stderr \u2192 String"},{"location":"commands/deploy/","text":"","title":"deploy"},{"location":"commands/init/","text":"Hey","title":"init"},{"location":"commands/run/","text":"","title":"run"},{"location":"commands/setup/","text":"","title":"setup"},{"location":"commands/tasks/","text":"","title":"tasks"},{"location":"plugins/bundler/","text":"bundler The bundler plugin installs ruby gem dependencies using bundler. This is required for deploying Rails apps. It also provides conveniences for using bundle exec . Settings Name Purpose Default bundler_install_flags Array of command-line flags to pass to the bundle install command [\"--deployment\"] bundler_gemfile Optionally used to override the location of the Gemfile nil bundler_jobs Amount of concurrency used when downloading/installing gems \"4\" bundler_path Directory where gems where be installed \"%<shared_path>/bundle\" bundler_without Array of Gemfile groups to exclude from installation [\"development\", \"test\"] Tasks bundler:upgrade_bundler Installs the version of bundler required by the app that is being deployed. The version is determined by looking at the BUNDLED WITH entry within the app\u2019s Gemfile.lock . If the app is missing a lockfile this task does nothing. Bundler will be installed withing this command: gem install bundler --conservative --no-document -v VERSION bundler:upgrade_bundler is intended for use as a setup task. It should be run prior to bundler:install to ensure that the correct version bundler is present. bundler:install Runs bundle install to download and install all the dependencies specified by the Gemfile of the app that is being deployed. As a performance optimization, this task will run bundle check first to see if the app\u2019s dependencies have already been installed. If so, bundle install is skipped. bundler:install is intended for use as a deploy task. It should be run prior to any tasks that rely on gems. bundler:clean Runs bundle clean to delete any previously installed gems that are no longer needed by the current version of the app. Cleaning is generally good practice to save disk space and speed up app launch time. bundler:clean is intended for use as a deploy task. It should be run at the conclusion of the deploy after all other tasks. Helpers These helper methods become available on instances of Remote when the bundler plugin is loaded. They accept the same options as Remote#run . remote.bundle(*args, **options) \u2192 Tomo::Result Runs bundle within release_path by default. remote.bundle(\"exec\", \"rails\", \"console\") # $ cd /var/www/my-app/current && bundle exec rails console remote.bundle?(*args, **options) \u2192 true or false Same as bundle but returns true if the command succeeded, false otherwise.","title":"bundler"},{"location":"plugins/bundler/#bundler","text":"The bundler plugin installs ruby gem dependencies using bundler. This is required for deploying Rails apps. It also provides conveniences for using bundle exec .","title":"bundler"},{"location":"plugins/bundler/#settings","text":"Name Purpose Default bundler_install_flags Array of command-line flags to pass to the bundle install command [\"--deployment\"] bundler_gemfile Optionally used to override the location of the Gemfile nil bundler_jobs Amount of concurrency used when downloading/installing gems \"4\" bundler_path Directory where gems where be installed \"%<shared_path>/bundle\" bundler_without Array of Gemfile groups to exclude from installation [\"development\", \"test\"]","title":"Settings"},{"location":"plugins/bundler/#tasks","text":"","title":"Tasks"},{"location":"plugins/bundler/#bundlerupgrade_bundler","text":"Installs the version of bundler required by the app that is being deployed. The version is determined by looking at the BUNDLED WITH entry within the app\u2019s Gemfile.lock . If the app is missing a lockfile this task does nothing. Bundler will be installed withing this command: gem install bundler --conservative --no-document -v VERSION bundler:upgrade_bundler is intended for use as a setup task. It should be run prior to bundler:install to ensure that the correct version bundler is present.","title":"bundler:upgrade_bundler"},{"location":"plugins/bundler/#bundlerinstall","text":"Runs bundle install to download and install all the dependencies specified by the Gemfile of the app that is being deployed. As a performance optimization, this task will run bundle check first to see if the app\u2019s dependencies have already been installed. If so, bundle install is skipped. bundler:install is intended for use as a deploy task. It should be run prior to any tasks that rely on gems.","title":"bundler:install"},{"location":"plugins/bundler/#bundlerclean","text":"Runs bundle clean to delete any previously installed gems that are no longer needed by the current version of the app. Cleaning is generally good practice to save disk space and speed up app launch time. bundler:clean is intended for use as a deploy task. It should be run at the conclusion of the deploy after all other tasks.","title":"bundler:clean"},{"location":"plugins/bundler/#helpers","text":"These helper methods become available on instances of Remote when the bundler plugin is loaded. They accept the same options as Remote#run .","title":"Helpers"},{"location":"plugins/bundler/#remotebundle42args-4242options-tomoresult","text":"Runs bundle within release_path by default. remote.bundle(\"exec\", \"rails\", \"console\") # $ cd /var/www/my-app/current && bundle exec rails console","title":"remote.bundle(*args, **options) \u2192 Tomo::Result"},{"location":"plugins/bundler/#remotebundle42args-4242options-true-or-false","text":"Same as bundle but returns true if the command succeeded, false otherwise.","title":"remote.bundle?(*args, **options) \u2192 true or false"},{"location":"plugins/core/","text":"core The core plugin provides tasks, settings, and helpers that are the fundamental building blocks for most tomo deployments. This plugin is always loaded and available, even if it is not explicitly declared in the configuration file. Settings Name Purpose Default application The name of the application being deployed \"default\" concurrency The maximum number of threads to use when deploying to multiple hosts at once 10 current_path Location of the symlink that points to the currently deployed release \"%<deploy_to/current\" deploy_to The root directory under which all tomo data, releases, etc. are stored \"/var/www/%<application>\" keep_releases Number of releases to keep when pruning old releases with the core:clean_releases task 10 linked_dirs Array of directory names that will be symlinked from the shared directory into each release by the core:symlink_shared task [] linked_files Array of file names that will be symlinked from the shared directory into each release by the core:symlink_shared task [] releases_path Directory where the deploy command creates releases \"%<deploy_to>/releases\" release_json_path Path where the core:write_release_json task will write a JSON file describing the release \"%<release_path>/.tomo_release.json\" revision_log_path Path where the core:log_revision task will append a log message with the date and time of the release \"%<deploy_to>/revisions.log\" run_args A special read-only setting where tomo places any extra arguments that are passed to the run command [] shared_path Directory where files shared between releases are stored; used by core:symlink_shared \"%<deploy_to>/shared\" ssh_connect_timeout The number of seconds tomo will wait before it gives up when trying to open an SSH connection 5 ssh_executable The name (or full path) of the ssh executable \"ssh\" ssh_extra_opts An array of extra command line arguments that tomo will pass to every invocation of the ssh executable [\"-o\", \"PasswordAuthentication=no\"] ssh_forward_agent Whether to forward authentication when connecting via SSH; needed for seamless git+ssh true ssh_reuse_connections Whether to use ControlMaster to keep connections open across multiple invocations of ssh; setting this to false will slow down tomo significantly true ssh_strict_host_key_checking Use \"accept-new\" for a good compromise of security and convenience, true for most security, false for most convenience; note that older versions of ssh do not understand the \"accept-new\" option \"accept-new\" tmp_path Directory where the setup command stages temporary files \"/tmp/tomo\" Tasks core:setup_directories Creates the :deploy_to , :shared_path , and :releases_path directories so that other tasks that rely on these directories can work. This is one of the first tasks that should be run as part of setup . core:symlink_shared Creates a symlink for each directory listed in the :linked_dirs setting and each file in :linked_files . The symlink will point to the directory or file of the same name inside the shared directory. This allows these directories and files to be shared across all releases. Note that if a directory or file already exists in the release, that directory or file will be deleted or overwritten prior to creating the link. For example, given this configuration: set linked_dirs: [\"public/assets\"] set linked_files: [\"config/database.yml\"] Calling this task will run: mkdir -p /var/www/my-app/shared/public/assets \\ /var/www/my-app/releases/20190604204415/public cd /var/www/my-app/releases/20190604204415 && rm -rf public/assets ln -sf /var/www/my-app/shared/public/assets \\ /var/www/my-app/releases/20190604204415/public/assets ln -sfn /var/www/my-app/shared/config/database.yml \\ /var/www/my-app/releases/20190604204415/config/database.yml core:symlink_shared is intended for use as a deploy task. If :linked_dirs and :linked_files are both empty, running this task has no effect. core:symlink_current Promotes the release that is currently being deployed to become the \u201ccurrent\u201d release by updating the current symlink. core:symlink_shared is intended for use as a deploy task. It is typically run after all build steps have completed ( bundler:install , rails:db_migrate , rails:assets_precompile , etc.). core:clean_releases Deletes old releases while maintaining the most recent releases and keeping the current release. The total number of releases kept will be based on the :keep_releases setting. If this setting is absent or zero, running this task has no effect. If you are continuously deploying your application in an automated fashion, the releases can quickly fill up disk space if they are not pruned; hence the need for this task. core:clean_releases is intended for use as a deploy task. It is typically run at the end of a deployment once everything else has succeeded. core:write_release_json Writes a JSON file to the location specified by the :release_json_path setting. This file will contain a JSON object with properties that describe the release. Here is an example: { \"branch\": \"master\", \"author\": \"matt@example.com\", \"revision\": \"0d1cb3212e2f9c43aa49fb172d8d9c726163cecf\", \"revision_date\": \"2019-06-01 17:23:48 -0700\", \"deploy_date\": \"2019-06-05 19:00:26 -0700\", \"deploy_user\": \"mbrictson\" } core:log_revision Appends a message to a log file specified by the :revision_log_path setting. The message contains information about the release. Here is an example entry: 2019-06-05 19:00:26 -0700 - 0d1cb3212e2f9c43aa49fb172d8d9c726163cecf (master) deployed by mbrictson Helpers All of these methods are available on instances of Remote and accept the same options as Remote#run . remote.capture(*command, **options) \u2192 String Run the given command, returning the stdout of that command. If the command did not write to stdout, then return an empty String. Note that stderr is ignored, and an exception will be thrown if the command fails. remote.capture(\"echo\", \"hello\") # => \"hello\" remote.run?(*command, **options) \u2192 true or false Run the given command, returning true if the command succeeded (exit status of 0) or false otherwise. # If java is not installed in the $PATH remote.run?(\"which\", \"java\") # => false remote.write(text:, to:, append: false, **options) \u2192 Tomo::Result Write the given text (must be a String) to the remote path specified by to: . If append is false (the default), the remote file will completely replaced; if true , the file will be appended to. This is designed for small amounts of text (e.g. configuration files), not large or binary data. remote.write text: \"hello world!\\n\", to: paths.shared.join(\"greetings.txt\"), append: true remote.ln_sf(target, link, **options) \u2192 Tomo::Result Create a symlink on the remote host at the path specified at link that points to target . remote.ln_sf(paths.shared.join(\".env\"), paths.release.join(\".env\")) # $ ln -sf /var/www/my-app/shared/.env /var/www/my-app/releases/20190604204415/.env remote.ln_sfn(target, link, **options) \u2192 Tomo::Result Like ln_sf but also passes the -n flag, which deletes an existing file if necessary before creating the link. remote.mkdir_p(*directories, **options) \u2192 Tomo::Result Creates one or more directories on the remote host. remote.mkdir_p(paths.current.dirname, paths.shared) # $ mkdir -p /var/www/my-app /var/www/my-app/shared remote.rm_rf(*paths, **options) \u2192 Tomo::Result Deletes one or more files or directories on the remote host. remote.rm_rf(paths.tmp) # $ rm -rf /tmp/tomo remote.list_files(directory=nil, **options) \u2192 [String] Lists non-hidden files in the specified directory. If directory is omitted, the default SSH login directory is used (typically the deploy user\u2019s home directory). The result will be an array of the directory contents. remote.list_files(\"/var/www/my-app\") # => [\"current\", \"releases\", \"revision.log\", shared\"] remote.command_available?(command_name, **options) \u2192 true or false Runs which on the remote host to determine whether the given command_name is an available executable. Returns true if an executable exists, false otherwise. remote.command_available?(\"java\") # => false remote.file?(file, **options) \u2192 true or false Uses the shell expression [ -f ] to test whether the given file exists on the remote host. Returns true if the path exists and is a normal file, false otherwise. remote.file?(\".bashrc\") # => true remote.executable?(file, **options) \u2192 true or false Uses the shell expression [ -x ] to test whether the given file exists on the remote host. Returns true if the path exists and is executable, false otherwise. remote.executable?(\"/usr/bin/git\") # => true remote.directory?(directory, **options) \u2192 true or false Uses the shell expression [ -d ] to test whether the given directory exists on the remote host. Returns true if the path exists and is a directory, false otherwise. remote.directory?(\"/opt\") # => true","title":"core"},{"location":"plugins/core/#core","text":"The core plugin provides tasks, settings, and helpers that are the fundamental building blocks for most tomo deployments. This plugin is always loaded and available, even if it is not explicitly declared in the configuration file.","title":"core"},{"location":"plugins/core/#settings","text":"Name Purpose Default application The name of the application being deployed \"default\" concurrency The maximum number of threads to use when deploying to multiple hosts at once 10 current_path Location of the symlink that points to the currently deployed release \"%<deploy_to/current\" deploy_to The root directory under which all tomo data, releases, etc. are stored \"/var/www/%<application>\" keep_releases Number of releases to keep when pruning old releases with the core:clean_releases task 10 linked_dirs Array of directory names that will be symlinked from the shared directory into each release by the core:symlink_shared task [] linked_files Array of file names that will be symlinked from the shared directory into each release by the core:symlink_shared task [] releases_path Directory where the deploy command creates releases \"%<deploy_to>/releases\" release_json_path Path where the core:write_release_json task will write a JSON file describing the release \"%<release_path>/.tomo_release.json\" revision_log_path Path where the core:log_revision task will append a log message with the date and time of the release \"%<deploy_to>/revisions.log\" run_args A special read-only setting where tomo places any extra arguments that are passed to the run command [] shared_path Directory where files shared between releases are stored; used by core:symlink_shared \"%<deploy_to>/shared\" ssh_connect_timeout The number of seconds tomo will wait before it gives up when trying to open an SSH connection 5 ssh_executable The name (or full path) of the ssh executable \"ssh\" ssh_extra_opts An array of extra command line arguments that tomo will pass to every invocation of the ssh executable [\"-o\", \"PasswordAuthentication=no\"] ssh_forward_agent Whether to forward authentication when connecting via SSH; needed for seamless git+ssh true ssh_reuse_connections Whether to use ControlMaster to keep connections open across multiple invocations of ssh; setting this to false will slow down tomo significantly true ssh_strict_host_key_checking Use \"accept-new\" for a good compromise of security and convenience, true for most security, false for most convenience; note that older versions of ssh do not understand the \"accept-new\" option \"accept-new\" tmp_path Directory where the setup command stages temporary files \"/tmp/tomo\"","title":"Settings"},{"location":"plugins/core/#tasks","text":"","title":"Tasks"},{"location":"plugins/core/#coresetup_directories","text":"Creates the :deploy_to , :shared_path , and :releases_path directories so that other tasks that rely on these directories can work. This is one of the first tasks that should be run as part of setup .","title":"core:setup_directories"},{"location":"plugins/core/#coresymlink_shared","text":"Creates a symlink for each directory listed in the :linked_dirs setting and each file in :linked_files . The symlink will point to the directory or file of the same name inside the shared directory. This allows these directories and files to be shared across all releases. Note that if a directory or file already exists in the release, that directory or file will be deleted or overwritten prior to creating the link. For example, given this configuration: set linked_dirs: [\"public/assets\"] set linked_files: [\"config/database.yml\"] Calling this task will run: mkdir -p /var/www/my-app/shared/public/assets \\ /var/www/my-app/releases/20190604204415/public cd /var/www/my-app/releases/20190604204415 && rm -rf public/assets ln -sf /var/www/my-app/shared/public/assets \\ /var/www/my-app/releases/20190604204415/public/assets ln -sfn /var/www/my-app/shared/config/database.yml \\ /var/www/my-app/releases/20190604204415/config/database.yml core:symlink_shared is intended for use as a deploy task. If :linked_dirs and :linked_files are both empty, running this task has no effect.","title":"core:symlink_shared"},{"location":"plugins/core/#coresymlink_current","text":"Promotes the release that is currently being deployed to become the \u201ccurrent\u201d release by updating the current symlink. core:symlink_shared is intended for use as a deploy task. It is typically run after all build steps have completed ( bundler:install , rails:db_migrate , rails:assets_precompile , etc.).","title":"core:symlink_current"},{"location":"plugins/core/#coreclean_releases","text":"Deletes old releases while maintaining the most recent releases and keeping the current release. The total number of releases kept will be based on the :keep_releases setting. If this setting is absent or zero, running this task has no effect. If you are continuously deploying your application in an automated fashion, the releases can quickly fill up disk space if they are not pruned; hence the need for this task. core:clean_releases is intended for use as a deploy task. It is typically run at the end of a deployment once everything else has succeeded.","title":"core:clean_releases"},{"location":"plugins/core/#corewrite_release_json","text":"Writes a JSON file to the location specified by the :release_json_path setting. This file will contain a JSON object with properties that describe the release. Here is an example: { \"branch\": \"master\", \"author\": \"matt@example.com\", \"revision\": \"0d1cb3212e2f9c43aa49fb172d8d9c726163cecf\", \"revision_date\": \"2019-06-01 17:23:48 -0700\", \"deploy_date\": \"2019-06-05 19:00:26 -0700\", \"deploy_user\": \"mbrictson\" }","title":"core:write_release_json"},{"location":"plugins/core/#corelog_revision","text":"Appends a message to a log file specified by the :revision_log_path setting. The message contains information about the release. Here is an example entry: 2019-06-05 19:00:26 -0700 - 0d1cb3212e2f9c43aa49fb172d8d9c726163cecf (master) deployed by mbrictson","title":"core:log_revision"},{"location":"plugins/core/#helpers","text":"All of these methods are available on instances of Remote and accept the same options as Remote#run .","title":"Helpers"},{"location":"plugins/core/#remotecapture42command-4242options-string","text":"Run the given command, returning the stdout of that command. If the command did not write to stdout, then return an empty String. Note that stderr is ignored, and an exception will be thrown if the command fails. remote.capture(\"echo\", \"hello\") # => \"hello\"","title":"remote.capture(*command, **options) \u2192 String"},{"location":"plugins/core/#remoterun42command-4242options-true-or-false","text":"Run the given command, returning true if the command succeeded (exit status of 0) or false otherwise. # If java is not installed in the $PATH remote.run?(\"which\", \"java\") # => false","title":"remote.run?(*command, **options) \u2192 true or false"},{"location":"plugins/core/#remotewritetext-to-append-false-4242options-tomoresult","text":"Write the given text (must be a String) to the remote path specified by to: . If append is false (the default), the remote file will completely replaced; if true , the file will be appended to. This is designed for small amounts of text (e.g. configuration files), not large or binary data. remote.write text: \"hello world!\\n\", to: paths.shared.join(\"greetings.txt\"), append: true","title":"remote.write(text:, to:, append: false, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remoteln_sftarget-link-4242options-tomoresult","text":"Create a symlink on the remote host at the path specified at link that points to target . remote.ln_sf(paths.shared.join(\".env\"), paths.release.join(\".env\")) # $ ln -sf /var/www/my-app/shared/.env /var/www/my-app/releases/20190604204415/.env","title":"remote.ln_sf(target, link, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remoteln_sfntarget-link-4242options-tomoresult","text":"Like ln_sf but also passes the -n flag, which deletes an existing file if necessary before creating the link.","title":"remote.ln_sfn(target, link, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remotemkdir_p42directories-4242options-tomoresult","text":"Creates one or more directories on the remote host. remote.mkdir_p(paths.current.dirname, paths.shared) # $ mkdir -p /var/www/my-app /var/www/my-app/shared","title":"remote.mkdir_p(*directories, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remoterm_rf42paths-4242options-tomoresult","text":"Deletes one or more files or directories on the remote host. remote.rm_rf(paths.tmp) # $ rm -rf /tmp/tomo","title":"remote.rm_rf(*paths, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remotelist_filesdirectorynil-4242options-string","text":"Lists non-hidden files in the specified directory. If directory is omitted, the default SSH login directory is used (typically the deploy user\u2019s home directory). The result will be an array of the directory contents. remote.list_files(\"/var/www/my-app\") # => [\"current\", \"releases\", \"revision.log\", shared\"]","title":"remote.list_files(directory=nil, **options) \u2192 [String]"},{"location":"plugins/core/#remotecommand_availablecommand_name-4242options-true-or-false","text":"Runs which on the remote host to determine whether the given command_name is an available executable. Returns true if an executable exists, false otherwise. remote.command_available?(\"java\") # => false","title":"remote.command_available?(command_name, **options) \u2192 true or false"},{"location":"plugins/core/#remotefilefile-4242options-true-or-false","text":"Uses the shell expression [ -f ] to test whether the given file exists on the remote host. Returns true if the path exists and is a normal file, false otherwise. remote.file?(\".bashrc\") # => true","title":"remote.file?(file, **options) \u2192 true or false"},{"location":"plugins/core/#remoteexecutablefile-4242options-true-or-false","text":"Uses the shell expression [ -x ] to test whether the given file exists on the remote host. Returns true if the path exists and is executable, false otherwise. remote.executable?(\"/usr/bin/git\") # => true","title":"remote.executable?(file, **options) \u2192 true or false"},{"location":"plugins/core/#remotedirectorydirectory-4242options-true-or-false","text":"Uses the shell expression [ -d ] to test whether the given directory exists on the remote host. Returns true if the path exists and is a directory, false otherwise. remote.directory?(\"/opt\") # => true","title":"remote.directory?(directory, **options) \u2192 true or false"},{"location":"plugins/env/","text":"env The env plugin manages environment variables on the remote host. It does this by creating an envrc file on the remote host and modifying the .bashrc of the deploy user so that the envrc is always loaded (for both interactive and non-interactive SSH sessions). There are two ways to specify the environment variables that are stored in the envrc file: Use env:set via the command line like tomo run env:set NAME[=VALUE] ... to explicitly set or modify environment variables Specify the :env_vars setting in the tomo configuration and then run the env:update task Note that in order for these tasks to work, you must first run env:setup to ensure the deploy user\u2019s .bashrc is properly configured to read from the envrc file that is managed by this plugin. Settings Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" env_path Location of the envrc file on the remote host \"%<deploy_to>/envrc\" env_vars A hash of environment variable names and values that will configured on the remote host; see env:update for details {} Tasks env:setup Performs an env:update and then modifies the deploy user\u2019s bashrc so that the envrc is automatically loaded for all future SSH sessions. Specifically, this is what is added to the top of the .bashrc file: if [ -f /var/www/my-app/envrc ]; then . /var/www/my-app/envrc fi env:setup is intended for use as a setup task. It must be run before other env tasks. env:update Ensures that all environment variables that are specified in the :env_vars setting are present in the envrc file on the remote host, modifying the envrc file if necessary. For example, given this config: set env_vars: { RAILS_ENV: \"production\", PUMA_THREADS: 20 } This task will ensure that the envrc file is updated to include: export RAILS=production export PUMA_THREADS=20 For environment variables that are used for secrets or other sensitive data, you can specify :prompt instead of the actual value. In this case tomo will prompt interactively for the value the first time it is needed. For example: set env_vars: { SECRET_KEY_BASE: :prompt } The first time env:update is run, tomo will prompt for the value: $ tomo deploy tomo deploy v0.1.0 \u2192 Connecting to user@app.example.com \u2022 env:update SECRET_KEY_BASE? Once the environment variable exists in the envrc file, tomo will no longer prompt for it. env:update is intended for use as a deploy task. It should be run at the beginning of a deploy to ensure that the environment has all the latest values before other tasks are run. env:set Set one or more environment variables in the remote envrc file. This task is intended for use with run and takes command-line arguments. There are two forms: # Set the remote envrc var named KEY to have VALUE $ tomo run env:set KEY=VALUE # Prompt interactively for the value of KEY and then set it in the remote envrc $ tomo run env:set KEY KEY? env:unset Remove one or more environment variables from the remote envrc file. This task is intended for use with run and takes command-line arguments. # Remove the remote envrc var named KEY $ tomo run env:unset KEY","title":"env"},{"location":"plugins/env/#env","text":"The env plugin manages environment variables on the remote host. It does this by creating an envrc file on the remote host and modifying the .bashrc of the deploy user so that the envrc is always loaded (for both interactive and non-interactive SSH sessions). There are two ways to specify the environment variables that are stored in the envrc file: Use env:set via the command line like tomo run env:set NAME[=VALUE] ... to explicitly set or modify environment variables Specify the :env_vars setting in the tomo configuration and then run the env:update task Note that in order for these tasks to work, you must first run env:setup to ensure the deploy user\u2019s .bashrc is properly configured to read from the envrc file that is managed by this plugin.","title":"env"},{"location":"plugins/env/#settings","text":"Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" env_path Location of the envrc file on the remote host \"%<deploy_to>/envrc\" env_vars A hash of environment variable names and values that will configured on the remote host; see env:update for details {}","title":"Settings"},{"location":"plugins/env/#tasks","text":"","title":"Tasks"},{"location":"plugins/env/#envsetup","text":"Performs an env:update and then modifies the deploy user\u2019s bashrc so that the envrc is automatically loaded for all future SSH sessions. Specifically, this is what is added to the top of the .bashrc file: if [ -f /var/www/my-app/envrc ]; then . /var/www/my-app/envrc fi env:setup is intended for use as a setup task. It must be run before other env tasks.","title":"env:setup"},{"location":"plugins/env/#envupdate","text":"Ensures that all environment variables that are specified in the :env_vars setting are present in the envrc file on the remote host, modifying the envrc file if necessary. For example, given this config: set env_vars: { RAILS_ENV: \"production\", PUMA_THREADS: 20 } This task will ensure that the envrc file is updated to include: export RAILS=production export PUMA_THREADS=20 For environment variables that are used for secrets or other sensitive data, you can specify :prompt instead of the actual value. In this case tomo will prompt interactively for the value the first time it is needed. For example: set env_vars: { SECRET_KEY_BASE: :prompt } The first time env:update is run, tomo will prompt for the value: $ tomo deploy tomo deploy v0.1.0 \u2192 Connecting to user@app.example.com \u2022 env:update SECRET_KEY_BASE? Once the environment variable exists in the envrc file, tomo will no longer prompt for it. env:update is intended for use as a deploy task. It should be run at the beginning of a deploy to ensure that the environment has all the latest values before other tasks are run.","title":"env:update"},{"location":"plugins/env/#envset","text":"Set one or more environment variables in the remote envrc file. This task is intended for use with run and takes command-line arguments. There are two forms: # Set the remote envrc var named KEY to have VALUE $ tomo run env:set KEY=VALUE # Prompt interactively for the value of KEY and then set it in the remote envrc $ tomo run env:set KEY KEY?","title":"env:set"},{"location":"plugins/env/#envunset","text":"Remove one or more environment variables from the remote envrc file. This task is intended for use with run and takes command-line arguments. # Remove the remote envrc var named KEY $ tomo run env:unset KEY","title":"env:unset"},{"location":"plugins/git/","text":"git The git plugin uses git running on the remote host to fetch the code of the app being deployed. This \u201cremote pull\u201d technique is currently the only deployment method officially supported by tomo. For this to work, the SSH key you use to connect to the remote host via tomo must match the key expected by the git host (e.g. by GitHub). Settings Name Purpose Default git_branch The branch of the repository to deploy \"master\" git_repo_path Directory on the remote host where a cache of the repository will be stored \"%<deploy_to>/git_repo\" git_exclusions An array of paths (similar to gitignore syntax) that will be excluded when the repository is copied into a release; it is recommend you exclude .tomo/ and other directories not needed in production, like spec/ [] git_env Environment variables that will be set when issuing git commands (hash) { GIT_SSH_COMMAND: \"ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no\" } git_url URL of the git repository; always use the SSH form like git@github.com:username/repo.git (not HTTPS) nil Tasks git:clone Performs the initial clone of the git repository. This is necessary before a deploy can be performed. The clone of the repository will be stored in the git_repo_path . The git_url setting must be specified for this task to work. git:clone is intended for use as a setup task. git:create_release Fetches the latest commits from git_branch and creates a release by copying the contents of that branch of repository into a new release inside the releases_path . Releases are numbered based on the timestamp of when the deploy takes place. git:create_release is intended for use as a deploy task. Helpers These helper methods become available on instances of Remote when the git plugin is loaded. They accept the same options as Remote#run . remote.git(*args, **options) \u2192 Tomo::Result Runs git with the environment variables specified by the git_env setting. remote.git(\"fetch\") # $ export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication=no\\ -o\\ StrictHostKeyChecking=no && git fetch","title":"git"},{"location":"plugins/git/#git","text":"The git plugin uses git running on the remote host to fetch the code of the app being deployed. This \u201cremote pull\u201d technique is currently the only deployment method officially supported by tomo. For this to work, the SSH key you use to connect to the remote host via tomo must match the key expected by the git host (e.g. by GitHub).","title":"git"},{"location":"plugins/git/#settings","text":"Name Purpose Default git_branch The branch of the repository to deploy \"master\" git_repo_path Directory on the remote host where a cache of the repository will be stored \"%<deploy_to>/git_repo\" git_exclusions An array of paths (similar to gitignore syntax) that will be excluded when the repository is copied into a release; it is recommend you exclude .tomo/ and other directories not needed in production, like spec/ [] git_env Environment variables that will be set when issuing git commands (hash) { GIT_SSH_COMMAND: \"ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no\" } git_url URL of the git repository; always use the SSH form like git@github.com:username/repo.git (not HTTPS) nil","title":"Settings"},{"location":"plugins/git/#tasks","text":"","title":"Tasks"},{"location":"plugins/git/#gitclone","text":"Performs the initial clone of the git repository. This is necessary before a deploy can be performed. The clone of the repository will be stored in the git_repo_path . The git_url setting must be specified for this task to work. git:clone is intended for use as a setup task.","title":"git:clone"},{"location":"plugins/git/#gitcreate_release","text":"Fetches the latest commits from git_branch and creates a release by copying the contents of that branch of repository into a new release inside the releases_path . Releases are numbered based on the timestamp of when the deploy takes place. git:create_release is intended for use as a deploy task.","title":"git:create_release"},{"location":"plugins/git/#helpers","text":"These helper methods become available on instances of Remote when the git plugin is loaded. They accept the same options as Remote#run .","title":"Helpers"},{"location":"plugins/git/#remotegit42args-4242options-tomoresult","text":"Runs git with the environment variables specified by the git_env setting. remote.git(\"fetch\") # $ export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication=no\\ -o\\ StrictHostKeyChecking=no && git fetch","title":"remote.git(*args, **options) \u2192 Tomo::Result"},{"location":"plugins/nvm/","text":"nvm The nvm plugin installs node and optionally yarn via nvm. This allows you to deploy an app with confidence that particular versions of these tools will be available on the host. This plugin is strongly recommended for Rails apps, which by default use webpacker and thus require node and yarn. Settings Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" nvm_version Version of nvm to install \"0.34.0\" nvm_node_version Version of node to install nil nvm_yarn_version Version of yarn to install nil Tasks nvm:install Installs nvm, uses nvm to install node, and makes the desired version of node the global default version for the deploy user. During installation, the user\u2019s bashrc file is modified so that nvm is automatically loaded for interactive and non-interactive shells. You must supply a value for the nvm_node_version setting for this task to work. If the nvm_yarn_version setting is specified, yarn is also installed globally via npm. This setting is optional. nvm:install is intended for use as a setup task.","title":"nvm"},{"location":"plugins/nvm/#nvm","text":"The nvm plugin installs node and optionally yarn via nvm. This allows you to deploy an app with confidence that particular versions of these tools will be available on the host. This plugin is strongly recommended for Rails apps, which by default use webpacker and thus require node and yarn.","title":"nvm"},{"location":"plugins/nvm/#settings","text":"Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" nvm_version Version of nvm to install \"0.34.0\" nvm_node_version Version of node to install nil nvm_yarn_version Version of yarn to install nil","title":"Settings"},{"location":"plugins/nvm/#tasks","text":"","title":"Tasks"},{"location":"plugins/nvm/#nvminstall","text":"Installs nvm, uses nvm to install node, and makes the desired version of node the global default version for the deploy user. During installation, the user\u2019s bashrc file is modified so that nvm is automatically loaded for interactive and non-interactive shells. You must supply a value for the nvm_node_version setting for this task to work. If the nvm_yarn_version setting is specified, yarn is also installed globally via npm. This setting is optional. nvm:install is intended for use as a setup task.","title":"nvm:install"},{"location":"plugins/puma/","text":"puma The puma plugin provides basic, zero-configuration support for the default Rails web server. Settings Name Purpose Default puma_control_token Auth token to use when connecting to the puma control server \"tomo\" puma_control_url Connection URL for the puma control server \"tcp://127.0.0.1:9293\" Tasks puma:restart Attempts to restart the puma web server via pumactl . If puma is not already running or has crashed, this task will gracefully perform a cold start of the server instead. The puma gem must be present in the Rails application Gemfile for this task to work. Puma is started with this command: bundle exec puma --daemon The config/puma.rb file within the Rails app is used for configuration. puma:restart is intended for use in a deploy , immediately following core:symlink_current to ensure that the new version of the Rails app is activated.","title":"puma"},{"location":"plugins/puma/#puma","text":"The puma plugin provides basic, zero-configuration support for the default Rails web server.","title":"puma"},{"location":"plugins/puma/#settings","text":"Name Purpose Default puma_control_token Auth token to use when connecting to the puma control server \"tomo\" puma_control_url Connection URL for the puma control server \"tcp://127.0.0.1:9293\"","title":"Settings"},{"location":"plugins/puma/#tasks","text":"","title":"Tasks"},{"location":"plugins/puma/#pumarestart","text":"Attempts to restart the puma web server via pumactl . If puma is not already running or has crashed, this task will gracefully perform a cold start of the server instead. The puma gem must be present in the Rails application Gemfile for this task to work. Puma is started with this command: bundle exec puma --daemon The config/puma.rb file within the Rails app is used for configuration. puma:restart is intended for use in a deploy , immediately following core:symlink_current to ensure that the new version of the Rails app is activated.","title":"puma:restart"},{"location":"plugins/rails/","text":"rails The rails plugin provides tasks for running rails and rake commands commonly used during setup and deployment, such as for precompiling assets and migrating the database. Make sure the RAILS_ENV environment variable is set prior to running rails tasks. The env plugin is the preferred mechanism for this. Settings None. Tasks rails:assets_precompile Builds the asset pipeline in preparation for deployment. This is necessary for Rails apps that use the asset pipeline, which is all new Rails apps by default. Running this task will execute this script: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake assets:precompile rails:assets_precompile is intended for use as a deploy task. It is typically run just prior to core:symlink_current to activate a new release. rails:console Starts an interactive Rails console via SSH to the remote host. This task is intended for use as a run task and accepts command-line arguments. The arguments are passed through to the console. For example: $ tomo run -- rails:console --sandbox Will run this remote script: cd /var/www/my-app/current && bundle exec rails console --sandbox rails:db_migrate Migrates the database by running: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake db:migrate rails:db_migrate is intended for use as a deploy task. It is typically run just after bundler:install prior to activating a new release. rails:db_seed Loads seed data into the database. Seeds should be written to be idempotent, such that it is safe to seed the database on each deploy. Typically seeds are used to load reference data need for the app to function, or for example to create an initial admin user. This task runs the following script: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake db:seed rails:db_seed is intended for use as a deploy task. Since seeds rely on the structure of the database, it is typically run just after rails:db_migrate . Helpers These helper methods become available on instances of Remote when the rails plugin is loaded. They accept the same options as Remote#run . remote.rails(*args, **options) \u2192 Tomo::Result Runs bundle exec rails in within paths.release by default. remote.rails(\"routes\") # $ cd /var/www/my-app/releases/20190604204415 && bundle exec rails routes remote.rake(*args, **options) \u2192 Tomo::Result Runs bundle exec rake in within paths.release by default. remote.rake(\"db:migrate\") # $ cd /var/www/my-app/releases/20190604204415 && bundle exec rake db:migrate remote.rake?(*args, **options) \u2192 true or false Like rake but returns true if the command succeeds (exit status 0), otherwise false . remote.rake?(\"db:migrate\") # => true","title":"rails"},{"location":"plugins/rails/#rails","text":"The rails plugin provides tasks for running rails and rake commands commonly used during setup and deployment, such as for precompiling assets and migrating the database. Make sure the RAILS_ENV environment variable is set prior to running rails tasks. The env plugin is the preferred mechanism for this.","title":"rails"},{"location":"plugins/rails/#settings","text":"None.","title":"Settings"},{"location":"plugins/rails/#tasks","text":"","title":"Tasks"},{"location":"plugins/rails/#railsassets_precompile","text":"Builds the asset pipeline in preparation for deployment. This is necessary for Rails apps that use the asset pipeline, which is all new Rails apps by default. Running this task will execute this script: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake assets:precompile rails:assets_precompile is intended for use as a deploy task. It is typically run just prior to core:symlink_current to activate a new release.","title":"rails:assets_precompile"},{"location":"plugins/rails/#railsconsole","text":"Starts an interactive Rails console via SSH to the remote host. This task is intended for use as a run task and accepts command-line arguments. The arguments are passed through to the console. For example: $ tomo run -- rails:console --sandbox Will run this remote script: cd /var/www/my-app/current && bundle exec rails console --sandbox","title":"rails:console"},{"location":"plugins/rails/#railsdb_migrate","text":"Migrates the database by running: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake db:migrate rails:db_migrate is intended for use as a deploy task. It is typically run just after bundler:install prior to activating a new release.","title":"rails:db_migrate"},{"location":"plugins/rails/#railsdb_seed","text":"Loads seed data into the database. Seeds should be written to be idempotent, such that it is safe to seed the database on each deploy. Typically seeds are used to load reference data need for the app to function, or for example to create an initial admin user. This task runs the following script: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake db:seed rails:db_seed is intended for use as a deploy task. Since seeds rely on the structure of the database, it is typically run just after rails:db_migrate .","title":"rails:db_seed"},{"location":"plugins/rails/#helpers","text":"These helper methods become available on instances of Remote when the rails plugin is loaded. They accept the same options as Remote#run .","title":"Helpers"},{"location":"plugins/rails/#remoterails42args-4242options-tomoresult","text":"Runs bundle exec rails in within paths.release by default. remote.rails(\"routes\") # $ cd /var/www/my-app/releases/20190604204415 && bundle exec rails routes","title":"remote.rails(*args, **options) \u2192 Tomo::Result"},{"location":"plugins/rails/#remoterake42args-4242options-tomoresult","text":"Runs bundle exec rake in within paths.release by default. remote.rake(\"db:migrate\") # $ cd /var/www/my-app/releases/20190604204415 && bundle exec rake db:migrate","title":"remote.rake(*args, **options) \u2192 Tomo::Result"},{"location":"plugins/rails/#remoterake42args-4242options-true-or-false","text":"Like rake but returns true if the command succeeds (exit status 0), otherwise false . remote.rake?(\"db:migrate\") # => true","title":"remote.rake?(*args, **options) \u2192 true or false"},{"location":"plugins/rbenv/","text":"rbenv The rbenv plugin provides a way to install and run a desired version of ruby. This is the recommended way to manage ruby for Rails apps. Settings Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" rbenv_ruby_version Version of ruby to install nil Tasks rbenv:install Installs rbenv, uses rbenv to install ruby, and makes the desired version of ruby the global default version for the deploy user. During installation, the user\u2019s bashrc file is modified so that rbenv is automatically loaded for interactive and non-interactive shells. Behind the scenes, rbenv installs ruby via ruby-build, which compiles ruby from source. This means installation can take several minutes. If the desired version of ruby is already installed, the compilation step will be skipped. You must supply a value for the rbenv_ruby_version setting for this task to work. rbenv:install is intended for use as a setup task.","title":"rbenv"},{"location":"plugins/rbenv/#rbenv","text":"The rbenv plugin provides a way to install and run a desired version of ruby. This is the recommended way to manage ruby for Rails apps.","title":"rbenv"},{"location":"plugins/rbenv/#settings","text":"Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" rbenv_ruby_version Version of ruby to install nil","title":"Settings"},{"location":"plugins/rbenv/#tasks","text":"","title":"Tasks"},{"location":"plugins/rbenv/#rbenvinstall","text":"Installs rbenv, uses rbenv to install ruby, and makes the desired version of ruby the global default version for the deploy user. During installation, the user\u2019s bashrc file is modified so that rbenv is automatically loaded for interactive and non-interactive shells. Behind the scenes, rbenv installs ruby via ruby-build, which compiles ruby from source. This means installation can take several minutes. If the desired version of ruby is already installed, the compilation step will be skipped. You must supply a value for the rbenv_ruby_version setting for this task to work. rbenv:install is intended for use as a setup task.","title":"rbenv:install"},{"location":"tutorials/deploying-rails-from-scratch/","text":"Deploying Rails From Scratch Coming soon\u2026","title":"Deploying Rails From Scratch"},{"location":"tutorials/deploying-rails-from-scratch/#deploying-rails-from-scratch","text":"Coming soon\u2026","title":"Deploying Rails From Scratch"},{"location":"tutorials/publishing-a-plugin/","text":"Publishing a Plugin Coming soon\u2026","title":"Publishing a Plugin"},{"location":"tutorials/publishing-a-plugin/#publishing-a-plugin","text":"Coming soon\u2026","title":"Publishing a Plugin"},{"location":"tutorials/writing-custom-tasks/","text":"Writing Custom Tasks Coming soon\u2026","title":"Writing Custom Tasks"},{"location":"tutorials/writing-custom-tasks/#writing-custom-tasks","text":"Coming soon\u2026","title":"Writing Custom Tasks"}]}