{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tomo Tomo is a friendly command-line tool for deploying Rails apps. It is a new alternative to Capistrano, Mina, and Shipit that optimizes for simplicity and developer happiness. \ud83d\udcbb Rich command-line interface with built-in bash completions \u2601\ufe0f Multi-environment and role-based multi-host support \ud83d\udc8e Everything you need to deploy a basic Rails app out of the box \ud83d\udd0c Easily extensible for polyglot projects (not just Rails!) \ud83d\udca1 Concise, helpful error messages \ud83d\udcda Quality documentation \ud83d\udd2c Minimal dependencies This project wouldn\u2019t be possible without the generosity of the open source Ruby community. Please support open source projects and your fellow developers by helping answer questions, contributing pull requests to improve code and documentation, or just drop a note to say thanks! \u2764\ufe0f Quick start Reference documentation FAQ Support License Code of conduct Contribution guide [TODO] Quick start Tomo is distributed as a ruby gem. To install: $ gem install tomo Getting help An easy way to kick the tires is to view the --help . Configuring a project Let\u2019s init a project to see how tomo is configured. The .tomo/config.rb file defines all the settings and tasks needed to setup and deploy a typical Rails project. An abbreviated version looks like this: # .tomo/config.rb plugin \"git\" plugin \"bundler\" plugin \"rails\" # ... host \"user@hostname.or.ip.address\" set application: \"my-rails-app\" set deploy_to: \"/var/www/%<application>\" set git_url: \"git@github.com:my-username/my-rails-app.git\" set git_branch: \"master\" # ... setup do run \"git:clone\" run \"git:create_release\" run \"bundler:install\" run \"rails:db_schema_load\" # ... end deploy do run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" run \"core:symlink_current\" # ... end Eventually you\u2019ll want to edit the config file to specify the appropriate user and host, perhaps define some custom tasks, and tweak the settings to make them suitable for your Rails app. You can also take advantage of more advanced features like multiple hosts and environment-based config. Host setup With tomo, an initial deployment is separated into two distinct steps. The setup command prepares the host for its first deploy. Let\u2019s take a look at the documentation with --help : We can simulate the setup operation with the --dry-run option. Let\u2019s try it: As you can see, the setup command in this project clones the git repository, installs ruby, node, bundler, and initializes the database. One the host is set up, it is ready for its first deploy. Performing a deploy Typically you only need to run setup once. From then on deploying a project is a matter of running the deploy command. Like setup , this can be simulated with --dry-run , like this: Running a single task Tomo can also run individual remote tasks. Use the tasks command to see the list of tasks tomo knows about. One of the built-in Rails tasks is rails:console , which brings up a fully-interactive Rails console over SSH. We can simulate this with --dry-run as well. Writing tasks Tomo has many plugins built-in, but you can easily add your own to extend tomo with custom tasks. By convention, custom plugins are stored in .tomo/plugins/ . These plugins can define tasks as plain ruby methods. For example: # .tomo/plugins/my-plugin.rb def hello remote.run \"echo\", \"hello\", settings[:application] end Use remote.run to execute shell scripts on the remote host, similar to how you would use Ruby\u2019s system . Project settings are accessible via settings , which is a plain Ruby hash. Load your plugin in config.rb like this: # .tomo/config.rb plugin \"./plugins/my-plugin.rb\" And run it! Next steps And just like that, you are now already familiar with the basics of tomo and how to extend it! Tomo is even more friendly and powerful with the help of bash completions. If you use bash, run tomo completion-script for instructions on setting them up. To prepare your existing project for a real deploy, check out the sections of the reference documentation on configuration , writing custom tasks , the setup command , and the deploy command . There is also a tutorial that walks through deploying a new Rails app from scratch [TODO]. If you have questions, check out the FAQ and support notes below. Enjoy using tomo! Reference documentation Configuration Commands init setup deploy run tasks Plugins core bundler env git nvm puma rails rbenv Tutorials Deploying Rails From Scratch [TODO] Writing Custom Tasks Publishing a Plugin [TODO] API Host Logger Paths PluginDSL Remote Result TaskLibrary Testing::MockPluginTester Testing::DockerPluginTester FAQ What does the unsupported option \"accept-new\" error mean? By default, tomo uses the \u201caccept-new\u201d value for the StrictHostKeyChecking option, which is supported by OpenSSH 7.6 and newer. If you are using an older version, this will cause an error. As a workaround, you can override tomo\u2019s default behavior like this: # Replace \"accept-new\" with something compatible with older versions of SSH set ssh_strict_host_key_checking: true # or false Support Thanks for your interest in Tomo! I use Tomo myself to deploy my own Rails projects and intend to keep this repository working and up to date for the foreseeable future. However Tomo is only a hobby, and as the sole maintainer, my ability to provide support and review pull request is limited and a bit sporadic. My priorities right now are: Improve test coverage Keep the project free of any serious bugs Stay up to date with the latest versions of Ruby and gem dependencies If you\u2019d like to help by submitting a pull request, that would be much appreciated! Check out the contribution guide to get started. Otherwise if you want to report a bug, or have ideas, feedback or questions about Tomo, let me know via GitHub issues and I will do my best to provide a helpful answer. Happy hacking! \u2014Matt License The gem is available as open source under the terms of the MIT License . Code of conduct Everyone interacting in the Tomo project\u2019s codebases, issue trackers, chat rooms and mailing lists is expected to follow the code of conduct . Contribution guide [TODO]","title":"Home"},{"location":"#tomo","text":"Tomo is a friendly command-line tool for deploying Rails apps. It is a new alternative to Capistrano, Mina, and Shipit that optimizes for simplicity and developer happiness. \ud83d\udcbb Rich command-line interface with built-in bash completions \u2601\ufe0f Multi-environment and role-based multi-host support \ud83d\udc8e Everything you need to deploy a basic Rails app out of the box \ud83d\udd0c Easily extensible for polyglot projects (not just Rails!) \ud83d\udca1 Concise, helpful error messages \ud83d\udcda Quality documentation \ud83d\udd2c Minimal dependencies This project wouldn\u2019t be possible without the generosity of the open source Ruby community. Please support open source projects and your fellow developers by helping answer questions, contributing pull requests to improve code and documentation, or just drop a note to say thanks! \u2764\ufe0f Quick start Reference documentation FAQ Support License Code of conduct Contribution guide [TODO]","title":"Tomo"},{"location":"#quick-start","text":"Tomo is distributed as a ruby gem. To install: $ gem install tomo","title":"Quick start"},{"location":"#getting-help","text":"An easy way to kick the tires is to view the --help .","title":"Getting help"},{"location":"#configuring-a-project","text":"Let\u2019s init a project to see how tomo is configured. The .tomo/config.rb file defines all the settings and tasks needed to setup and deploy a typical Rails project. An abbreviated version looks like this: # .tomo/config.rb plugin \"git\" plugin \"bundler\" plugin \"rails\" # ... host \"user@hostname.or.ip.address\" set application: \"my-rails-app\" set deploy_to: \"/var/www/%<application>\" set git_url: \"git@github.com:my-username/my-rails-app.git\" set git_branch: \"master\" # ... setup do run \"git:clone\" run \"git:create_release\" run \"bundler:install\" run \"rails:db_schema_load\" # ... end deploy do run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" run \"core:symlink_current\" # ... end Eventually you\u2019ll want to edit the config file to specify the appropriate user and host, perhaps define some custom tasks, and tweak the settings to make them suitable for your Rails app. You can also take advantage of more advanced features like multiple hosts and environment-based config.","title":"Configuring a project"},{"location":"#host-setup","text":"With tomo, an initial deployment is separated into two distinct steps. The setup command prepares the host for its first deploy. Let\u2019s take a look at the documentation with --help : We can simulate the setup operation with the --dry-run option. Let\u2019s try it: As you can see, the setup command in this project clones the git repository, installs ruby, node, bundler, and initializes the database. One the host is set up, it is ready for its first deploy.","title":"Host setup"},{"location":"#performing-a-deploy","text":"Typically you only need to run setup once. From then on deploying a project is a matter of running the deploy command. Like setup , this can be simulated with --dry-run , like this:","title":"Performing a deploy"},{"location":"#running-a-single-task","text":"Tomo can also run individual remote tasks. Use the tasks command to see the list of tasks tomo knows about. One of the built-in Rails tasks is rails:console , which brings up a fully-interactive Rails console over SSH. We can simulate this with --dry-run as well.","title":"Running a single task"},{"location":"#writing-tasks","text":"Tomo has many plugins built-in, but you can easily add your own to extend tomo with custom tasks. By convention, custom plugins are stored in .tomo/plugins/ . These plugins can define tasks as plain ruby methods. For example: # .tomo/plugins/my-plugin.rb def hello remote.run \"echo\", \"hello\", settings[:application] end Use remote.run to execute shell scripts on the remote host, similar to how you would use Ruby\u2019s system . Project settings are accessible via settings , which is a plain Ruby hash. Load your plugin in config.rb like this: # .tomo/config.rb plugin \"./plugins/my-plugin.rb\" And run it!","title":"Writing tasks"},{"location":"#next-steps","text":"And just like that, you are now already familiar with the basics of tomo and how to extend it! Tomo is even more friendly and powerful with the help of bash completions. If you use bash, run tomo completion-script for instructions on setting them up. To prepare your existing project for a real deploy, check out the sections of the reference documentation on configuration , writing custom tasks , the setup command , and the deploy command . There is also a tutorial that walks through deploying a new Rails app from scratch [TODO]. If you have questions, check out the FAQ and support notes below. Enjoy using tomo!","title":"Next steps"},{"location":"#reference-documentation","text":"Configuration Commands init setup deploy run tasks Plugins core bundler env git nvm puma rails rbenv Tutorials Deploying Rails From Scratch [TODO] Writing Custom Tasks Publishing a Plugin [TODO] API Host Logger Paths PluginDSL Remote Result TaskLibrary Testing::MockPluginTester Testing::DockerPluginTester","title":"Reference documentation"},{"location":"#faq","text":"","title":"FAQ"},{"location":"#what-does-the-unsupported-option-accept-new-error-mean","text":"By default, tomo uses the \u201caccept-new\u201d value for the StrictHostKeyChecking option, which is supported by OpenSSH 7.6 and newer. If you are using an older version, this will cause an error. As a workaround, you can override tomo\u2019s default behavior like this: # Replace \"accept-new\" with something compatible with older versions of SSH set ssh_strict_host_key_checking: true # or false","title":"What does the unsupported option \"accept-new\" error mean?"},{"location":"#support","text":"Thanks for your interest in Tomo! I use Tomo myself to deploy my own Rails projects and intend to keep this repository working and up to date for the foreseeable future. However Tomo is only a hobby, and as the sole maintainer, my ability to provide support and review pull request is limited and a bit sporadic. My priorities right now are: Improve test coverage Keep the project free of any serious bugs Stay up to date with the latest versions of Ruby and gem dependencies If you\u2019d like to help by submitting a pull request, that would be much appreciated! Check out the contribution guide to get started. Otherwise if you want to report a bug, or have ideas, feedback or questions about Tomo, let me know via GitHub issues and I will do my best to provide a helpful answer. Happy hacking! \u2014Matt","title":"Support"},{"location":"#license","text":"The gem is available as open source under the terms of the MIT License .","title":"License"},{"location":"#code-of-conduct","text":"Everyone interacting in the Tomo project\u2019s codebases, issue trackers, chat rooms and mailing lists is expected to follow the code of conduct .","title":"Code of conduct"},{"location":"#contribution-guide","text":"[TODO]","title":"Contribution guide"},{"location":"configuration/","text":"Configuration Tomo is configured via a .tomo/config.rb file. This configuration file defines what tasks to run when executing a setup or deploy , the settings that affect the behavior of those tasks, and the remote host or hosts where those tasks will be run. The format of tomo\u2019s configuration file is designed to be simple and concise for basic deployments, with the flexibility to scale to more advanced setups that involve multiple roles, environments, and hosts. A basic deployment will typically use these configuration directives: plugin host set setup deploy Here\u2019s an abbreviated example: plugin \"git\" plugin \"bundler\" plugin \"rails\" # ... host \"deployer@app.example.com\" set application: \"my-rails-app\" set deploy_to: \"/var/www/%<application>\" set git_url: \"git@github.com:my-username/my-rails-app.git\" set git_branch: \"master\" # ... setup do run \"git:clone\" run \"git:create_release\" run \"bundler:install\" run \"rails:db_schema_load\" # ... end deploy do run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" run \"core:symlink_current\" # ... end A more complex deployment may make use of these additional directives: environment role batch plugin(name_or_relative_path) Load a tomo plugin by name or from a Ruby file by a relative path. Several plugins are built into tomo: bundler , env , git , nvm , puma , rails , and rbenv . If you want to use the tasks provided by one of these plugins, load it by name, like this: plugin \"git\" Plugins can also be provided by gems installed on your system. For example, the tomo-plugin-rollbar gem provides the \u201crollbar\u201d plugin. Make sure the gem is installed (e.g. in your Gemfile) and then reference the plugin by name to load it: plugin \"rollbar\" Note that the name of the plugin may not necessarily match the name of the gem. Refer to the gem\u2019s documentation for installation instructions. Finally, if the argument to plugin starts with a dot ( . ) it is considered a relative path to a custom plugin. By convention, custom plugins are stored in .tomo/plugins/ within the project that tomo is deploying. The name of the plugin is inferred from its file name. So for example, if the plugin is loaded from a file named foo.rb , then the name of the plugin is \u201cfoo\u201d and all tasks it defines will be given the foo: namespace: plugin \"./plugins/foo.rb\" host(address, **options) Specify the SSH host address (including username) that tomo will connect to. For example: host \"deployer@app.example.com\" # port 22 is implied host \"admin@192.168.1.50\", port: 8022 # port 8022 The following advanced options are supported: Name Purpose Default port SSH port number. 22 roles An array of String roles to assign to this host. Used with the role directive for specifying which tasks should run on this host. [] log_prefix A String prefix to print next to all log output for this host. nil privileged_user The SSH user to connect as when running privileged tasks. See setup for an example. \"root\" set(hash) Specify a value for a tomo setting. For example, to change the number of releases that tomo retains when pruning old releases: set keep_releases: 5 For a full list of settings that affect tomo\u2019s core behavior, refer to the core plugin documentation . Each plugin such as bundler and git also has its own specialized list of settings. Refer to the each plugin\u2019s documentation for a full reference. Interpolation It is possible to reference other settings when specifying a value. The format of a reference string is %<name> where name is the name of another setting. This is often used to build paths that are relative to the release that is being deployed, or for paths relative to tomo\u2019s shared directory. In this example, the value will be interpolated to contain the release that is being deployed: set release_json_path: \"%<release_path>/.tomo_release.json\" # => \"/var/www/my-app/20190523234156/.tomo_release.json\" Another common use case is the shared directory: set bundler_path: \"%<shared_path>/bundle\" # => \"/var/www/my-app/shared/bundle\" Interpolation takes place after tomo has loaded all configuration, plugins, and overrides, just before tasks are run. Custom settings set will define a setting if it does not already exist. This means you can create arbitrarily-named settings for your own purposes, such as for use within custom tasks. set my_setting_i_just_made_up: \"great\" In practice most settings are strings, but any Ruby value is possible. set some_double: 0.57 set my_hash: { urgent: true, message: \"hello\" } Overrides Settings defined by set can be overridden when running a tomo command, e.g. tomo deploy , by way of environment variables and command-line arguments. Environment variable overrides take the form of TOMO_* . For example, this will override the :git_branch setting to be \u201cdevelop\u201d: $ export TOMO_GIT_BRANCH=develop $ tomo deploy On the command line, -s or --setting can be used. For example: $ tomo deploy -s git_branch=develop The precedence of overrides is as follows (higher in the list have higher precedence): Command-line overrides Environment variable overrides set Defaults (specified by plugins) setup(&block) Define the list of tasks that will be run by the tomo setup command, by providing a block containing run directives, like this: setup do run \"env:setup\" run \"core:setup_directories\" run \"git:clone\" run \"git:create_release\" run \"core:symlink_shared\" run \"nvm:install\" run \"rbenv:install\" run \"bundler:upgrade_bundler\" run \"bundler:install\" run \"rails:db_create\" run \"rails:db_schema_load\" run \"rails:db_seed\" end Each run can optionally take a privileged: true option. When specified, the task will be run using the \u201croot\u201d user instead of the default user specified for each host . setup do run \"apt:install\", privileged: true end deploy(&block) Define the list of tasks that will be run by the tomo deploy command, by providing a block containing run directives, like this: deploy do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:db_migrate\" run \"rails:db_seed\" run \"rails:assets_precompile\" run \"core:symlink_current\" run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end environment(name, &block) Define an environment so that tomo can be used to deploy the same project with more than one set of configuration. Each environment must have a unique name and can contain its own host and set directives. For example: # Top-level config is shared by both environments set git_url: \"git@github.com:username/repo.git\" environment :staging do host \"deployer@staging.example.com\" set git_branch: \"develop\" end environment :production do host \"deployer@app.example.com\" set git_branch: \"master\" end Use the -e or --environment option when running tomo to select which environment to use. role(name, runs:) Specify that certain task(s) are only allowed to run on hosts that have the role name . The runs option must be an array of Strings representing task names. Simple wildcards (glob rules using * ) can be used to match multiple tasks. By default, every task that is listed in setup and deploy blocks is run on every host. In a multi-host deployment this is not always desirable. For example, the rails:db_seed and rails:db_migrate tasks should only be run once per deployment (i.e. on one host). To accomplish this, we can define a role named \u201cdb\u201d that is responsible for running these tasks, like this: role \"db\", runs: [\"rails:db_*\"] host \"deployer@app1.example.com\", roles: [\"db\"] host \"deployer@app2.example.com\", roles: [] The role directive in the example above tells tomo that any task matching the glob pattern rails:db_* should only run on hosts that are assigned the \u201cdb\u201d role. That means that app1.example.com will run rails:db_seed and rails:db_migrate , but app2.example.com will not. batch(&block) Define a group tasks to run in parallel during a multi-host deploy. This allows one host to \u201crace ahead\u201d of other hosts and leads to potentially faster deployments. In a multi-host deployment, by default each task in a setup and deploy must complete on all hosts before tomo will move onto the next task. This means a deployment is limited by its slowest host. If a task is configured via role to run on only one host (e.g. rails:db_migrate ), other hosts must wait until the task is done. We can speed this up by using batch , as in this example: deploy do # All tasks in this batch must complete before tomo will move onto # core:symlink_current, but within the batch each host can \"race ahead\" # independently in parallel. batch do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" end # This task must complete on all hosts before moving onto the next batch. run \"core:symlink_current\" # The tasks within this batch can run independently in parallel on each host. batch do run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end end In the above configuration, we care that core:symlink_current is executed at the same time on all hosts, but before and after that, the other tasks can be executed out of sync.","title":"Configuration"},{"location":"configuration/#configuration","text":"Tomo is configured via a .tomo/config.rb file. This configuration file defines what tasks to run when executing a setup or deploy , the settings that affect the behavior of those tasks, and the remote host or hosts where those tasks will be run. The format of tomo\u2019s configuration file is designed to be simple and concise for basic deployments, with the flexibility to scale to more advanced setups that involve multiple roles, environments, and hosts. A basic deployment will typically use these configuration directives: plugin host set setup deploy Here\u2019s an abbreviated example: plugin \"git\" plugin \"bundler\" plugin \"rails\" # ... host \"deployer@app.example.com\" set application: \"my-rails-app\" set deploy_to: \"/var/www/%<application>\" set git_url: \"git@github.com:my-username/my-rails-app.git\" set git_branch: \"master\" # ... setup do run \"git:clone\" run \"git:create_release\" run \"bundler:install\" run \"rails:db_schema_load\" # ... end deploy do run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" run \"core:symlink_current\" # ... end A more complex deployment may make use of these additional directives: environment role batch","title":"Configuration"},{"location":"configuration/#pluginname_or_relative_path","text":"Load a tomo plugin by name or from a Ruby file by a relative path. Several plugins are built into tomo: bundler , env , git , nvm , puma , rails , and rbenv . If you want to use the tasks provided by one of these plugins, load it by name, like this: plugin \"git\" Plugins can also be provided by gems installed on your system. For example, the tomo-plugin-rollbar gem provides the \u201crollbar\u201d plugin. Make sure the gem is installed (e.g. in your Gemfile) and then reference the plugin by name to load it: plugin \"rollbar\" Note that the name of the plugin may not necessarily match the name of the gem. Refer to the gem\u2019s documentation for installation instructions. Finally, if the argument to plugin starts with a dot ( . ) it is considered a relative path to a custom plugin. By convention, custom plugins are stored in .tomo/plugins/ within the project that tomo is deploying. The name of the plugin is inferred from its file name. So for example, if the plugin is loaded from a file named foo.rb , then the name of the plugin is \u201cfoo\u201d and all tasks it defines will be given the foo: namespace: plugin \"./plugins/foo.rb\"","title":"plugin(name_or_relative_path)"},{"location":"configuration/#hostaddress-4242options","text":"Specify the SSH host address (including username) that tomo will connect to. For example: host \"deployer@app.example.com\" # port 22 is implied host \"admin@192.168.1.50\", port: 8022 # port 8022 The following advanced options are supported: Name Purpose Default port SSH port number. 22 roles An array of String roles to assign to this host. Used with the role directive for specifying which tasks should run on this host. [] log_prefix A String prefix to print next to all log output for this host. nil privileged_user The SSH user to connect as when running privileged tasks. See setup for an example. \"root\"","title":"host(address, **options)"},{"location":"configuration/#sethash","text":"Specify a value for a tomo setting. For example, to change the number of releases that tomo retains when pruning old releases: set keep_releases: 5 For a full list of settings that affect tomo\u2019s core behavior, refer to the core plugin documentation . Each plugin such as bundler and git also has its own specialized list of settings. Refer to the each plugin\u2019s documentation for a full reference.","title":"set(hash)"},{"location":"configuration/#interpolation","text":"It is possible to reference other settings when specifying a value. The format of a reference string is %<name> where name is the name of another setting. This is often used to build paths that are relative to the release that is being deployed, or for paths relative to tomo\u2019s shared directory. In this example, the value will be interpolated to contain the release that is being deployed: set release_json_path: \"%<release_path>/.tomo_release.json\" # => \"/var/www/my-app/20190523234156/.tomo_release.json\" Another common use case is the shared directory: set bundler_path: \"%<shared_path>/bundle\" # => \"/var/www/my-app/shared/bundle\" Interpolation takes place after tomo has loaded all configuration, plugins, and overrides, just before tasks are run.","title":"Interpolation"},{"location":"configuration/#custom-settings","text":"set will define a setting if it does not already exist. This means you can create arbitrarily-named settings for your own purposes, such as for use within custom tasks. set my_setting_i_just_made_up: \"great\" In practice most settings are strings, but any Ruby value is possible. set some_double: 0.57 set my_hash: { urgent: true, message: \"hello\" }","title":"Custom settings"},{"location":"configuration/#overrides","text":"Settings defined by set can be overridden when running a tomo command, e.g. tomo deploy , by way of environment variables and command-line arguments. Environment variable overrides take the form of TOMO_* . For example, this will override the :git_branch setting to be \u201cdevelop\u201d: $ export TOMO_GIT_BRANCH=develop $ tomo deploy On the command line, -s or --setting can be used. For example: $ tomo deploy -s git_branch=develop The precedence of overrides is as follows (higher in the list have higher precedence): Command-line overrides Environment variable overrides set Defaults (specified by plugins)","title":"Overrides"},{"location":"configuration/#setupblock","text":"Define the list of tasks that will be run by the tomo setup command, by providing a block containing run directives, like this: setup do run \"env:setup\" run \"core:setup_directories\" run \"git:clone\" run \"git:create_release\" run \"core:symlink_shared\" run \"nvm:install\" run \"rbenv:install\" run \"bundler:upgrade_bundler\" run \"bundler:install\" run \"rails:db_create\" run \"rails:db_schema_load\" run \"rails:db_seed\" end Each run can optionally take a privileged: true option. When specified, the task will be run using the \u201croot\u201d user instead of the default user specified for each host . setup do run \"apt:install\", privileged: true end","title":"setup(&amp;block)"},{"location":"configuration/#deployblock","text":"Define the list of tasks that will be run by the tomo deploy command, by providing a block containing run directives, like this: deploy do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:db_migrate\" run \"rails:db_seed\" run \"rails:assets_precompile\" run \"core:symlink_current\" run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end","title":"deploy(&amp;block)"},{"location":"configuration/#environmentname-block","text":"Define an environment so that tomo can be used to deploy the same project with more than one set of configuration. Each environment must have a unique name and can contain its own host and set directives. For example: # Top-level config is shared by both environments set git_url: \"git@github.com:username/repo.git\" environment :staging do host \"deployer@staging.example.com\" set git_branch: \"develop\" end environment :production do host \"deployer@app.example.com\" set git_branch: \"master\" end Use the -e or --environment option when running tomo to select which environment to use.","title":"environment(name, &amp;block)"},{"location":"configuration/#rolename-runs","text":"Specify that certain task(s) are only allowed to run on hosts that have the role name . The runs option must be an array of Strings representing task names. Simple wildcards (glob rules using * ) can be used to match multiple tasks. By default, every task that is listed in setup and deploy blocks is run on every host. In a multi-host deployment this is not always desirable. For example, the rails:db_seed and rails:db_migrate tasks should only be run once per deployment (i.e. on one host). To accomplish this, we can define a role named \u201cdb\u201d that is responsible for running these tasks, like this: role \"db\", runs: [\"rails:db_*\"] host \"deployer@app1.example.com\", roles: [\"db\"] host \"deployer@app2.example.com\", roles: [] The role directive in the example above tells tomo that any task matching the glob pattern rails:db_* should only run on hosts that are assigned the \u201cdb\u201d role. That means that app1.example.com will run rails:db_seed and rails:db_migrate , but app2.example.com will not.","title":"role(name, runs:)"},{"location":"configuration/#batchblock","text":"Define a group tasks to run in parallel during a multi-host deploy. This allows one host to \u201crace ahead\u201d of other hosts and leads to potentially faster deployments. In a multi-host deployment, by default each task in a setup and deploy must complete on all hosts before tomo will move onto the next task. This means a deployment is limited by its slowest host. If a task is configured via role to run on only one host (e.g. rails:db_migrate ), other hosts must wait until the task is done. We can speed this up by using batch , as in this example: deploy do # All tasks in this batch must complete before tomo will move onto # core:symlink_current, but within the batch each host can \"race ahead\" # independently in parallel. batch do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:assets_precompile\" run \"rails:db_migrate\" end # This task must complete on all hosts before moving onto the next batch. run \"core:symlink_current\" # The tasks within this batch can run independently in parallel on each host. batch do run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end end In the above configuration, we care that core:symlink_current is executed at the same time on all hosts, but before and after that, the other tasks can be executed out of sync.","title":"batch(&amp;block)"},{"location":"api/Host/","text":"Tomo::Host Represents a remote SSH host. host.address # => \"example.com\" host.port # => 22 host.user # => \"deployer\" host.roles # => [\"app\", \"db\"] host.to_s # => \"deployer@example.com\" A Host is always frozen and cannot be modified. Instance methods address \u2192 String The host name or IP address. port \u2192 Integer The SSH port, usually 22. user \u2192 String The username used when connecting to the host via SSH. roles \u2192 [String] An array of roles that are assigned to this host. Roles are used in multi-host deployments to control which tasks are run on which hosts. to_s \u2192 String A representation of host in the form of user@address:port . If the port is 22, that portion is omitted.","title":"Tomo::Host"},{"location":"api/Host/#tomohost","text":"Represents a remote SSH host. host.address # => \"example.com\" host.port # => 22 host.user # => \"deployer\" host.roles # => [\"app\", \"db\"] host.to_s # => \"deployer@example.com\" A Host is always frozen and cannot be modified.","title":"Tomo::Host"},{"location":"api/Host/#instance-methods","text":"","title":"Instance methods"},{"location":"api/Host/#address-string","text":"The host name or IP address.","title":"address \u2192 String"},{"location":"api/Host/#port-integer","text":"The SSH port, usually 22.","title":"port \u2192 Integer"},{"location":"api/Host/#user-string","text":"The username used when connecting to the host via SSH.","title":"user \u2192 String"},{"location":"api/Host/#roles-string","text":"An array of roles that are assigned to this host. Roles are used in multi-host deployments to control which tasks are run on which hosts.","title":"roles \u2192 [String]"},{"location":"api/Host/#to_s-string","text":"A representation of host in the form of user@address:port . If the port is 22, that portion is omitted.","title":"to_s \u2192 String"},{"location":"api/Logger/","text":"Tomo::Logger Provides a simple interface for logging messages to stdout and stderr. In multi-host deployments, messages are automatically prefixed with [1] , [2] , etc. based on current host. This makes it easier to distinguish where log messages are coming from. $ tomo run bundler:clean tomo run v0.1.0 [1] \u2192 Connecting to deployer@web1.example.com [2] \u2192 Connecting to deployer@web2.example.com [1] \u2022 bundler:clean [2] \u2022 bundler:clean [1] cd /home/deployer/apps/my-app/current && bundle clean [2] cd /home/deployer/apps/my-app/current && bundle clean \u2714 Ran bundler:clean on deployer@web1.example.com and deployer@web2.example.com If tomo is run in --dry-run mode, log messages are prefixed with a * to indicate the commands are being simulated. $ tomo run bundler:clean --dry-run tomo run v0.1.0 * [1] \u2192 Connecting to deployer@web1.example.com * [2] \u2192 Connecting to deployer@web2.example.com * [1] \u2022 bundler:clean * [2] \u2022 bundler:clean * [1] cd /home/deployer/apps/my-app/current && bundle clean * [2] cd /home/deployer/apps/my-app/current && bundle clean * Simulated bundler:clean on deployer@web1.example.com and deployer@web2.example.com (dry run) Instance methods debug(message) \u2192 nil Prints a message to stderr in gray with a DEBUG: prefix. Debug messages are only shown if tomo is run with the --debug option. Otherwise this is a no-op. info(message) \u2192 nil Prints a message to stdout . warn(message) \u2192 nil Prints a message to stderr with a red WARNING: prefix. error(message) \u2192 nil Prints a message to stderr with a red ERROR: prefix, indented, and with leading and trailing blank lines for extra emphasis.","title":"Tomo::Logger"},{"location":"api/Logger/#tomologger","text":"Provides a simple interface for logging messages to stdout and stderr. In multi-host deployments, messages are automatically prefixed with [1] , [2] , etc. based on current host. This makes it easier to distinguish where log messages are coming from. $ tomo run bundler:clean tomo run v0.1.0 [1] \u2192 Connecting to deployer@web1.example.com [2] \u2192 Connecting to deployer@web2.example.com [1] \u2022 bundler:clean [2] \u2022 bundler:clean [1] cd /home/deployer/apps/my-app/current && bundle clean [2] cd /home/deployer/apps/my-app/current && bundle clean \u2714 Ran bundler:clean on deployer@web1.example.com and deployer@web2.example.com If tomo is run in --dry-run mode, log messages are prefixed with a * to indicate the commands are being simulated. $ tomo run bundler:clean --dry-run tomo run v0.1.0 * [1] \u2192 Connecting to deployer@web1.example.com * [2] \u2192 Connecting to deployer@web2.example.com * [1] \u2022 bundler:clean * [2] \u2022 bundler:clean * [1] cd /home/deployer/apps/my-app/current && bundle clean * [2] cd /home/deployer/apps/my-app/current && bundle clean * Simulated bundler:clean on deployer@web1.example.com and deployer@web2.example.com (dry run)","title":"Tomo::Logger"},{"location":"api/Logger/#instance-methods","text":"","title":"Instance methods"},{"location":"api/Logger/#debugmessage-nil","text":"Prints a message to stderr in gray with a DEBUG: prefix. Debug messages are only shown if tomo is run with the --debug option. Otherwise this is a no-op.","title":"debug(message) \u2192 nil"},{"location":"api/Logger/#infomessage-nil","text":"Prints a message to stdout .","title":"info(message) \u2192 nil"},{"location":"api/Logger/#warnmessage-nil","text":"Prints a message to stderr with a red WARNING: prefix.","title":"warn(message) \u2192 nil"},{"location":"api/Logger/#errormessage-nil","text":"Prints a message to stderr with a red ERROR: prefix, indented, and with leading and trailing blank lines for extra emphasis.","title":"error(message) \u2192 nil"},{"location":"api/Paths/","text":"Tomo::Paths Provides syntactic sugar for accessing settings that represent file system paths. For every tomo setting in the form :<name>_path , Paths will expose a method of that name that behaves like a Ruby Pathname object. As a special exception, the :deploy_to setting is also exposed even though it does not follow the same naming convention. In tomo the following path settings are always available: settings[:deploy_to] # => \"/var/www/my-app\" settings[:current_path] # => \"/var/www/my-app/current\" settings[:release_path] # => \"/var/www/my-app/releases/20190531164322\" settings[:releases_path] # => \"/var/www/my-app/releases\" settings[:shared_path] # => \"/var/www/my-app/shared\" Using Paths, these same settings can be accessed like this: paths.deploy_to # => \"/var/www/my-app\" paths.current # => \"/var/www/my-app/current\" paths.release # => \"/var/www/my-app/releases/20190531164322\" paths.releases # => \"/var/www/my-app/releases\" paths.shared # => \"/var/www/my-app/shared\" More powerfully, the values returned by Paths respond to join and dirname , so you can easily compose them: paths.current.dirname # => \"/var/www/my-app\" paths.release.join(\"tmp\") # => \"/var/www/my-app/releases/20190531164322/tmp\" paths.shared.join(\"bundle\") # => \"/var/www/my-app/shared/bundle\" Paths can be used wherever a path string is expected, like chdir : remote.chdir(paths.current) do remote.run(\"bundle\", \"exec\", \"puma\", \"--daemon\") end # $ cd /var/www/my-app/current && bundle exec puma --daemon If a plugin defines a setting with the suffix _path or if you create your own setting with that suffix, it automatically will be exposed via the Paths object: # .tomo/config.rb set my_custom_path: \"/opt/custom\" paths.my_custom.join(\"var\") # => \"/opt/custom/var\"","title":"Tomo::Paths"},{"location":"api/Paths/#tomopaths","text":"Provides syntactic sugar for accessing settings that represent file system paths. For every tomo setting in the form :<name>_path , Paths will expose a method of that name that behaves like a Ruby Pathname object. As a special exception, the :deploy_to setting is also exposed even though it does not follow the same naming convention. In tomo the following path settings are always available: settings[:deploy_to] # => \"/var/www/my-app\" settings[:current_path] # => \"/var/www/my-app/current\" settings[:release_path] # => \"/var/www/my-app/releases/20190531164322\" settings[:releases_path] # => \"/var/www/my-app/releases\" settings[:shared_path] # => \"/var/www/my-app/shared\" Using Paths, these same settings can be accessed like this: paths.deploy_to # => \"/var/www/my-app\" paths.current # => \"/var/www/my-app/current\" paths.release # => \"/var/www/my-app/releases/20190531164322\" paths.releases # => \"/var/www/my-app/releases\" paths.shared # => \"/var/www/my-app/shared\" More powerfully, the values returned by Paths respond to join and dirname , so you can easily compose them: paths.current.dirname # => \"/var/www/my-app\" paths.release.join(\"tmp\") # => \"/var/www/my-app/releases/20190531164322/tmp\" paths.shared.join(\"bundle\") # => \"/var/www/my-app/shared/bundle\" Paths can be used wherever a path string is expected, like chdir : remote.chdir(paths.current) do remote.run(\"bundle\", \"exec\", \"puma\", \"--daemon\") end # $ cd /var/www/my-app/current && bundle exec puma --daemon If a plugin defines a setting with the suffix _path or if you create your own setting with that suffix, it automatically will be exposed via the Paths object: # .tomo/config.rb set my_custom_path: \"/opt/custom\" paths.my_custom.join(\"var\") # => \"/opt/custom/var\"","title":"Tomo::Paths"},{"location":"api/PluginDSL/","text":"Tomo::PluginDSL A tomo plugin is defined by a Ruby module that extends Tomo::PluginDSL. A plugin definition can specify three things: Default settings Tasks Helpers Here is the bundler plugin as an example: require_relative \"bundler/helpers\" require_relative \"bundler/tasks\" module Tomo::Plugin::Bundler extend Tomo::PluginDSL tasks Tomo::Plugin::Bundler::Tasks helpers Tomo::Plugin::Bundler::Helpers defaults bundler_install_flags: [\"--deployment\"], bundler_gemfile: nil, bundler_jobs: \"4\", bundler_path: \"%<shared_path>/bundle\", bundler_without: %w[development test] end The above plugin defines several default settings, defines tasks using a TaskLibrary named Tomo::Plugin::Bundler::Tasks , and defines helpers in a module named Tomo::Plugin::Bundler::Helpers . Refer to the Publishing a Plugin tutorial for more information about packaging and distributing tomo plugins. Instance methods defaults(hash) Specify default settings that will be applied when this plugin is loaded. Although not strictly necessary, it is best practice to list all required and optional settings that are used by the plugin, even if the default values are nil . This lets other developers know what setting names are expected when using the plugin. Settings must use symbol keys and typically String values, although any Ruby type is possible. Strings can contain interpolated values . module Tomo::Plugin::Bundler extend Tomo::PluginDSL defaults bundler_install_flags: [\"--deployment\"], bundler_gemfile: nil, bundler_jobs: \"4\", bundler_path: \"%<shared_path>/bundle\", bundler_without: %w[development test] end tasks(*task_library_class) Specify the tasks that will be defined by this plugin by supplying one or more TaskLibrary classes. The public instance methods of each class will be turned into tomo tasks. class Tomo::Plugin::Git::Tasks < Tomo::TaskLibrary def clone # ... end def create_release # ... end end class Tomo::Plugin::Git extend Tomo::PluginDSL tasks Tomo::Plugin::Git::Tasks end You can use self to define a plugin and its tasks together as a single class: class Tomo::Plugin::Git < Tomo::TaskLibrary extend Tomo::PluginDSL tasks self def clone # ... end def create_release # ... end end helpers(*module) Specify the helpers that will be defined by this plugin by supplying one or more plain Ruby modules. The modules will be mixed in at runtime to extend the Remote interface with additional methods. module Tomo::Plugin::Core::Helpers def ln_sf(target, link, **run_opts) # ... end def mkdir_p(*directories, **run_opts) # ... end end module Tomo::Plugin::Core extend Tomo::PluginDSL helpers Tomo::Plugin::Core::Helpers end","title":"Tomo::PluginDSL"},{"location":"api/PluginDSL/#tomoplugindsl","text":"A tomo plugin is defined by a Ruby module that extends Tomo::PluginDSL. A plugin definition can specify three things: Default settings Tasks Helpers Here is the bundler plugin as an example: require_relative \"bundler/helpers\" require_relative \"bundler/tasks\" module Tomo::Plugin::Bundler extend Tomo::PluginDSL tasks Tomo::Plugin::Bundler::Tasks helpers Tomo::Plugin::Bundler::Helpers defaults bundler_install_flags: [\"--deployment\"], bundler_gemfile: nil, bundler_jobs: \"4\", bundler_path: \"%<shared_path>/bundle\", bundler_without: %w[development test] end The above plugin defines several default settings, defines tasks using a TaskLibrary named Tomo::Plugin::Bundler::Tasks , and defines helpers in a module named Tomo::Plugin::Bundler::Helpers . Refer to the Publishing a Plugin tutorial for more information about packaging and distributing tomo plugins.","title":"Tomo::PluginDSL"},{"location":"api/PluginDSL/#instance-methods","text":"","title":"Instance methods"},{"location":"api/PluginDSL/#defaultshash","text":"Specify default settings that will be applied when this plugin is loaded. Although not strictly necessary, it is best practice to list all required and optional settings that are used by the plugin, even if the default values are nil . This lets other developers know what setting names are expected when using the plugin. Settings must use symbol keys and typically String values, although any Ruby type is possible. Strings can contain interpolated values . module Tomo::Plugin::Bundler extend Tomo::PluginDSL defaults bundler_install_flags: [\"--deployment\"], bundler_gemfile: nil, bundler_jobs: \"4\", bundler_path: \"%<shared_path>/bundle\", bundler_without: %w[development test] end","title":"defaults(hash)"},{"location":"api/PluginDSL/#tasks42task_library_class","text":"Specify the tasks that will be defined by this plugin by supplying one or more TaskLibrary classes. The public instance methods of each class will be turned into tomo tasks. class Tomo::Plugin::Git::Tasks < Tomo::TaskLibrary def clone # ... end def create_release # ... end end class Tomo::Plugin::Git extend Tomo::PluginDSL tasks Tomo::Plugin::Git::Tasks end You can use self to define a plugin and its tasks together as a single class: class Tomo::Plugin::Git < Tomo::TaskLibrary extend Tomo::PluginDSL tasks self def clone # ... end def create_release # ... end end","title":"tasks(*task_library_class)"},{"location":"api/PluginDSL/#helpers42module","text":"Specify the helpers that will be defined by this plugin by supplying one or more plain Ruby modules. The modules will be mixed in at runtime to extend the Remote interface with additional methods. module Tomo::Plugin::Core::Helpers def ln_sf(target, link, **run_opts) # ... end def mkdir_p(*directories, **run_opts) # ... end end module Tomo::Plugin::Core extend Tomo::PluginDSL helpers Tomo::Plugin::Core::Helpers end","title":"helpers(*module)"},{"location":"api/Remote/","text":"Tomo::Remote A Remote represents an SSH connection to a remote host and provides a fa\u00e7ade for building and running shell scripts on that host. A Remote instance is always implicitly available within the context of a task implementation as remote . The tomo framework takes care of initializing the SSH connection and setting this reference. The most basic use of Remote is the run method, which executes a script on the remote host: remote.run \"echo\", \"hello world\" For building more complex scripts, Remote offers a variety of builder methods: chdir , env , prepend , and umask . Here is an example of some of them: remote.chdir(paths.current) do remote.prepend(\"bundle exec\") do remote.env(DISABLE_SPRING: \"1\") do remote.run(\"rails\", \"db:prepare\") end end end # $ cd /var/www/my-app/current && export DISABLE_SPRING=1 && bundle exec rails db:prepare Instance methods In addition the methods listed here, all helpers provided by the core plugin are also available, as are helpers from any other plugins that have been explicitly loaded in .tomo/config.rb . Refer to the documentation for each plugin for details. run(*command, **options) \u2192 Tomo::Result Runs a shell script on the remote host via SSH. The command can take one of two forms. If given as a single string, the command is executed as a shell script directly; no escaping is performed. This is useful if your script needs to specify output redirection ( > or >> ), pipes, or other shell logic ( && or || ). For example: remote.run \"bundle exec rails db:prepare > /dev/null && echo 'All set!'\" # $ bundle exec rails db:prepare > /dev/null && echo 'All set!' If the command is given as multiple string arguments, then each argument is individually shell-escaped and then assembled into a shell script. This is the preferred way to safely run scripts, especially if the script relies on settings or other user input. For example: settings[:greeting] # => \"<this> is safe & easy\" remote.run \"echo\", settings[:greeting] # $ echo \\<this\\>\\ is\\ safe\\ \\&\\ easy When a script is run it is first echoed to the console and all of its output (stdout and stderr) is streamed to the console as well. If the script fails then an exception will be raised. If the script succeeds, a Result object will be returned. This behavior can be customized by specifying options , which can include: Name Purpose Default :echo Similar to -x in bash, setting echo: true will cause the script to be printed to the logger before it is run. If false , the script will be run without being printed. If a string is provided, the string will be printed instead of the actual script. This can be useful for redacting or abbreviating sensitive or very long scripts. true :silent Normally stdout and stderr of the remote script are printed to the logger. Setting silent: true will silence this output. Note that even if silenced, the output can still be accessed via the Result . false :raise_on_error By default, if the remote script fails (i.e. returns an exit status other than 0), tomo will raise an exception, stopping execution. If the script being executed is expected to fail, or you would like to take action based on failure, set raise_on_error: false . In this case a failed script will return a Result with failure? set to true . true :default_chdir The working directory where the script will be run by default, if chdir is not used. If not specified, the working directory is based on the SSH server\u2019s default login directory (almost always this is the user\u2019s home directory). nil :attach Setting attach: true will cause the script to be run as if attach had been called instead. false :pty Setting pty: true will instruct the SSH client to allocate a pseudo-tty when running the script. false attach(*command, **options) Runs a script on the remote host via SSH, just like run , except the Ruby process will be replaced with the SSH process and control completely handed over to SSH (this is done via Process.exec ). In other words, tomo will immediately stop and it will be like you had run SSH directly. This is useful for things like running a Rails console, where you would like to \u201cattach\u201d stdin/stdout to the remote process. Typically pty: true is used in these situations to force a tty. remote.attach \"bundle exec rails console\", pty: true attach accepts the same options as run (except for :attach , which is redundant). chdir(dir, &block) \u2192 obj Changes into the specified dir when executing a script via run or attach . Must be used with a block. This causes cd <dir> && to be prepended to the script. remote.chdir \"/opt/data\" do remote.run \"ls -al\" end # $ cd /opt/data && ls -al chdir returns the value of its block. env(hash, &block) \u2192 obj Sets environment variables when executing a script via run or attach . Must be used with a block. This causes export VAR1=value VAR2=value ... && to be prepended to the script. The environment variables are specified as a Ruby hash. remote.env(CLICOLOR_FORCE: \"1\", RAILS_ENV: \"production\") do remote.run \"bundle exec sidekiq\" end # $ export CLICOLOR_FORCE=1 RAILS_ENV=production && bundle exec sidekiq env returns the value of its block. prepend(*command, &block) \u2192 obj Prepends an arbitrary command when executing a script via run or attach . Must be used with a block. remote.prepend \"bundle\", \"exec\" do remote.run \"rails routes\" end # $ bundle exec rails routes prepend returns the value of its block. umask(mask, &block) \u2192 obj Sets a umask when executing a script via run or attach . Must be used with a block. This causes umask ... && to be prepended to the script. The mask can be an Integer (typically expressed in octal) or a String. remote.umask 0o077 do remote.run \"touch a_file\" end # $ umask 0077 && touch a_file umask returns the value of its block. host \u2192 Tomo::Host The remote SSH host that scripts will be run on. release \u2192 Hash A mutable Hash that can be used to share data about the release that is being deployed. Data stored in this Hash can be read by other tasks. In practice this is used by the git:create_release task to store the branch, author, SHA, date, etc. of the release. This data can then be accessed by other tasks that are interested in this information. result = remote.run('git log -n1 --pretty=format:\"%ae\"') remote.release[:author] = result.stdout.chomp # remote.release[:author] can now be read by other tasks that connect to this host","title":"Tomo::Remote"},{"location":"api/Remote/#tomoremote","text":"A Remote represents an SSH connection to a remote host and provides a fa\u00e7ade for building and running shell scripts on that host. A Remote instance is always implicitly available within the context of a task implementation as remote . The tomo framework takes care of initializing the SSH connection and setting this reference. The most basic use of Remote is the run method, which executes a script on the remote host: remote.run \"echo\", \"hello world\" For building more complex scripts, Remote offers a variety of builder methods: chdir , env , prepend , and umask . Here is an example of some of them: remote.chdir(paths.current) do remote.prepend(\"bundle exec\") do remote.env(DISABLE_SPRING: \"1\") do remote.run(\"rails\", \"db:prepare\") end end end # $ cd /var/www/my-app/current && export DISABLE_SPRING=1 && bundle exec rails db:prepare","title":"Tomo::Remote"},{"location":"api/Remote/#instance-methods","text":"In addition the methods listed here, all helpers provided by the core plugin are also available, as are helpers from any other plugins that have been explicitly loaded in .tomo/config.rb . Refer to the documentation for each plugin for details.","title":"Instance methods"},{"location":"api/Remote/#run42command-4242options-tomoresult","text":"Runs a shell script on the remote host via SSH. The command can take one of two forms. If given as a single string, the command is executed as a shell script directly; no escaping is performed. This is useful if your script needs to specify output redirection ( > or >> ), pipes, or other shell logic ( && or || ). For example: remote.run \"bundle exec rails db:prepare > /dev/null && echo 'All set!'\" # $ bundle exec rails db:prepare > /dev/null && echo 'All set!' If the command is given as multiple string arguments, then each argument is individually shell-escaped and then assembled into a shell script. This is the preferred way to safely run scripts, especially if the script relies on settings or other user input. For example: settings[:greeting] # => \"<this> is safe & easy\" remote.run \"echo\", settings[:greeting] # $ echo \\<this\\>\\ is\\ safe\\ \\&\\ easy When a script is run it is first echoed to the console and all of its output (stdout and stderr) is streamed to the console as well. If the script fails then an exception will be raised. If the script succeeds, a Result object will be returned. This behavior can be customized by specifying options , which can include: Name Purpose Default :echo Similar to -x in bash, setting echo: true will cause the script to be printed to the logger before it is run. If false , the script will be run without being printed. If a string is provided, the string will be printed instead of the actual script. This can be useful for redacting or abbreviating sensitive or very long scripts. true :silent Normally stdout and stderr of the remote script are printed to the logger. Setting silent: true will silence this output. Note that even if silenced, the output can still be accessed via the Result . false :raise_on_error By default, if the remote script fails (i.e. returns an exit status other than 0), tomo will raise an exception, stopping execution. If the script being executed is expected to fail, or you would like to take action based on failure, set raise_on_error: false . In this case a failed script will return a Result with failure? set to true . true :default_chdir The working directory where the script will be run by default, if chdir is not used. If not specified, the working directory is based on the SSH server\u2019s default login directory (almost always this is the user\u2019s home directory). nil :attach Setting attach: true will cause the script to be run as if attach had been called instead. false :pty Setting pty: true will instruct the SSH client to allocate a pseudo-tty when running the script. false","title":"run(*command, **options) \u2192 Tomo::Result"},{"location":"api/Remote/#attach42command-4242options","text":"Runs a script on the remote host via SSH, just like run , except the Ruby process will be replaced with the SSH process and control completely handed over to SSH (this is done via Process.exec ). In other words, tomo will immediately stop and it will be like you had run SSH directly. This is useful for things like running a Rails console, where you would like to \u201cattach\u201d stdin/stdout to the remote process. Typically pty: true is used in these situations to force a tty. remote.attach \"bundle exec rails console\", pty: true attach accepts the same options as run (except for :attach , which is redundant).","title":"attach(*command, **options)"},{"location":"api/Remote/#chdirdir-block-obj","text":"Changes into the specified dir when executing a script via run or attach . Must be used with a block. This causes cd <dir> && to be prepended to the script. remote.chdir \"/opt/data\" do remote.run \"ls -al\" end # $ cd /opt/data && ls -al chdir returns the value of its block.","title":"chdir(dir, &amp;block) \u2192 obj"},{"location":"api/Remote/#envhash-block-obj","text":"Sets environment variables when executing a script via run or attach . Must be used with a block. This causes export VAR1=value VAR2=value ... && to be prepended to the script. The environment variables are specified as a Ruby hash. remote.env(CLICOLOR_FORCE: \"1\", RAILS_ENV: \"production\") do remote.run \"bundle exec sidekiq\" end # $ export CLICOLOR_FORCE=1 RAILS_ENV=production && bundle exec sidekiq env returns the value of its block.","title":"env(hash, &amp;block) \u2192 obj"},{"location":"api/Remote/#prepend42command-block-obj","text":"Prepends an arbitrary command when executing a script via run or attach . Must be used with a block. remote.prepend \"bundle\", \"exec\" do remote.run \"rails routes\" end # $ bundle exec rails routes prepend returns the value of its block.","title":"prepend(*command, &amp;block) \u2192 obj"},{"location":"api/Remote/#umaskmask-block-obj","text":"Sets a umask when executing a script via run or attach . Must be used with a block. This causes umask ... && to be prepended to the script. The mask can be an Integer (typically expressed in octal) or a String. remote.umask 0o077 do remote.run \"touch a_file\" end # $ umask 0077 && touch a_file umask returns the value of its block.","title":"umask(mask, &amp;block) \u2192 obj"},{"location":"api/Remote/#host-tomohost","text":"The remote SSH host that scripts will be run on.","title":"host \u2192 Tomo::Host"},{"location":"api/Remote/#release-hash","text":"A mutable Hash that can be used to share data about the release that is being deployed. Data stored in this Hash can be read by other tasks. In practice this is used by the git:create_release task to store the branch, author, SHA, date, etc. of the release. This data can then be accessed by other tasks that are interested in this information. result = remote.run('git log -n1 --pretty=format:\"%ae\"') remote.release[:author] = result.stdout.chomp # remote.release[:author] can now be read by other tasks that connect to this host","title":"release \u2192 Hash"},{"location":"api/Result/","text":"Tomo::Result Represents the result of a remote SSH script. result = remote.run(\"echo\", \"hello world\") result.success? # => true result.failure? # => false result.exit_status # => 0 result.stdout # => \"hello world\\n\" result.stderr # => \"\" result.output # => \"hello world\\n\" A Result is always frozen and cannot be modified. Instance methods success? \u2192 true or false Whether the remote SSH script executed successfully. An exit status of 0 is considered success. failure? \u2192 true or false Whether the remote SSH script failed to execute. An non-zero exit status is considered a failure. exit_status \u2192 Integer The exit status returned by the remote SSH script. A status of 0 is considered success. stdout \u2192 String All data that was written to stdout by the remote SSH script. Empty string if nothing was written. stderr \u2192 String All data that was written to stderr by the remote SSH script. Empty string if nothing was written. output \u2192 String All data that was written by the remote SSH script: stdout and stderr combined, in that order. Empty string if nothing was written.","title":"Tomo::Result"},{"location":"api/Result/#tomoresult","text":"Represents the result of a remote SSH script. result = remote.run(\"echo\", \"hello world\") result.success? # => true result.failure? # => false result.exit_status # => 0 result.stdout # => \"hello world\\n\" result.stderr # => \"\" result.output # => \"hello world\\n\" A Result is always frozen and cannot be modified.","title":"Tomo::Result"},{"location":"api/Result/#instance-methods","text":"","title":"Instance methods"},{"location":"api/Result/#success-true-or-false","text":"Whether the remote SSH script executed successfully. An exit status of 0 is considered success.","title":"success? \u2192 true or false"},{"location":"api/Result/#failure-true-or-false","text":"Whether the remote SSH script failed to execute. An non-zero exit status is considered a failure.","title":"failure? \u2192 true or false"},{"location":"api/Result/#exit_status-integer","text":"The exit status returned by the remote SSH script. A status of 0 is considered success.","title":"exit_status \u2192 Integer"},{"location":"api/Result/#stdout-string","text":"All data that was written to stdout by the remote SSH script. Empty string if nothing was written.","title":"stdout \u2192 String"},{"location":"api/Result/#stderr-string","text":"All data that was written to stderr by the remote SSH script. Empty string if nothing was written.","title":"stderr \u2192 String"},{"location":"api/Result/#output-string","text":"All data that was written by the remote SSH script: stdout and stderr combined, in that order. Empty string if nothing was written.","title":"output \u2192 String"},{"location":"api/TaskLibrary/","text":"Tomo::TaskLibrary This is the primary public API for extending tomo. A TaskLibrary defines tasks. Every public instance method of a TaskLibrary becomes accessible to tomo as a task of the same name, prefixed by the name of its plugin. For example, this is how the git:clone task is defined: module Tomo::Plugin::Git class Tasks < Tomo::TaskLibrary # This becomes the implementation of the git:clone task def clone require_setting :git_url # ... end end end The TaskLibrary base class provides several useful private methods (detailed below) that allow task authors to run commands on the remote host, access tomo settings, and more. For more information on writing tasks, refer to the Writing Custom Tasks tutorial. Instance methods paths \u2192 Tomo::Paths Returns a Paths object that provides convenient access to settings representing file system paths. paths.current.join(\"lib\") # => \"/var/www/my-app/current/lib\" # ...which is syntactic sugar for: Pathname.new(settings[:current_path]).join(\"lib\") settings \u2192 Hash Returns a frozen (i.e. read-only) Hash containing all of tomo\u2019s settings. Any string interpolations will have already been applied. The keys representing the setting names are always symbols. settings[:application] # => \"my-app\" settings[:deploy_to] # => \"/var/www/my-app\" settings[:non_existing] # => nil settings.fetch(:non_existing) # => KeyError settings[:foo] = \"bar\" # => FrozenError settings.key?(:application) # => true settings.key?(:non_existing) # => false remote \u2192 Tomo::Remote Returns the Remote fa\u00e7ade that allows scripts to be run on the remote host. remote.run(\"echo\", \"hello world\") require_setting(name) \u2192 nil Raises an exception if a setting with the given name is not present. In other words, it will raise if settings[name] is nil . This can be used as a guard clause to ensure that users provide all necessary settings before a task can be run. def clone require_setting :git_url remote.run \"git\", \"clone\", settings[:git_url] end require_settings(*names) \u2192 nil Like require_setting , except it accepts an arbitrary number of setting names. Raises if any of the settings are nil . require_settings :puma_control_token, :puma_control_url dry_run? \u2192 true or false Returns true if tomo was started with the --dry-run option. This is useful if there are certain code paths you want to ensure are taken during a dry run. def install return if remote.bundle?(\"check\", *check_options) && !dry_run? remote.bundle(\"install\", *install_options) end logger \u2192 Tomo::Logger Returns the global Logger object that can be used to write messages to tomo\u2019s output. logger.debug \"got here\" logger.info \"hi!\" logger.warn \"uh oh\" die(reason) Immediately halt task execution by raising an exception. This will automatically print information to stderr about what task failed, on which host, and the reason for the failure. raw(string) \u2192 String Mark a string as a \u201craw\u201d value so that it is not automatically escaped. By default tomo applies shell escaping rules for safety. If you explicitly want to invoke shell behavior, use raw to prevent these escaping rules. remote.run \"ls\", \"$HOME/.bashrc\" # $ ls $\\HOME/.bashrc # \"$HOME/.bashrc\": No such file or directory (os error 2) remote.run \"ls\", raw(\"$HOME/.bashrc\") # $ ls $HOME/.bashrc # /home/deployer/.bashrc","title":"Tomo::TaskLibrary"},{"location":"api/TaskLibrary/#tomotasklibrary","text":"This is the primary public API for extending tomo. A TaskLibrary defines tasks. Every public instance method of a TaskLibrary becomes accessible to tomo as a task of the same name, prefixed by the name of its plugin. For example, this is how the git:clone task is defined: module Tomo::Plugin::Git class Tasks < Tomo::TaskLibrary # This becomes the implementation of the git:clone task def clone require_setting :git_url # ... end end end The TaskLibrary base class provides several useful private methods (detailed below) that allow task authors to run commands on the remote host, access tomo settings, and more. For more information on writing tasks, refer to the Writing Custom Tasks tutorial.","title":"Tomo::TaskLibrary"},{"location":"api/TaskLibrary/#instance-methods","text":"","title":"Instance methods"},{"location":"api/TaskLibrary/#paths-tomopaths","text":"Returns a Paths object that provides convenient access to settings representing file system paths. paths.current.join(\"lib\") # => \"/var/www/my-app/current/lib\" # ...which is syntactic sugar for: Pathname.new(settings[:current_path]).join(\"lib\")","title":"paths \u2192 Tomo::Paths"},{"location":"api/TaskLibrary/#settings-hash","text":"Returns a frozen (i.e. read-only) Hash containing all of tomo\u2019s settings. Any string interpolations will have already been applied. The keys representing the setting names are always symbols. settings[:application] # => \"my-app\" settings[:deploy_to] # => \"/var/www/my-app\" settings[:non_existing] # => nil settings.fetch(:non_existing) # => KeyError settings[:foo] = \"bar\" # => FrozenError settings.key?(:application) # => true settings.key?(:non_existing) # => false","title":"settings \u2192 Hash"},{"location":"api/TaskLibrary/#remote-tomoremote","text":"Returns the Remote fa\u00e7ade that allows scripts to be run on the remote host. remote.run(\"echo\", \"hello world\")","title":"remote \u2192 Tomo::Remote"},{"location":"api/TaskLibrary/#require_settingname-nil","text":"Raises an exception if a setting with the given name is not present. In other words, it will raise if settings[name] is nil . This can be used as a guard clause to ensure that users provide all necessary settings before a task can be run. def clone require_setting :git_url remote.run \"git\", \"clone\", settings[:git_url] end","title":"require_setting(name) \u2192 nil"},{"location":"api/TaskLibrary/#require_settings42names-nil","text":"Like require_setting , except it accepts an arbitrary number of setting names. Raises if any of the settings are nil . require_settings :puma_control_token, :puma_control_url","title":"require_settings(*names) \u2192 nil"},{"location":"api/TaskLibrary/#dry_run-true-or-false","text":"Returns true if tomo was started with the --dry-run option. This is useful if there are certain code paths you want to ensure are taken during a dry run. def install return if remote.bundle?(\"check\", *check_options) && !dry_run? remote.bundle(\"install\", *install_options) end","title":"dry_run? \u2192 true or false"},{"location":"api/TaskLibrary/#logger-tomologger","text":"Returns the global Logger object that can be used to write messages to tomo\u2019s output. logger.debug \"got here\" logger.info \"hi!\" logger.warn \"uh oh\"","title":"logger \u2192 Tomo::Logger"},{"location":"api/TaskLibrary/#diereason","text":"Immediately halt task execution by raising an exception. This will automatically print information to stderr about what task failed, on which host, and the reason for the failure.","title":"die(reason)"},{"location":"api/TaskLibrary/#rawstring-string","text":"Mark a string as a \u201craw\u201d value so that it is not automatically escaped. By default tomo applies shell escaping rules for safety. If you explicitly want to invoke shell behavior, use raw to prevent these escaping rules. remote.run \"ls\", \"$HOME/.bashrc\" # $ ls $\\HOME/.bashrc # \"$HOME/.bashrc\": No such file or directory (os error 2) remote.run \"ls\", raw(\"$HOME/.bashrc\") # $ ls $HOME/.bashrc # /home/deployer/.bashrc","title":"raw(string) \u2192 String"},{"location":"api/testing/DockerPluginTester/","text":"Tomo::Testing::DockerPluginTester Similar to MockPluginTester , DockerPluginTester is a helper object that allows tasks and helpers provided by plugins to be easily tested. A real SSH connection is used and no mocking is performed. Instead, DockerPluginTester builds a Docker image containing a real SSH server and runs it, sending all remote SSH scripts to that Docker container. This allows for true end-to-end testing. The Docker image is based on Ubuntu 18.04. The first time DockerPluginTester is used, the base image will be downloaded and a tomo-specific image will be created, which can take a few minutes. Because of the overhead involved, Docker-based tests should be used sparingly and only when they provide high value over much faster unit tests. Note that you must require \"tomo/testing\" to use DockerPluginTester. Class methods new(*plugin_names, settings: {}) \u2192 new_tester Build a new DockerPluginTester that loads the given list of plugin_names . The resulting tester object can be used to execute any tasks or helpers that are provided by these plugins. Note that the \u201ccore\u201d plugin is always loaded implicitly and does not need to be specified. Creating a new DockerPluginTester will implicitly build and run a Docker image containing an SSH server. This can take a few minutes the first time the image is built. Make sure to call teardown after you are done using the tester. Instance methods run_task(task, *args) \u2192 nil Run the given task by its fully qualified name (the namespace is required). Any args , if specified, are passed to the task via settings[:run_args] . Any remote SSH scripts run by the task will be executed via an SSH connection to the Docker container. call_helper(helper, *args, **kwargs) \u2192 obj Invoke the specified helper method name with the optional positional args and keyword kwargs . Returns the return value of the helper. Any remote SSH scripts run by the task will be executed via an SSH connection to the Docker container. teardown \u2192 nil Stop the underlying Docker container associated with this tester. Be sure to call teardown after the test(s) that use the tester are finished. stdout \u2192 String Everything that was written to stdout during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned. stderr \u2192 String Everything that was written to stderr during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"Tomo::Testing::DockerPluginTester"},{"location":"api/testing/DockerPluginTester/#tomotestingdockerplugintester","text":"Similar to MockPluginTester , DockerPluginTester is a helper object that allows tasks and helpers provided by plugins to be easily tested. A real SSH connection is used and no mocking is performed. Instead, DockerPluginTester builds a Docker image containing a real SSH server and runs it, sending all remote SSH scripts to that Docker container. This allows for true end-to-end testing. The Docker image is based on Ubuntu 18.04. The first time DockerPluginTester is used, the base image will be downloaded and a tomo-specific image will be created, which can take a few minutes. Because of the overhead involved, Docker-based tests should be used sparingly and only when they provide high value over much faster unit tests. Note that you must require \"tomo/testing\" to use DockerPluginTester.","title":"Tomo::Testing::DockerPluginTester"},{"location":"api/testing/DockerPluginTester/#class-methods","text":"","title":"Class methods"},{"location":"api/testing/DockerPluginTester/#new42plugin_names-settings-new_tester","text":"Build a new DockerPluginTester that loads the given list of plugin_names . The resulting tester object can be used to execute any tasks or helpers that are provided by these plugins. Note that the \u201ccore\u201d plugin is always loaded implicitly and does not need to be specified. Creating a new DockerPluginTester will implicitly build and run a Docker image containing an SSH server. This can take a few minutes the first time the image is built. Make sure to call teardown after you are done using the tester.","title":"new(*plugin_names, settings: {}) \u2192 new_tester"},{"location":"api/testing/DockerPluginTester/#instance-methods","text":"","title":"Instance methods"},{"location":"api/testing/DockerPluginTester/#run_tasktask-42args-nil","text":"Run the given task by its fully qualified name (the namespace is required). Any args , if specified, are passed to the task via settings[:run_args] . Any remote SSH scripts run by the task will be executed via an SSH connection to the Docker container.","title":"run_task(task, *args) \u2192 nil"},{"location":"api/testing/DockerPluginTester/#call_helperhelper-42args-4242kwargs-obj","text":"Invoke the specified helper method name with the optional positional args and keyword kwargs . Returns the return value of the helper. Any remote SSH scripts run by the task will be executed via an SSH connection to the Docker container.","title":"call_helper(helper, *args, **kwargs) \u2192 obj"},{"location":"api/testing/DockerPluginTester/#teardown-nil","text":"Stop the underlying Docker container associated with this tester. Be sure to call teardown after the test(s) that use the tester are finished.","title":"teardown \u2192 nil"},{"location":"api/testing/DockerPluginTester/#stdout-string","text":"Everything that was written to stdout during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"stdout \u2192 String"},{"location":"api/testing/DockerPluginTester/#stderr-string","text":"Everything that was written to stderr during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"stderr \u2192 String"},{"location":"api/testing/MockPluginTester/","text":"Tomo::Testing::MockPluginTester MockPluginTester is a helper object that allows tasks and helpers provided by plugins to be easily unit tested. It has no test framework dependencies so it can be used in Minitest, RSpec, or the testing framework of your choice. MockPluginTester works by mocking the underlying SSH connection so that no actual remote SSH scripts are run. By default, the tester will simulate that the script runs successfully (exit status of 0) with empty stdout and stderr. You can then write assertions verifying that the script was run as expected. For example: require \"tomo/testing\" def test_setup_directories tester = Tomo::Testing::MockPluginTester.new(settings: { deploy_to: \"/app\" }) tester.run_task(\"core:setup_directories\") assert_equal(\"mkdir -p /app /app/releases /app/shared\", tester.executed_script) end You can change the default mocking behavior by using mock_script_result , like this: require \"tomo/testing\" def setup @tester = Tomo::Testing::MockPluginTester.new( \"bundler\", \"puma\", settings: { current_path: \"/app/current\", puma_control_url: \"tcp://127.0.0.1:9293\", puma_control_token: \"test\" } ) end def test_restart_starts_puma_if_pumactl_fails @tester.mock_script_result(/pumactl/, exit_status: 1) @tester.run_task(\"puma:restart\") assert_equal( \"cd /app/current && bundle exec puma --daemon \"\\ \"--control-url tcp://127.0.0.1:9293 --control-token test\", @tester.executed_scripts.last ) end Every MockPluginTester instance loads a fresh, independent tomo environment, so mocks, plugins, settings, etc. specified in one tester will not affect any other tests. Note that you must require \"tomo/testing\" to use MockPluginTester. Class methods new(*plugin_names, settings: {}, release: {}) \u2192 new_tester Build a new MockPluginTester that loads the given list of plugin_names . The resulting tester object can be used to simulate any tasks or helpers that are provided by these plugins. Note that the \u201ccore\u201d plugin is always loaded implicitly and does not need to be specified. Any settings that are specified will be applied after the defaults settings provided by the plugins have been defined. These settings can use template strings just like set . require \"tomo/testing\" tester = Tomo::Testing::MockPluginTester.new( \"bundler\", \"puma\", settings: { current_path: \"/app/current\", puma_control_url: \"tcp://127.0.0.1:9293\", puma_control_token: \"test\" } ) Any release data specified will be available to the task under test via remote.release . Instance methods run_task(task, *args) \u2192 nil Run the given task by its fully qualified name (the namespace is required). Any args , if specified, are passed to the task via settings[:run_args] . Any remote SSH scripts run by the task (e.g. via remote.run ) will be mocked according to rules previously supplied to mock_script_result . If a mock result has not been explicitly supplied, the script will use a default mock that returns a successful result with no output. require \"tomo/testing\" tester = Tomo::Testing::MockPluginTester.new(\"rails\") tester.run_task(\"rails:log_tail\", \"-F\") assert_equal( \"tail -F /var/www/testing/current/log/${RAILS_ENV}.log\", tester.executed_script ) call_helper(helper, *args, **kwargs) \u2192 obj Invoke the specified helper method name with the optional positional args and keyword kwargs . Returns the return value of the helper. Remote SSH scripts are mocked as explained in run_task . require \"tomo/testing\" def test_capture_returns_stdout_not_stderr tester = Tomo::Testing::MockPluginTester.new tester.mock_script_result(stderr: \"oh no\", stdout: \"hello world\\n\") captured = tester.call_helper(:capture, \"greet\") assert_equal(\"hello world\\n\", captured) end mock_script_result(script=/.*/, stdout: \u201c\u201d, stderr: \u201c\u201d, exit_status: 0) \u2192 self Mock the return value of remote SSH scripts that match the given script . If script is a String, the mock rule will apply only to scripts that match this String exactly. If script is Regexp, the mock rule will apply to any scripts that match that pattern. If script is omitted, the mock rule will apply always. In this example, any task or helper invoked via this tester that runs readline /app/current will receive the given mock stdout response: tester.mock_script_result(\"readlink /app/current\", stdout: <<~OUT) /app/releases/20190420203028 OUT Here, any script that includes pumactl will fail with an exit status of 1: tester.mock_script_result(/pumactl/, exit_status: 1) This mocks all scripts to fail with exit status of 255 and stderr of \u201coh no!\u201d: tester.mock_script_result(exit_status: 255, stderr: \"oh no!\") executed_script \u2192 String The remote SSH script that was run by a previous invocation of run_task or call_helper . If no script was run, then nil is returned. If more that one script was run, this will raise a RuntimeError . executed_scripts \u2192 [String] All remote SSH scripts that were run by a previous invocation of run_task or call_helper . If no script was run, then an empty array is returned. stdout \u2192 String Everything that was written to stdout during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned. stderr \u2192 String Everything that was written to stderr during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"Tomo::Testing::MockPluginTester"},{"location":"api/testing/MockPluginTester/#tomotestingmockplugintester","text":"MockPluginTester is a helper object that allows tasks and helpers provided by plugins to be easily unit tested. It has no test framework dependencies so it can be used in Minitest, RSpec, or the testing framework of your choice. MockPluginTester works by mocking the underlying SSH connection so that no actual remote SSH scripts are run. By default, the tester will simulate that the script runs successfully (exit status of 0) with empty stdout and stderr. You can then write assertions verifying that the script was run as expected. For example: require \"tomo/testing\" def test_setup_directories tester = Tomo::Testing::MockPluginTester.new(settings: { deploy_to: \"/app\" }) tester.run_task(\"core:setup_directories\") assert_equal(\"mkdir -p /app /app/releases /app/shared\", tester.executed_script) end You can change the default mocking behavior by using mock_script_result , like this: require \"tomo/testing\" def setup @tester = Tomo::Testing::MockPluginTester.new( \"bundler\", \"puma\", settings: { current_path: \"/app/current\", puma_control_url: \"tcp://127.0.0.1:9293\", puma_control_token: \"test\" } ) end def test_restart_starts_puma_if_pumactl_fails @tester.mock_script_result(/pumactl/, exit_status: 1) @tester.run_task(\"puma:restart\") assert_equal( \"cd /app/current && bundle exec puma --daemon \"\\ \"--control-url tcp://127.0.0.1:9293 --control-token test\", @tester.executed_scripts.last ) end Every MockPluginTester instance loads a fresh, independent tomo environment, so mocks, plugins, settings, etc. specified in one tester will not affect any other tests. Note that you must require \"tomo/testing\" to use MockPluginTester.","title":"Tomo::Testing::MockPluginTester"},{"location":"api/testing/MockPluginTester/#class-methods","text":"","title":"Class methods"},{"location":"api/testing/MockPluginTester/#new42plugin_names-settings-release-new_tester","text":"Build a new MockPluginTester that loads the given list of plugin_names . The resulting tester object can be used to simulate any tasks or helpers that are provided by these plugins. Note that the \u201ccore\u201d plugin is always loaded implicitly and does not need to be specified. Any settings that are specified will be applied after the defaults settings provided by the plugins have been defined. These settings can use template strings just like set . require \"tomo/testing\" tester = Tomo::Testing::MockPluginTester.new( \"bundler\", \"puma\", settings: { current_path: \"/app/current\", puma_control_url: \"tcp://127.0.0.1:9293\", puma_control_token: \"test\" } ) Any release data specified will be available to the task under test via remote.release .","title":"new(*plugin_names, settings: {}, release: {}) \u2192 new_tester"},{"location":"api/testing/MockPluginTester/#instance-methods","text":"","title":"Instance methods"},{"location":"api/testing/MockPluginTester/#run_tasktask-42args-nil","text":"Run the given task by its fully qualified name (the namespace is required). Any args , if specified, are passed to the task via settings[:run_args] . Any remote SSH scripts run by the task (e.g. via remote.run ) will be mocked according to rules previously supplied to mock_script_result . If a mock result has not been explicitly supplied, the script will use a default mock that returns a successful result with no output. require \"tomo/testing\" tester = Tomo::Testing::MockPluginTester.new(\"rails\") tester.run_task(\"rails:log_tail\", \"-F\") assert_equal( \"tail -F /var/www/testing/current/log/${RAILS_ENV}.log\", tester.executed_script )","title":"run_task(task, *args) \u2192 nil"},{"location":"api/testing/MockPluginTester/#call_helperhelper-42args-4242kwargs-obj","text":"Invoke the specified helper method name with the optional positional args and keyword kwargs . Returns the return value of the helper. Remote SSH scripts are mocked as explained in run_task . require \"tomo/testing\" def test_capture_returns_stdout_not_stderr tester = Tomo::Testing::MockPluginTester.new tester.mock_script_result(stderr: \"oh no\", stdout: \"hello world\\n\") captured = tester.call_helper(:capture, \"greet\") assert_equal(\"hello world\\n\", captured) end","title":"call_helper(helper, *args, **kwargs) \u2192 obj"},{"location":"api/testing/MockPluginTester/#mock_script_resultscript42-stdout-stderr-exit_status-0-self","text":"Mock the return value of remote SSH scripts that match the given script . If script is a String, the mock rule will apply only to scripts that match this String exactly. If script is Regexp, the mock rule will apply to any scripts that match that pattern. If script is omitted, the mock rule will apply always. In this example, any task or helper invoked via this tester that runs readline /app/current will receive the given mock stdout response: tester.mock_script_result(\"readlink /app/current\", stdout: <<~OUT) /app/releases/20190420203028 OUT Here, any script that includes pumactl will fail with an exit status of 1: tester.mock_script_result(/pumactl/, exit_status: 1) This mocks all scripts to fail with exit status of 255 and stderr of \u201coh no!\u201d: tester.mock_script_result(exit_status: 255, stderr: \"oh no!\")","title":"mock_script_result(script=/.*/, stdout: \"\", stderr: \"\", exit_status: 0) \u2192 self"},{"location":"api/testing/MockPluginTester/#executed_script-string","text":"The remote SSH script that was run by a previous invocation of run_task or call_helper . If no script was run, then nil is returned. If more that one script was run, this will raise a RuntimeError .","title":"executed_script \u2192 String"},{"location":"api/testing/MockPluginTester/#executed_scripts-string","text":"All remote SSH scripts that were run by a previous invocation of run_task or call_helper . If no script was run, then an empty array is returned.","title":"executed_scripts \u2192 [String]"},{"location":"api/testing/MockPluginTester/#stdout-string","text":"Everything that was written to stdout during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"stdout \u2192 String"},{"location":"api/testing/MockPluginTester/#stderr-string","text":"Everything that was written to stderr during the most recent invocation of run_task or call_helper . If nothing was written, then the empty string is returned.","title":"stderr \u2192 String"},{"location":"commands/deploy/","text":"deploy Deploy the current project to remote host(s). Usage $ tomo deploy [--dry-run] [options] Sequentially run the deploy list of tasks specified in .tomo/config.rb to deploy the project to a remote host. In practice, a deploy will usually consist of the following steps: Create a release (using the git:create_release task) Build the project (e.g. bundler:install , rails:assets_precompile ) Migrate data to the meet the requirements of the new release (e.g. rails:db_migrate ) Make the new release the \u201ccurrent\u201d one ( core:symlink_current ) Restart the app to use the new current release (e.g. puma:restart ) Perform any cleanup (e.g. bundler:clean ) During a deploy, tomo will initialize the :release_path setting based on the current date and time (e.g. /var/www/my-app/releases/20190616214752 ). Any tasks that copy files into a release ( git:create_release ), or run inside the release ( bundler:install , rails:assets_precompile , rails:db_migrate , etc.) will operate using this path. As a result, every tomo deploy will create a new entry in the releases directory, and the current symlink will point to the release that is currently active, i.e. the most recent successful deploy. The directory structure on the remote host looks like this: /var/www/my-app \u251c\u2500\u2500 git_repo/ \u251c\u2500\u2500 releases/ | \u251c\u2500\u2500 20190614192115/ | \u251c\u2500\u2500 20190615034736/ | \u2514\u2500\u2500 20190616214752/ \u251c\u2500\u2500 shared/ | \u251c\u2500\u2500 bundle/ | \u251c\u2500\u2500 log/ | \u251c\u2500\u2500 node_modules/ | \u2514\u2500\u2500 public/ | \u2514\u2500\u2500 assets/ \u251c\u2500\u2500 current -> /var/www/my-app/releases/20190616214752 \u2514\u2500\u2500 revisions.log This structure is customizable; see the core plugin settings for details. Options Option Purpose -e ENVIRONMENT , --environment ENVIRONMENT If the configuration contains multiple environments , specify the ENVIRONMENT that should be used (e.g. production). The host(s) and settings can be different per environment. -s NAME=VALUE , --setting NAME=VALUE Override the setting NAME with the given VALUE. Refer to the settings overrides documentation for a detailed explanation. --[no-]dry-run Simulate running tasks instead of using real SSH. -c PATH , --config PATH Override the PATH where the configuration file is loaded from. (Default: .tomo/config.rb ). --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page. Example Given the following configuration: host \"deployer@localhost\", port: 32809 deploy do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:db_migrate\" run \"rails:db_seed\" run \"rails:assets_precompile\" run \"core:symlink_current\" run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end Then a deploy would produce: $ tomo deploy tomo deploy v0.1.0 \u2192 Connecting to deployer@localhost:32809 \u2022 env:update \u2022 git:create_release Writing 60 bytes to /var/www/rails-new/git_repo/info/attributes cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git remote update --prune Fetching origin cd /var/www/rails-new/git_repo && mkdir -p /var/www/rails-new/releases/20190616214752 cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git archive master | tar -x -f - -C /var/www/rails-new/releases/20190616214752 cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git log -n1 --date=iso --pretty=format:\"%H/%cd/%ae\" master \u2022 core:symlink_shared mkdir -p /var/www/rails-new/shared/.bundle /var/www/rails-new/shared/log /var/www/rails-new/shared/node_modules /var/www/rails-new/shared/public/assets /var/www/rails-new/releases/20190616214752/public cd /var/www/rails-new/releases/20190616214752 && rm -rf .bundle log node_modules public/assets ln -sf /var/www/rails-new/shared/.bundle /var/www/rails-new/releases/20190616214752/.bundle ln -sf /var/www/rails-new/shared/log /var/www/rails-new/releases/20190616214752/log ln -sf /var/www/rails-new/shared/node_modules /var/www/rails-new/releases/20190616214752/node_modules ln -sf /var/www/rails-new/shared/public/assets /var/www/rails-new/releases/20190616214752/public/assets \u2022 core:write_release_json Writing 243 bytes to /var/www/rails-new/releases/20190616214752/.tomo_release.json \u2022 bundler:install cd /var/www/rails-new/releases/20190616214752 && bundle check --path /var/www/rails-new/shared/bundle The Gemfile's dependencies are satisfied \u2022 rails:db_migrate cd /var/www/rails-new/releases/20190616214752 && bundle exec rails db:migrate \u2022 rails:db_seed cd /var/www/rails-new/releases/20190616214752 && bundle exec rails db:seed \u2022 rails:assets_precompile cd /var/www/rails-new/releases/20190616214752 && bundle exec rails assets:precompile yarn install v1.16.0 [1/4] Resolving packages... [2/4] Fetching packages... info fsevents@1.2.9: The platform \"linux\" is incompatible with this module. info \"fsevents@1.2.9\" is an optional dependency and failed compatibility check. Excluding it from installation. [3/4] Linking dependencies... warning \" > webpack-dev-server@3.3.1\" has unmet peer dependency \"webpack@^4.0.0\". warning \"webpack-dev-server > webpack-dev-middleware@3.7.0\" has unmet peer dependency \"webpack@^4.0.0\". [4/4] Building fresh packages... Done in 27.71s. I, [2019-06-16T21:48:36.682912 #36032] INFO -- : Writing /var/www/rails-new/releases/20190616214752/public/assets/application-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css I, [2019-06-16T21:48:36.683798 #36032] INFO -- : Writing /var/www/rails-new/releases/20190616214752/public/assets/application-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css.gz Compiling\u2026 Compiled all packs in /var/www/rails-new/releases/20190616214752/public/packs \u2022 core:symlink_current ln -sf /var/www/rails-new/releases/20190616214752 /var/www/rails-new/current-9f36bc6f645ade90 mv -fT /var/www/rails-new/current-9f36bc6f645ade90 /var/www/rails-new/current \u2022 puma:restart cd /var/www/rails-new/current && bundle exec pumactl --control-url tcp://127.0.0.1:9293 --control-token tomo restart Puma is not running. Starting it now. cd /var/www/rails-new/current && bundle exec puma --daemon --control-url tcp://127.0.0.1:9293 --control-token tomo Puma starting in single mode... * Version 3.12.1 (ruby 2.6.3-p62), codename: Llamas in Pajamas * Min threads: 5, max threads: 5 * Environment: production * Daemonizing... \u2022 core:clean_releases readlink /var/www/rails-new/current cd /var/www/rails-new/releases && ls -A1 \u2022 bundler:clean cd /var/www/rails-new/releases/20190616214752 && bundle clean \u2022 core:log_revision Writing 100 bytes to /var/www/rails-new/revisions.log","title":"deploy"},{"location":"commands/deploy/#deploy","text":"Deploy the current project to remote host(s).","title":"deploy"},{"location":"commands/deploy/#usage","text":"$ tomo deploy [--dry-run] [options] Sequentially run the deploy list of tasks specified in .tomo/config.rb to deploy the project to a remote host. In practice, a deploy will usually consist of the following steps: Create a release (using the git:create_release task) Build the project (e.g. bundler:install , rails:assets_precompile ) Migrate data to the meet the requirements of the new release (e.g. rails:db_migrate ) Make the new release the \u201ccurrent\u201d one ( core:symlink_current ) Restart the app to use the new current release (e.g. puma:restart ) Perform any cleanup (e.g. bundler:clean ) During a deploy, tomo will initialize the :release_path setting based on the current date and time (e.g. /var/www/my-app/releases/20190616214752 ). Any tasks that copy files into a release ( git:create_release ), or run inside the release ( bundler:install , rails:assets_precompile , rails:db_migrate , etc.) will operate using this path. As a result, every tomo deploy will create a new entry in the releases directory, and the current symlink will point to the release that is currently active, i.e. the most recent successful deploy. The directory structure on the remote host looks like this: /var/www/my-app \u251c\u2500\u2500 git_repo/ \u251c\u2500\u2500 releases/ | \u251c\u2500\u2500 20190614192115/ | \u251c\u2500\u2500 20190615034736/ | \u2514\u2500\u2500 20190616214752/ \u251c\u2500\u2500 shared/ | \u251c\u2500\u2500 bundle/ | \u251c\u2500\u2500 log/ | \u251c\u2500\u2500 node_modules/ | \u2514\u2500\u2500 public/ | \u2514\u2500\u2500 assets/ \u251c\u2500\u2500 current -> /var/www/my-app/releases/20190616214752 \u2514\u2500\u2500 revisions.log This structure is customizable; see the core plugin settings for details.","title":"Usage"},{"location":"commands/deploy/#options","text":"Option Purpose -e ENVIRONMENT , --environment ENVIRONMENT If the configuration contains multiple environments , specify the ENVIRONMENT that should be used (e.g. production). The host(s) and settings can be different per environment. -s NAME=VALUE , --setting NAME=VALUE Override the setting NAME with the given VALUE. Refer to the settings overrides documentation for a detailed explanation. --[no-]dry-run Simulate running tasks instead of using real SSH. -c PATH , --config PATH Override the PATH where the configuration file is loaded from. (Default: .tomo/config.rb ). --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page.","title":"Options"},{"location":"commands/deploy/#example","text":"Given the following configuration: host \"deployer@localhost\", port: 32809 deploy do run \"env:update\" run \"git:create_release\" run \"core:symlink_shared\" run \"core:write_release_json\" run \"bundler:install\" run \"rails:db_migrate\" run \"rails:db_seed\" run \"rails:assets_precompile\" run \"core:symlink_current\" run \"puma:restart\" run \"core:clean_releases\" run \"bundler:clean\" run \"core:log_revision\" end Then a deploy would produce: $ tomo deploy tomo deploy v0.1.0 \u2192 Connecting to deployer@localhost:32809 \u2022 env:update \u2022 git:create_release Writing 60 bytes to /var/www/rails-new/git_repo/info/attributes cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git remote update --prune Fetching origin cd /var/www/rails-new/git_repo && mkdir -p /var/www/rails-new/releases/20190616214752 cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git archive master | tar -x -f - -C /var/www/rails-new/releases/20190616214752 cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git log -n1 --date=iso --pretty=format:\"%H/%cd/%ae\" master \u2022 core:symlink_shared mkdir -p /var/www/rails-new/shared/.bundle /var/www/rails-new/shared/log /var/www/rails-new/shared/node_modules /var/www/rails-new/shared/public/assets /var/www/rails-new/releases/20190616214752/public cd /var/www/rails-new/releases/20190616214752 && rm -rf .bundle log node_modules public/assets ln -sf /var/www/rails-new/shared/.bundle /var/www/rails-new/releases/20190616214752/.bundle ln -sf /var/www/rails-new/shared/log /var/www/rails-new/releases/20190616214752/log ln -sf /var/www/rails-new/shared/node_modules /var/www/rails-new/releases/20190616214752/node_modules ln -sf /var/www/rails-new/shared/public/assets /var/www/rails-new/releases/20190616214752/public/assets \u2022 core:write_release_json Writing 243 bytes to /var/www/rails-new/releases/20190616214752/.tomo_release.json \u2022 bundler:install cd /var/www/rails-new/releases/20190616214752 && bundle check --path /var/www/rails-new/shared/bundle The Gemfile's dependencies are satisfied \u2022 rails:db_migrate cd /var/www/rails-new/releases/20190616214752 && bundle exec rails db:migrate \u2022 rails:db_seed cd /var/www/rails-new/releases/20190616214752 && bundle exec rails db:seed \u2022 rails:assets_precompile cd /var/www/rails-new/releases/20190616214752 && bundle exec rails assets:precompile yarn install v1.16.0 [1/4] Resolving packages... [2/4] Fetching packages... info fsevents@1.2.9: The platform \"linux\" is incompatible with this module. info \"fsevents@1.2.9\" is an optional dependency and failed compatibility check. Excluding it from installation. [3/4] Linking dependencies... warning \" > webpack-dev-server@3.3.1\" has unmet peer dependency \"webpack@^4.0.0\". warning \"webpack-dev-server > webpack-dev-middleware@3.7.0\" has unmet peer dependency \"webpack@^4.0.0\". [4/4] Building fresh packages... Done in 27.71s. I, [2019-06-16T21:48:36.682912 #36032] INFO -- : Writing /var/www/rails-new/releases/20190616214752/public/assets/application-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css I, [2019-06-16T21:48:36.683798 #36032] INFO -- : Writing /var/www/rails-new/releases/20190616214752/public/assets/application-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css.gz Compiling\u2026 Compiled all packs in /var/www/rails-new/releases/20190616214752/public/packs \u2022 core:symlink_current ln -sf /var/www/rails-new/releases/20190616214752 /var/www/rails-new/current-9f36bc6f645ade90 mv -fT /var/www/rails-new/current-9f36bc6f645ade90 /var/www/rails-new/current \u2022 puma:restart cd /var/www/rails-new/current && bundle exec pumactl --control-url tcp://127.0.0.1:9293 --control-token tomo restart Puma is not running. Starting it now. cd /var/www/rails-new/current && bundle exec puma --daemon --control-url tcp://127.0.0.1:9293 --control-token tomo Puma starting in single mode... * Version 3.12.1 (ruby 2.6.3-p62), codename: Llamas in Pajamas * Min threads: 5, max threads: 5 * Environment: production * Daemonizing... \u2022 core:clean_releases readlink /var/www/rails-new/current cd /var/www/rails-new/releases && ls -A1 \u2022 bundler:clean cd /var/www/rails-new/releases/20190616214752 && bundle clean \u2022 core:log_revision Writing 100 bytes to /var/www/rails-new/revisions.log","title":"Example"},{"location":"commands/init/","text":"init Start a new tomo project with a sample config. Usage $ tomo init [APP] Set up a new tomo project named APP . If APP is not specified, the name of the current directory will be used. This command creates a .tomo/config.rb file relative the current directory containing some example configuration. Refer to Configuration for a detailed explanation of this file. tomo init will make educated guesses about your project and fill in some configuration settings for you: nvm_node_version based on node --version nvm_yarn_version based on yarn --version git_url based on metadata in .git/ for this project, if present rbenv_ruby_version based on the version of Ruby being used to run tomo Options Option Purpose --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page. Example $ cd my-rails-app $ tomo init \u2714 Created .tomo/config.rb","title":"init"},{"location":"commands/init/#init","text":"Start a new tomo project with a sample config.","title":"init"},{"location":"commands/init/#usage","text":"$ tomo init [APP] Set up a new tomo project named APP . If APP is not specified, the name of the current directory will be used. This command creates a .tomo/config.rb file relative the current directory containing some example configuration. Refer to Configuration for a detailed explanation of this file. tomo init will make educated guesses about your project and fill in some configuration settings for you: nvm_node_version based on node --version nvm_yarn_version based on yarn --version git_url based on metadata in .git/ for this project, if present rbenv_ruby_version based on the version of Ruby being used to run tomo","title":"Usage"},{"location":"commands/init/#options","text":"Option Purpose --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page.","title":"Options"},{"location":"commands/init/#example","text":"$ cd my-rails-app $ tomo init \u2714 Created .tomo/config.rb","title":"Example"},{"location":"commands/run/","text":"run Run a specific remote task from the current project. Usage $ tomo run [--dry-run] [options] [--] TASK [ARGS...] Remotely run one specified TASK, optionally passing ARGS to that task. For example, if this project uses the rails plugin , you could run: $ tomo run -- rails:console --sandbox This will run the rails:console task on the host specified in .tomo/config.rb configuration file , and will pass the --sandbox argument to that task. The -- is used to separate tomo options from options that are passed to the task. If a task does not accept options, the -- can be omitted, like this: $ tomo run core:clean_releases When you specify a task name, the run command is implied and can be omitted, so this works as well: $ tomo core:clean_releases You can run any task defined by plugins loaded by the plugin declarations in .tomo/config.rb . To see a list of available tasks, run the tasks command. During the run command, tomo will initialize the :release_path setting to be equal to the current symlink (i.e. /var/www/my-app/current ). This means that the task will run within the current release. Options Option Purpose --[no-]privileged Run the task using a privileged user (e.g. root). This user is configured per host . -e ENVIRONMENT , --environment ENVIRONMENT If the configuration contains multiple environments , specify the ENVIRONMENT that should be used (e.g. production). The host(s) and settings can be different per environment. -s NAME=VALUE , --setting NAME=VALUE Override the setting NAME with the given VALUE. Refer to the settings overrides documentation for a detailed explanation. --[no-]dry-run Simulate running tasks instead of using real SSH. -c PATH , --config PATH Override the PATH where the configuration file is loaded from. (Default: .tomo/config.rb ). --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page. Example Given the following configuration: plugin \"bundler\" plugin \"puma\" host \"deployer@localhost\", port: 32811 Then we could run puma:restart like this: $ tomo run puma:restart tomo run v0.1.0 \u2192 Connecting to deployer@localhost:32811 \u2022 puma:restart cd /var/www/rails-new/current && bundle exec pumactl --control-url tcp://127.0.0.1:9293 --control-token tomo restart Command restart sent success \u2714 Ran puma:restart on deployer@localhost:32811","title":"run"},{"location":"commands/run/#run","text":"Run a specific remote task from the current project.","title":"run"},{"location":"commands/run/#usage","text":"$ tomo run [--dry-run] [options] [--] TASK [ARGS...] Remotely run one specified TASK, optionally passing ARGS to that task. For example, if this project uses the rails plugin , you could run: $ tomo run -- rails:console --sandbox This will run the rails:console task on the host specified in .tomo/config.rb configuration file , and will pass the --sandbox argument to that task. The -- is used to separate tomo options from options that are passed to the task. If a task does not accept options, the -- can be omitted, like this: $ tomo run core:clean_releases When you specify a task name, the run command is implied and can be omitted, so this works as well: $ tomo core:clean_releases You can run any task defined by plugins loaded by the plugin declarations in .tomo/config.rb . To see a list of available tasks, run the tasks command. During the run command, tomo will initialize the :release_path setting to be equal to the current symlink (i.e. /var/www/my-app/current ). This means that the task will run within the current release.","title":"Usage"},{"location":"commands/run/#options","text":"Option Purpose --[no-]privileged Run the task using a privileged user (e.g. root). This user is configured per host . -e ENVIRONMENT , --environment ENVIRONMENT If the configuration contains multiple environments , specify the ENVIRONMENT that should be used (e.g. production). The host(s) and settings can be different per environment. -s NAME=VALUE , --setting NAME=VALUE Override the setting NAME with the given VALUE. Refer to the settings overrides documentation for a detailed explanation. --[no-]dry-run Simulate running tasks instead of using real SSH. -c PATH , --config PATH Override the PATH where the configuration file is loaded from. (Default: .tomo/config.rb ). --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page.","title":"Options"},{"location":"commands/run/#example","text":"Given the following configuration: plugin \"bundler\" plugin \"puma\" host \"deployer@localhost\", port: 32811 Then we could run puma:restart like this: $ tomo run puma:restart tomo run v0.1.0 \u2192 Connecting to deployer@localhost:32811 \u2022 puma:restart cd /var/www/rails-new/current && bundle exec pumactl --control-url tcp://127.0.0.1:9293 --control-token tomo restart Command restart sent success \u2714 Ran puma:restart on deployer@localhost:32811","title":"Example"},{"location":"commands/setup/","text":"setup Prepare the current project for its first deploy. Usage $ tomo setup [--dry-run] [options] Prepare the remote host for its first deploy by sequentially running the setup list of tasks specified in .tomo/config.rb . These tasks typically create directories, initialize data stores, install prerequisite tools, and perform other one-time actions that are necessary before a deploy can take place. During setup, tomo will initialize the :release_path setting based on the current date and time and using a temporary directory (e.g. /tmp/tomo/20190616214752 ). This means setup tasks (e.g. rails:db_create , rails:db_schema_load ) to run in a location that won\u2019t be deployed as an actual release. Options Option Purpose -e ENVIRONMENT , --environment ENVIRONMENT If the configuration contains multiple environments , specify the ENVIRONMENT that should be used (e.g. production). The host(s) and settings can be different per environment. -s NAME=VALUE , --setting NAME=VALUE Override the setting NAME with the given VALUE. Refer to the settings overrides documentation for a detailed explanation. --[no-]dry-run Simulate running tasks instead of using real SSH. -c PATH , --config PATH Override the PATH where the configuration file is loaded from. (Default: .tomo/config.rb ). --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page. Example Given the following configuration: host \"deployer@localhost\", port: 32809 setup do run \"env:setup\" run \"core:setup_directories\" run \"git:clone\" run \"git:create_release\" run \"core:symlink_shared\" run \"nvm:install\" run \"rbenv:install\" run \"bundler:upgrade_bundler\" run \"bundler:install\" run \"rails:db_create\" run \"rails:db_schema_load\" run \"rails:db_seed\" end Then a setup would produce: $ tomo setup tomo setup v0.1.0 \u2192 Connecting to deployer@localhost:32809 \u2022 env:setup Writing 280 bytes to /var/www/rails-new/envrc cat .bashrc Writing 3845 bytes to .bashrc \u2022 core:setup_directories mkdir -p /var/www/rails-new /var/www/rails-new/releases /var/www/rails-new/shared \u2022 git:clone [ -d /var/www/rails-new/git_repo ] mkdir -p /var/www/rails-new export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git clone --mirror git@github.com:mattbrictson/rails-new.git /var/www/rails-new/git_repo Cloning into bare repository '/var/www/rails-new/git_repo'... Warning: Permanently added 'github.com,192.30.255.112' (RSA) to the list of known hosts. \u2022 git:create_release Writing 60 bytes to /var/www/rails-new/git_repo/info/attributes cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git remote update --prune Fetching origin cd /var/www/rails-new/git_repo && mkdir -p /tmp/tomo/20190616214334 cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git archive master | tar -x -f - -C /tmp/tomo/20190616214334 cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git log -n1 --date=iso --pretty=format:\"%H/%cd/%ae\" master \u2022 core:symlink_shared mkdir -p /var/www/rails-new/shared/.bundle /var/www/rails-new/shared/log /var/www/rails-new/shared/node_modules /var/www/rails-new/shared/public/assets /tmp/tomo/20190616214334/public cd /tmp/tomo/20190616214334 && rm -rf .bundle log node_modules public/assets ln -sf /var/www/rails-new/shared/.bundle /tmp/tomo/20190616214334/.bundle ln -sf /var/www/rails-new/shared/log /tmp/tomo/20190616214334/log ln -sf /var/www/rails-new/shared/node_modules /tmp/tomo/20190616214334/node_modules ln -sf /var/www/rails-new/shared/public/assets /tmp/tomo/20190616214334/public/assets \u2022 nvm:install mkdir -p $HOME/.nvm cat .bashrc Writing 3923 bytes to .bashrc curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 13226 100 13226 0 0 116k 0 --:--:-- --:--:-- --:--:-- 117k => Downloading nvm from git to '/home/deployer/.nvm' Cloning into '/home/deployer/.nvm'... => => Compressing and cleaning up git repository => nvm source string already in /home/deployer/.bashrc => Appending bash_completion source string to /home/deployer/.bashrc => Close and reopen your terminal to start using nvm or run the following to use it now: export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm [ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion nvm ls nvm install 10.16.0 Downloading and installing node v10.16.0... Downloading https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz... ######################################################################## 100.0% Computing checksum with sha256sum Checksums matched! Now using node v10.16.0 (npm v6.9.0) Creating default alias: default -> 10.16.0 (-> v10.16.0 *) nvm alias default 10.16.0 default -> 10.16.0 (-> v10.16.0 *) npm i -g yarn@1.16.0 /home/deployer/.nvm/versions/node/v10.16.0/bin/yarn -> /home/deployer/.nvm/versions/node/v10.16.0/lib/node_modules/yarn/bin/yarn.js /home/deployer/.nvm/versions/node/v10.16.0/bin/yarnpkg -> /home/deployer/.nvm/versions/node/v10.16.0/lib/node_modules/yarn/bin/yarn.js + yarn@1.16.0 added 1 package in 0.57s \u2022 rbenv:install export PATH=$HOME/.rbenv/bin:$HOME/.rbenv/shims:$PATH && curl -fsSL https://github.com/rbenv/rbenv-installer/raw/master/bin/rbenv-installer | bash Installing rbenv with git... Initialized empty Git repository in /home/deployer/.rbenv/.git/ Updating origin From https://github.com/rbenv/rbenv * [new branch] master -> origin/master * [new tag] v0.1.0 -> v0.1.0 * [new tag] v0.1.1 -> v0.1.1 * [new tag] v0.1.2 -> v0.1.2 * [new tag] v0.2.0 -> v0.2.0 * [new tag] v0.2.1 -> v0.2.1 * [new tag] v0.3.0 -> v0.3.0 * [new tag] v0.4.0 -> v0.4.0 * [new tag] v1.0.0 -> v1.0.0 * [new tag] v1.1.0 -> v1.1.0 * [new tag] v1.1.1 -> v1.1.1 * [new tag] v1.1.2 -> v1.1.2 Already on 'master' Branch 'master' set up to track remote branch 'master' from 'origin'. make: Entering directory '/home/deployer/.rbenv/src' gcc -fPIC -c -o realpath.o realpath.c gcc -shared -Wl,-soname,../libexec/rbenv-realpath.dylib -o ../libexec/rbenv-realpath.dylib realpath.o make: Leaving directory '/home/deployer/.rbenv/src' Installing ruby-build with git... Cloning into '/home/deployer/.rbenv/plugins/ruby-build'... Running doctor script to verify installation... Checking for `rbenv' in PATH: /home/deployer/.rbenv/bin/rbenv Checking for rbenv shims in PATH: OK Checking `rbenv install' support: /home/deployer/.rbenv/plugins/ruby-build/bin/rbenv-install (ruby-build 20190615-1-g0867187) Counting installed Ruby versions: none There aren't any Ruby versions installed under `/home/deployer/.rbenv/versions'. You can install Ruby versions like so: rbenv install 2.2.4 Checking RubyGems settings: OK Auditing installed plugins: OK All done! Note that this installer doesn't yet configure your shell startup files: 1. You'll want to ensure that `~/.rbenv/bin' is added to PATH. 2. Run `rbenv init' to see instructions how to configure rbenv for your shell. 3. Launch a new terminal window to verify that the configuration is correct. cat .bashrc Writing 4121 bytes to .bashrc rbenv versions Installing ruby 2.6.3 -- this may take several minutes CFLAGS=-O3 rbenv install 2.6.3 Downloading ruby-2.6.3.tar.bz2... -> https://cache.ruby-lang.org/pub/ruby/2.6/ruby-2.6.3.tar.bz2 Installing ruby-2.6.3... Installed ruby-2.6.3 to /home/deployer/.rbenv/versions/2.6.3 rbenv global 2.6.3 \u2022 bundler:upgrade_bundler tail -n 10 /tmp/tomo/20190616214334/Gemfile.lock gem install bundler --conservative --no-document -v 2.0.1 Successfully installed bundler-2.0.1 1 gem installed \u2022 bundler:install cd /tmp/tomo/20190616214334 && bundle check --path /var/www/rails-new/shared/bundle The following gems are missing * rake (12.3.2) * concurrent-ruby (1.1.5) * i18n (1.6.0) * minitest (5.11.3) * thread_safe (0.3.6) * tzinfo (1.2.5) * zeitwerk (2.1.6) * activesupport (6.0.0.rc1) * builder (3.2.3) * erubi (1.8.0) * mini_portile2 (2.4.0) * nokogiri (1.10.3) * rails-dom-testing (2.0.3) * crass (1.0.4) * loofah (2.2.3) * rails-html-sanitizer (1.0.4) * actionview (6.0.0.rc1) * rack (2.0.7) * rack-test (1.1.0) * actionpack (6.0.0.rc1) * nio4r (2.3.1) * websocket-extensions (0.1.3) * websocket-driver (0.7.0) * actioncable (6.0.0.rc1) * globalid (0.4.2) * activejob (6.0.0.rc1) * activemodel (6.0.0.rc1) * activerecord (6.0.0.rc1) * mimemagic (0.3.3) * marcel (0.3.3) * activestorage (6.0.0.rc1) * mini_mime (1.0.1) * mail (2.7.1) * actionmailbox (6.0.0.rc1) * actionmailer (6.0.0.rc1) * actiontext (6.0.0.rc1) * public_suffix (3.0.3) * addressable (2.6.0) * bindex (0.7.0) * msgpack (1.2.10) * bootsnap (1.4.4) * byebug (11.0.1) * regexp_parser (1.5.0) * execjs (2.7.0) * uglifier (4.1.20) * xpath (3.2.0) * capybara (3.20.0) * childprocess (1.0.1) * ffi (1.10.0) * jbuilder (2.9.1) * rb-fsevent (0.10.3) * rb-inotify (0.10.0) * ruby_dep (1.5.0) * listen (3.1.5) * method_source (0.9.2) * puma (3.12.1) * rack-proxy (0.6.5) * thor (0.20.3) * railties (6.0.0.rc1) * sprockets (3.7.2) * sprockets-rails (3.2.1) * rails (6.0.0.rc1) * rubyzip (1.2.2) * sass-listen (4.0.0) * sass (3.7.4) * tilt (2.0.9) * sass-rails (5.0.7) * selenium-webdriver (3.142.2) * spring (2.0.2) * spring-watcher-listen (2.0.1) * sqlite3 (1.4.1) * turbolinks-source (5.2.0) * turbolinks (5.2.0) * web-console (4.0.0) * webdrivers (3.9.2) * webpacker (4.0.2) Install missing gems with `bundle install` cd /tmp/tomo/20190616214334 && bundle install --path /var/www/rails-new/shared/bundle --jobs 4 --without development test --deployment Fetching gem metadata from https://rubygems.org/............ Fetching rake 12.3.2 Installing rake 12.3.2 Fetching concurrent-ruby 1.1.5 Fetching minitest 5.11.3 Fetching thread_safe 0.3.6 Installing minitest 5.11.3 Installing thread_safe 0.3.6 Installing concurrent-ruby 1.1.5 Fetching zeitwerk 2.1.6 Installing zeitwerk 2.1.6 Fetching builder 3.2.3 Installing builder 3.2.3 Fetching erubi 1.8.0 Installing erubi 1.8.0 Fetching mini_portile2 2.4.0 Fetching crass 1.0.4 Installing mini_portile2 2.4.0 Fetching rack 2.0.7 Fetching nio4r 2.3.1 Installing crass 1.0.4 Fetching websocket-extensions 0.1.3 Installing websocket-extensions 0.1.3 Fetching mimemagic 0.3.3 Installing nio4r 2.3.1 with native extensions Installing rack 2.0.7 Installing mimemagic 0.3.3 Fetching mini_mime 1.0.1 Installing mini_mime 1.0.1 Fetching msgpack 1.2.10 Using bundler 2.0.1 Fetching ffi 1.10.0 Installing msgpack 1.2.10 with native extensions Installing ffi 1.10.0 with native extensions Fetching method_source 0.9.2 Installing method_source 0.9.2 Fetching puma 3.12.1 Installing puma 3.12.1 with native extensions Fetching thor 0.20.3 Installing thor 0.20.3 Fetching rb-fsevent 0.10.3 Installing rb-fsevent 0.10.3 Fetching tilt 2.0.9 Installing tilt 2.0.9 Fetching sqlite3 1.4.1 Installing sqlite3 1.4.1 with native extensions Fetching turbolinks-source 5.2.0 Installing turbolinks-source 5.2.0 Fetching tzinfo 1.2.5 Installing tzinfo 1.2.5 Fetching nokogiri 1.10.3 Installing nokogiri 1.10.3 with native extensions Fetching i18n 1.6.0 Installing i18n 1.6.0 Fetching websocket-driver 0.7.0 Installing websocket-driver 0.7.0 with native extensions Fetching marcel 0.3.3 Installing marcel 0.3.3 Fetching mail 2.7.1 Installing mail 2.7.1 Fetching rack-test 1.1.0 Installing rack-test 1.1.0 Fetching rack-proxy 0.6.5 Installing rack-proxy 0.6.5 Fetching sprockets 3.7.2 Installing sprockets 3.7.2 Fetching bootsnap 1.4.4 Installing bootsnap 1.4.4 with native extensions Fetching rb-inotify 0.10.0 Installing rb-inotify 0.10.0 Fetching turbolinks 5.2.0 Installing turbolinks 5.2.0 Fetching activesupport 6.0.0.rc1 Installing activesupport 6.0.0.rc1 Fetching loofah 2.2.3 Installing loofah 2.2.3 Fetching sass-listen 4.0.0 Fetching rails-html-sanitizer 1.0.4 Fetching rails-dom-testing 2.0.3 Installing sass-listen 4.0.0 Fetching globalid 0.4.2 Installing rails-html-sanitizer 1.0.4 Fetching activemodel 6.0.0.rc1 Installing rails-dom-testing 2.0.3 Fetching jbuilder 2.9.1 Installing globalid 0.4.2 Fetching sass 3.7.4 Installing activemodel 6.0.0.rc1 Installing jbuilder 2.9.1 Fetching actionview 6.0.0.rc1 Installing sass 3.7.4 Installing actionview 6.0.0.rc1 Fetching activejob 6.0.0.rc1 Installing activejob 6.0.0.rc1 Fetching activerecord 6.0.0.rc1 Installing activerecord 6.0.0.rc1 Fetching actionpack 6.0.0.rc1 Installing actionpack 6.0.0.rc1 Fetching actioncable 6.0.0.rc1 Fetching actionmailer 6.0.0.rc1 Fetching railties 6.0.0.rc1 Installing actionmailer 6.0.0.rc1 Installing actioncable 6.0.0.rc1 Fetching sprockets-rails 3.2.1 Fetching activestorage 6.0.0.rc1 Installing sprockets-rails 3.2.1 Installing activestorage 6.0.0.rc1 Installing railties 6.0.0.rc1 Fetching actionmailbox 6.0.0.rc1 Fetching actiontext 6.0.0.rc1 Installing actiontext 6.0.0.rc1 Installing actionmailbox 6.0.0.rc1 Fetching sass-rails 5.0.7 Fetching rails 6.0.0.rc1 Fetching webpacker 4.0.2 Installing sass-rails 5.0.7 Installing rails 6.0.0.rc1 Installing webpacker 4.0.2 Bundle complete! 17 Gemfile dependencies, 59 gems now installed. Gems in the groups development and test were not installed. Bundled gems are installed into `/var/www/rails-new/shared/bundle` Post-install message from i18n: HEADS UP! i18n 1.1 changed fallbacks to exclude default locale. But that may break your application. Please check your Rails app for 'config.i18n.fallbacks = true'. If you're using I18n (>= 1.1.0) and Rails (< 5.2.2), this should be 'config.i18n.fallbacks = [I18n.default_locale]'. If not, fallbacks will be broken in your app by I18n 1.1.x. For more info see: https://github.com/svenfuchs/i18n/releases/tag/v1.1.0 Post-install message from sass: Ruby Sass has reached end-of-life and should no longer be used. * If you use Sass as a command-line tool, we recommend using Dart Sass, the new primary implementation: https://sass-lang.com/install * If you use Sass as a plug-in for a Ruby web framework, we recommend using the sassc gem: https://github.com/sass/sassc-ruby#readme * For more details, please refer to the Sass blog: https://sass-lang.com/blog/posts/7828841 \u2022 rails:db_create cd /tmp/tomo/20190616214334 && bundle exec rails db:version Database already exists; skipping db:create. \u2022 rails:db_schema_load [ -f /tmp/tomo/20190616214334/db/schema.rb ] WARNING: db/schema.rb is not present; skipping schema:load. \u2022 rails:db_seed cd /tmp/tomo/20190616214334 && bundle exec rails db:seed \u2714 Performed setup of rails-new on deployer@localhost:32809","title":"setup"},{"location":"commands/setup/#setup","text":"Prepare the current project for its first deploy.","title":"setup"},{"location":"commands/setup/#usage","text":"$ tomo setup [--dry-run] [options] Prepare the remote host for its first deploy by sequentially running the setup list of tasks specified in .tomo/config.rb . These tasks typically create directories, initialize data stores, install prerequisite tools, and perform other one-time actions that are necessary before a deploy can take place. During setup, tomo will initialize the :release_path setting based on the current date and time and using a temporary directory (e.g. /tmp/tomo/20190616214752 ). This means setup tasks (e.g. rails:db_create , rails:db_schema_load ) to run in a location that won\u2019t be deployed as an actual release.","title":"Usage"},{"location":"commands/setup/#options","text":"Option Purpose -e ENVIRONMENT , --environment ENVIRONMENT If the configuration contains multiple environments , specify the ENVIRONMENT that should be used (e.g. production). The host(s) and settings can be different per environment. -s NAME=VALUE , --setting NAME=VALUE Override the setting NAME with the given VALUE. Refer to the settings overrides documentation for a detailed explanation. --[no-]dry-run Simulate running tasks instead of using real SSH. -c PATH , --config PATH Override the PATH where the configuration file is loaded from. (Default: .tomo/config.rb ). --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page.","title":"Options"},{"location":"commands/setup/#example","text":"Given the following configuration: host \"deployer@localhost\", port: 32809 setup do run \"env:setup\" run \"core:setup_directories\" run \"git:clone\" run \"git:create_release\" run \"core:symlink_shared\" run \"nvm:install\" run \"rbenv:install\" run \"bundler:upgrade_bundler\" run \"bundler:install\" run \"rails:db_create\" run \"rails:db_schema_load\" run \"rails:db_seed\" end Then a setup would produce: $ tomo setup tomo setup v0.1.0 \u2192 Connecting to deployer@localhost:32809 \u2022 env:setup Writing 280 bytes to /var/www/rails-new/envrc cat .bashrc Writing 3845 bytes to .bashrc \u2022 core:setup_directories mkdir -p /var/www/rails-new /var/www/rails-new/releases /var/www/rails-new/shared \u2022 git:clone [ -d /var/www/rails-new/git_repo ] mkdir -p /var/www/rails-new export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git clone --mirror git@github.com:mattbrictson/rails-new.git /var/www/rails-new/git_repo Cloning into bare repository '/var/www/rails-new/git_repo'... Warning: Permanently added 'github.com,192.30.255.112' (RSA) to the list of known hosts. \u2022 git:create_release Writing 60 bytes to /var/www/rails-new/git_repo/info/attributes cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git remote update --prune Fetching origin cd /var/www/rails-new/git_repo && mkdir -p /tmp/tomo/20190616214334 cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git archive master | tar -x -f - -C /tmp/tomo/20190616214334 cd /var/www/rails-new/git_repo && export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication\\=no\\ -o\\ StrictHostKeyChecking\\=no && git log -n1 --date=iso --pretty=format:\"%H/%cd/%ae\" master \u2022 core:symlink_shared mkdir -p /var/www/rails-new/shared/.bundle /var/www/rails-new/shared/log /var/www/rails-new/shared/node_modules /var/www/rails-new/shared/public/assets /tmp/tomo/20190616214334/public cd /tmp/tomo/20190616214334 && rm -rf .bundle log node_modules public/assets ln -sf /var/www/rails-new/shared/.bundle /tmp/tomo/20190616214334/.bundle ln -sf /var/www/rails-new/shared/log /tmp/tomo/20190616214334/log ln -sf /var/www/rails-new/shared/node_modules /tmp/tomo/20190616214334/node_modules ln -sf /var/www/rails-new/shared/public/assets /tmp/tomo/20190616214334/public/assets \u2022 nvm:install mkdir -p $HOME/.nvm cat .bashrc Writing 3923 bytes to .bashrc curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 13226 100 13226 0 0 116k 0 --:--:-- --:--:-- --:--:-- 117k => Downloading nvm from git to '/home/deployer/.nvm' Cloning into '/home/deployer/.nvm'... => => Compressing and cleaning up git repository => nvm source string already in /home/deployer/.bashrc => Appending bash_completion source string to /home/deployer/.bashrc => Close and reopen your terminal to start using nvm or run the following to use it now: export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm [ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion nvm ls nvm install 10.16.0 Downloading and installing node v10.16.0... Downloading https://nodejs.org/dist/v10.16.0/node-v10.16.0-linux-x64.tar.xz... ######################################################################## 100.0% Computing checksum with sha256sum Checksums matched! Now using node v10.16.0 (npm v6.9.0) Creating default alias: default -> 10.16.0 (-> v10.16.0 *) nvm alias default 10.16.0 default -> 10.16.0 (-> v10.16.0 *) npm i -g yarn@1.16.0 /home/deployer/.nvm/versions/node/v10.16.0/bin/yarn -> /home/deployer/.nvm/versions/node/v10.16.0/lib/node_modules/yarn/bin/yarn.js /home/deployer/.nvm/versions/node/v10.16.0/bin/yarnpkg -> /home/deployer/.nvm/versions/node/v10.16.0/lib/node_modules/yarn/bin/yarn.js + yarn@1.16.0 added 1 package in 0.57s \u2022 rbenv:install export PATH=$HOME/.rbenv/bin:$HOME/.rbenv/shims:$PATH && curl -fsSL https://github.com/rbenv/rbenv-installer/raw/master/bin/rbenv-installer | bash Installing rbenv with git... Initialized empty Git repository in /home/deployer/.rbenv/.git/ Updating origin From https://github.com/rbenv/rbenv * [new branch] master -> origin/master * [new tag] v0.1.0 -> v0.1.0 * [new tag] v0.1.1 -> v0.1.1 * [new tag] v0.1.2 -> v0.1.2 * [new tag] v0.2.0 -> v0.2.0 * [new tag] v0.2.1 -> v0.2.1 * [new tag] v0.3.0 -> v0.3.0 * [new tag] v0.4.0 -> v0.4.0 * [new tag] v1.0.0 -> v1.0.0 * [new tag] v1.1.0 -> v1.1.0 * [new tag] v1.1.1 -> v1.1.1 * [new tag] v1.1.2 -> v1.1.2 Already on 'master' Branch 'master' set up to track remote branch 'master' from 'origin'. make: Entering directory '/home/deployer/.rbenv/src' gcc -fPIC -c -o realpath.o realpath.c gcc -shared -Wl,-soname,../libexec/rbenv-realpath.dylib -o ../libexec/rbenv-realpath.dylib realpath.o make: Leaving directory '/home/deployer/.rbenv/src' Installing ruby-build with git... Cloning into '/home/deployer/.rbenv/plugins/ruby-build'... Running doctor script to verify installation... Checking for `rbenv' in PATH: /home/deployer/.rbenv/bin/rbenv Checking for rbenv shims in PATH: OK Checking `rbenv install' support: /home/deployer/.rbenv/plugins/ruby-build/bin/rbenv-install (ruby-build 20190615-1-g0867187) Counting installed Ruby versions: none There aren't any Ruby versions installed under `/home/deployer/.rbenv/versions'. You can install Ruby versions like so: rbenv install 2.2.4 Checking RubyGems settings: OK Auditing installed plugins: OK All done! Note that this installer doesn't yet configure your shell startup files: 1. You'll want to ensure that `~/.rbenv/bin' is added to PATH. 2. Run `rbenv init' to see instructions how to configure rbenv for your shell. 3. Launch a new terminal window to verify that the configuration is correct. cat .bashrc Writing 4121 bytes to .bashrc rbenv versions Installing ruby 2.6.3 -- this may take several minutes CFLAGS=-O3 rbenv install 2.6.3 Downloading ruby-2.6.3.tar.bz2... -> https://cache.ruby-lang.org/pub/ruby/2.6/ruby-2.6.3.tar.bz2 Installing ruby-2.6.3... Installed ruby-2.6.3 to /home/deployer/.rbenv/versions/2.6.3 rbenv global 2.6.3 \u2022 bundler:upgrade_bundler tail -n 10 /tmp/tomo/20190616214334/Gemfile.lock gem install bundler --conservative --no-document -v 2.0.1 Successfully installed bundler-2.0.1 1 gem installed \u2022 bundler:install cd /tmp/tomo/20190616214334 && bundle check --path /var/www/rails-new/shared/bundle The following gems are missing * rake (12.3.2) * concurrent-ruby (1.1.5) * i18n (1.6.0) * minitest (5.11.3) * thread_safe (0.3.6) * tzinfo (1.2.5) * zeitwerk (2.1.6) * activesupport (6.0.0.rc1) * builder (3.2.3) * erubi (1.8.0) * mini_portile2 (2.4.0) * nokogiri (1.10.3) * rails-dom-testing (2.0.3) * crass (1.0.4) * loofah (2.2.3) * rails-html-sanitizer (1.0.4) * actionview (6.0.0.rc1) * rack (2.0.7) * rack-test (1.1.0) * actionpack (6.0.0.rc1) * nio4r (2.3.1) * websocket-extensions (0.1.3) * websocket-driver (0.7.0) * actioncable (6.0.0.rc1) * globalid (0.4.2) * activejob (6.0.0.rc1) * activemodel (6.0.0.rc1) * activerecord (6.0.0.rc1) * mimemagic (0.3.3) * marcel (0.3.3) * activestorage (6.0.0.rc1) * mini_mime (1.0.1) * mail (2.7.1) * actionmailbox (6.0.0.rc1) * actionmailer (6.0.0.rc1) * actiontext (6.0.0.rc1) * public_suffix (3.0.3) * addressable (2.6.0) * bindex (0.7.0) * msgpack (1.2.10) * bootsnap (1.4.4) * byebug (11.0.1) * regexp_parser (1.5.0) * execjs (2.7.0) * uglifier (4.1.20) * xpath (3.2.0) * capybara (3.20.0) * childprocess (1.0.1) * ffi (1.10.0) * jbuilder (2.9.1) * rb-fsevent (0.10.3) * rb-inotify (0.10.0) * ruby_dep (1.5.0) * listen (3.1.5) * method_source (0.9.2) * puma (3.12.1) * rack-proxy (0.6.5) * thor (0.20.3) * railties (6.0.0.rc1) * sprockets (3.7.2) * sprockets-rails (3.2.1) * rails (6.0.0.rc1) * rubyzip (1.2.2) * sass-listen (4.0.0) * sass (3.7.4) * tilt (2.0.9) * sass-rails (5.0.7) * selenium-webdriver (3.142.2) * spring (2.0.2) * spring-watcher-listen (2.0.1) * sqlite3 (1.4.1) * turbolinks-source (5.2.0) * turbolinks (5.2.0) * web-console (4.0.0) * webdrivers (3.9.2) * webpacker (4.0.2) Install missing gems with `bundle install` cd /tmp/tomo/20190616214334 && bundle install --path /var/www/rails-new/shared/bundle --jobs 4 --without development test --deployment Fetching gem metadata from https://rubygems.org/............ Fetching rake 12.3.2 Installing rake 12.3.2 Fetching concurrent-ruby 1.1.5 Fetching minitest 5.11.3 Fetching thread_safe 0.3.6 Installing minitest 5.11.3 Installing thread_safe 0.3.6 Installing concurrent-ruby 1.1.5 Fetching zeitwerk 2.1.6 Installing zeitwerk 2.1.6 Fetching builder 3.2.3 Installing builder 3.2.3 Fetching erubi 1.8.0 Installing erubi 1.8.0 Fetching mini_portile2 2.4.0 Fetching crass 1.0.4 Installing mini_portile2 2.4.0 Fetching rack 2.0.7 Fetching nio4r 2.3.1 Installing crass 1.0.4 Fetching websocket-extensions 0.1.3 Installing websocket-extensions 0.1.3 Fetching mimemagic 0.3.3 Installing nio4r 2.3.1 with native extensions Installing rack 2.0.7 Installing mimemagic 0.3.3 Fetching mini_mime 1.0.1 Installing mini_mime 1.0.1 Fetching msgpack 1.2.10 Using bundler 2.0.1 Fetching ffi 1.10.0 Installing msgpack 1.2.10 with native extensions Installing ffi 1.10.0 with native extensions Fetching method_source 0.9.2 Installing method_source 0.9.2 Fetching puma 3.12.1 Installing puma 3.12.1 with native extensions Fetching thor 0.20.3 Installing thor 0.20.3 Fetching rb-fsevent 0.10.3 Installing rb-fsevent 0.10.3 Fetching tilt 2.0.9 Installing tilt 2.0.9 Fetching sqlite3 1.4.1 Installing sqlite3 1.4.1 with native extensions Fetching turbolinks-source 5.2.0 Installing turbolinks-source 5.2.0 Fetching tzinfo 1.2.5 Installing tzinfo 1.2.5 Fetching nokogiri 1.10.3 Installing nokogiri 1.10.3 with native extensions Fetching i18n 1.6.0 Installing i18n 1.6.0 Fetching websocket-driver 0.7.0 Installing websocket-driver 0.7.0 with native extensions Fetching marcel 0.3.3 Installing marcel 0.3.3 Fetching mail 2.7.1 Installing mail 2.7.1 Fetching rack-test 1.1.0 Installing rack-test 1.1.0 Fetching rack-proxy 0.6.5 Installing rack-proxy 0.6.5 Fetching sprockets 3.7.2 Installing sprockets 3.7.2 Fetching bootsnap 1.4.4 Installing bootsnap 1.4.4 with native extensions Fetching rb-inotify 0.10.0 Installing rb-inotify 0.10.0 Fetching turbolinks 5.2.0 Installing turbolinks 5.2.0 Fetching activesupport 6.0.0.rc1 Installing activesupport 6.0.0.rc1 Fetching loofah 2.2.3 Installing loofah 2.2.3 Fetching sass-listen 4.0.0 Fetching rails-html-sanitizer 1.0.4 Fetching rails-dom-testing 2.0.3 Installing sass-listen 4.0.0 Fetching globalid 0.4.2 Installing rails-html-sanitizer 1.0.4 Fetching activemodel 6.0.0.rc1 Installing rails-dom-testing 2.0.3 Fetching jbuilder 2.9.1 Installing globalid 0.4.2 Fetching sass 3.7.4 Installing activemodel 6.0.0.rc1 Installing jbuilder 2.9.1 Fetching actionview 6.0.0.rc1 Installing sass 3.7.4 Installing actionview 6.0.0.rc1 Fetching activejob 6.0.0.rc1 Installing activejob 6.0.0.rc1 Fetching activerecord 6.0.0.rc1 Installing activerecord 6.0.0.rc1 Fetching actionpack 6.0.0.rc1 Installing actionpack 6.0.0.rc1 Fetching actioncable 6.0.0.rc1 Fetching actionmailer 6.0.0.rc1 Fetching railties 6.0.0.rc1 Installing actionmailer 6.0.0.rc1 Installing actioncable 6.0.0.rc1 Fetching sprockets-rails 3.2.1 Fetching activestorage 6.0.0.rc1 Installing sprockets-rails 3.2.1 Installing activestorage 6.0.0.rc1 Installing railties 6.0.0.rc1 Fetching actionmailbox 6.0.0.rc1 Fetching actiontext 6.0.0.rc1 Installing actiontext 6.0.0.rc1 Installing actionmailbox 6.0.0.rc1 Fetching sass-rails 5.0.7 Fetching rails 6.0.0.rc1 Fetching webpacker 4.0.2 Installing sass-rails 5.0.7 Installing rails 6.0.0.rc1 Installing webpacker 4.0.2 Bundle complete! 17 Gemfile dependencies, 59 gems now installed. Gems in the groups development and test were not installed. Bundled gems are installed into `/var/www/rails-new/shared/bundle` Post-install message from i18n: HEADS UP! i18n 1.1 changed fallbacks to exclude default locale. But that may break your application. Please check your Rails app for 'config.i18n.fallbacks = true'. If you're using I18n (>= 1.1.0) and Rails (< 5.2.2), this should be 'config.i18n.fallbacks = [I18n.default_locale]'. If not, fallbacks will be broken in your app by I18n 1.1.x. For more info see: https://github.com/svenfuchs/i18n/releases/tag/v1.1.0 Post-install message from sass: Ruby Sass has reached end-of-life and should no longer be used. * If you use Sass as a command-line tool, we recommend using Dart Sass, the new primary implementation: https://sass-lang.com/install * If you use Sass as a plug-in for a Ruby web framework, we recommend using the sassc gem: https://github.com/sass/sassc-ruby#readme * For more details, please refer to the Sass blog: https://sass-lang.com/blog/posts/7828841 \u2022 rails:db_create cd /tmp/tomo/20190616214334 && bundle exec rails db:version Database already exists; skipping db:create. \u2022 rails:db_schema_load [ -f /tmp/tomo/20190616214334/db/schema.rb ] WARNING: db/schema.rb is not present; skipping schema:load. \u2022 rails:db_seed cd /tmp/tomo/20190616214334 && bundle exec rails db:seed \u2714 Performed setup of rails-new on deployer@localhost:32809","title":"Example"},{"location":"commands/tasks/","text":"tasks List all tasks that can be used with the run command. Usage $ tomo tasks List all tomo tasks (i.e. those that can be used with tomo run ). Available tasks are those defined by plugins loaded in .tomo/config.rb . Refer to the Configuration guide for an explanation of how plugins are loaded. The reference documentation for each plugin (e.g. core , git ) describes the tasks these plugins provide. Options Option Purpose --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page. Example $ tomo tasks bundler:clean bundler:install bundler:upgrade_bundler core:clean_releases core:log_revision core:setup_directories core:symlink_current core:symlink_shared core:write_release_json env:set env:setup env:show env:unset env:update git:clone git:create_release nvm:install puma:restart rails:assets_precompile rails:console rails:db_create rails:db_migrate rails:db_schema_load rails:db_seed rails:db_setup rails:db_structure_load rails:log_tail rbenv:install","title":"tasks"},{"location":"commands/tasks/#tasks","text":"List all tasks that can be used with the run command.","title":"tasks"},{"location":"commands/tasks/#usage","text":"$ tomo tasks List all tomo tasks (i.e. those that can be used with tomo run ). Available tasks are those defined by plugins loaded in .tomo/config.rb . Refer to the Configuration guide for an explanation of how plugins are loaded. The reference documentation for each plugin (e.g. core , git ) describes the tasks these plugins provide.","title":"Usage"},{"location":"commands/tasks/#options","text":"Option Purpose --[no-]color By default, tomo automatically determines whether to use color output based on the capabilities of the terminal. Use this option to override this behavior and force tomo to enable or disable color output. --[no-]debug Enables verbose logging output that is helpful for troubleshooting. This includes runtime information such as the environment variables on the remote host and all tomo settings. Each SSH command executed by tomo is also logged in detail. --[no-]trace Normally if a tomo command fails, a concise and helpful error message is printed. If --trace is specified, tomo will also print the full backtrace. -h , --help Prints the help for this tomo command, similar to what you see on this page.","title":"Options"},{"location":"commands/tasks/#example","text":"$ tomo tasks bundler:clean bundler:install bundler:upgrade_bundler core:clean_releases core:log_revision core:setup_directories core:symlink_current core:symlink_shared core:write_release_json env:set env:setup env:show env:unset env:update git:clone git:create_release nvm:install puma:restart rails:assets_precompile rails:console rails:db_create rails:db_migrate rails:db_schema_load rails:db_seed rails:db_setup rails:db_structure_load rails:log_tail rbenv:install","title":"Example"},{"location":"plugins/bundler/","text":"bundler The bundler plugin installs ruby gem dependencies using bundler. This is required for deploying Rails apps. It also provides conveniences for using bundle exec . Settings Name Purpose Default bundler_install_flags Array of command-line flags to pass to the bundle install command [\"--deployment\"] bundler_gemfile Optionally used to override the location of the Gemfile nil bundler_jobs Amount of concurrency used when downloading/installing gems \"4\" bundler_path Directory where gems where be installed \"%<shared_path>/bundle\" bundler_version The version of bundler to install, used by the bundler:upgrade_bundler task; if nil (the default), determine the version based on Gemfile.lock nil bundler_without Array of Gemfile groups to exclude from installation [\"development\", \"test\"] Tasks bundler:upgrade_bundler Installs the version of bundler specified by the :bundler_version setting, if specified. If :bundler_version is nil (the default), this task will automatically determine the version of bundler required by the app that is being deployed by looking at the BUNDLED WITH entry within the app\u2019s Gemfile.lock . If :bundler_version is nil and the app is missing a lockfile, then this task does nothing. Bundler will be installed withing this command: gem install bundler --conservative --no-document -v VERSION bundler:upgrade_bundler is intended for use as a setup task. It should be run prior to bundler:install to ensure that the correct version bundler is present. bundler:install Runs bundle install to download and install all the dependencies specified by the Gemfile of the app that is being deployed. As a performance optimization, this task will run bundle check first to see if the app\u2019s dependencies have already been installed. If so, bundle install is skipped. bundler:install is intended for use as a deploy task. It should be run prior to any tasks that rely on gems. bundler:clean Runs bundle clean to delete any previously installed gems that are no longer needed by the current version of the app. Cleaning is generally good practice to save disk space and speed up app launch time. bundler:clean is intended for use as a deploy task. It should be run at the conclusion of the deploy after all other tasks. Helpers These helper methods become available on instances of Remote when the bundler plugin is loaded. They accept the same options as Remote#run . remote.bundle(*args, **options) \u2192 Tomo::Result Runs bundle within release_path by default. remote.bundle(\"exec\", \"rails\", \"console\") # $ cd /var/www/my-app/current && bundle exec rails console remote.bundle?(*args, **options) \u2192 true or false Same as bundle but returns true if the command succeeded, false otherwise.","title":"bundler"},{"location":"plugins/bundler/#bundler","text":"The bundler plugin installs ruby gem dependencies using bundler. This is required for deploying Rails apps. It also provides conveniences for using bundle exec .","title":"bundler"},{"location":"plugins/bundler/#settings","text":"Name Purpose Default bundler_install_flags Array of command-line flags to pass to the bundle install command [\"--deployment\"] bundler_gemfile Optionally used to override the location of the Gemfile nil bundler_jobs Amount of concurrency used when downloading/installing gems \"4\" bundler_path Directory where gems where be installed \"%<shared_path>/bundle\" bundler_version The version of bundler to install, used by the bundler:upgrade_bundler task; if nil (the default), determine the version based on Gemfile.lock nil bundler_without Array of Gemfile groups to exclude from installation [\"development\", \"test\"]","title":"Settings"},{"location":"plugins/bundler/#tasks","text":"","title":"Tasks"},{"location":"plugins/bundler/#bundlerupgrade_bundler","text":"Installs the version of bundler specified by the :bundler_version setting, if specified. If :bundler_version is nil (the default), this task will automatically determine the version of bundler required by the app that is being deployed by looking at the BUNDLED WITH entry within the app\u2019s Gemfile.lock . If :bundler_version is nil and the app is missing a lockfile, then this task does nothing. Bundler will be installed withing this command: gem install bundler --conservative --no-document -v VERSION bundler:upgrade_bundler is intended for use as a setup task. It should be run prior to bundler:install to ensure that the correct version bundler is present.","title":"bundler:upgrade_bundler"},{"location":"plugins/bundler/#bundlerinstall","text":"Runs bundle install to download and install all the dependencies specified by the Gemfile of the app that is being deployed. As a performance optimization, this task will run bundle check first to see if the app\u2019s dependencies have already been installed. If so, bundle install is skipped. bundler:install is intended for use as a deploy task. It should be run prior to any tasks that rely on gems.","title":"bundler:install"},{"location":"plugins/bundler/#bundlerclean","text":"Runs bundle clean to delete any previously installed gems that are no longer needed by the current version of the app. Cleaning is generally good practice to save disk space and speed up app launch time. bundler:clean is intended for use as a deploy task. It should be run at the conclusion of the deploy after all other tasks.","title":"bundler:clean"},{"location":"plugins/bundler/#helpers","text":"These helper methods become available on instances of Remote when the bundler plugin is loaded. They accept the same options as Remote#run .","title":"Helpers"},{"location":"plugins/bundler/#remotebundle42args-4242options-tomoresult","text":"Runs bundle within release_path by default. remote.bundle(\"exec\", \"rails\", \"console\") # $ cd /var/www/my-app/current && bundle exec rails console","title":"remote.bundle(*args, **options) \u2192 Tomo::Result"},{"location":"plugins/bundler/#remotebundle42args-4242options-true-or-false","text":"Same as bundle but returns true if the command succeeded, false otherwise.","title":"remote.bundle?(*args, **options) \u2192 true or false"},{"location":"plugins/core/","text":"core The core plugin provides tasks, settings, and helpers that are the fundamental building blocks for most tomo deployments. This plugin is always loaded and available, even if it is not explicitly declared in the configuration file. Settings Name Purpose Default application The name of the application being deployed \"default\" concurrency The maximum number of threads to use when deploying to multiple hosts at once 10 current_path Location of the symlink that points to the currently deployed release \"%<deploy_to>/current\" deploy_to The root directory under which all tomo data, releases, etc. are stored \"/var/www/%<application>\" keep_releases Number of releases to keep when pruning old releases with the core:clean_releases task 10 linked_dirs Array of directory names that will be symlinked from the shared directory into each release by the core:symlink_shared task [] linked_files Array of file names that will be symlinked from the shared directory into each release by the core:symlink_shared task [] releases_path Directory where the deploy command creates releases \"%<deploy_to>/releases\" release_json_path Path where the core:write_release_json task will write a JSON file describing the release \"%<release_path>/.tomo_release.json\" revision_log_path Path where the core:log_revision task will append a log message with the date and time of the release \"%<deploy_to>/revisions.log\" run_args A special read-only setting where tomo places any extra arguments that are passed to the run command [] shared_path Directory where files shared between releases are stored; used by core:symlink_shared \"%<deploy_to>/shared\" ssh_connect_timeout The number of seconds tomo will wait before it gives up when trying to open an SSH connection 5 ssh_executable The name (or full path) of the ssh executable \"ssh\" ssh_extra_opts An array of extra command line arguments that tomo will pass to every invocation of the ssh executable [\"-o\", \"PasswordAuthentication=no\"] ssh_forward_agent Whether to forward authentication when connecting via SSH; needed for seamless git+ssh true ssh_reuse_connections Whether to use ControlMaster to keep connections open across multiple invocations of ssh; setting this to false will slow down tomo significantly true ssh_strict_host_key_checking Use \"accept-new\" for a good compromise of security and convenience, true for most security, false for most convenience; note that older versions of ssh do not understand the \"accept-new\" option \"accept-new\" tmp_path Directory where the setup command stages temporary files \"/tmp/tomo\" Tasks core:setup_directories Creates the :deploy_to , :shared_path , and :releases_path directories so that other tasks that rely on these directories can work. This is one of the first tasks that should be run as part of setup . core:symlink_shared Creates a symlink for each directory listed in the :linked_dirs setting and each file in :linked_files . The symlink will point to the directory or file of the same name inside the shared directory. This allows these directories and files to be shared across all releases. Note that if a directory or file already exists in the release, that directory or file will be deleted or overwritten prior to creating the link. For example, given this configuration: set linked_dirs: [\"public/assets\"] set linked_files: [\"config/database.yml\"] Calling this task will run: mkdir -p /var/www/my-app/shared/public/assets \\ /var/www/my-app/releases/20190604204415/public cd /var/www/my-app/releases/20190604204415 && rm -rf public/assets ln -sf /var/www/my-app/shared/public/assets \\ /var/www/my-app/releases/20190604204415/public/assets ln -sfn /var/www/my-app/shared/config/database.yml \\ /var/www/my-app/releases/20190604204415/config/database.yml core:symlink_shared is intended for use as a deploy task. If :linked_dirs and :linked_files are both empty, running this task has no effect. core:symlink_current Promotes the release that is currently being deployed to become the \u201ccurrent\u201d release by updating the current symlink. core:symlink_shared is intended for use as a deploy task. It is typically run after all build steps have completed ( bundler:install , rails:db_migrate , rails:assets_precompile , etc.). core:clean_releases Deletes old releases while maintaining the most recent releases and keeping the current release. The total number of releases kept will be based on the :keep_releases setting. If this setting is absent or zero, running this task has no effect. If you are continuously deploying your application in an automated fashion, the releases can quickly fill up disk space if they are not pruned; hence the need for this task. core:clean_releases is intended for use as a deploy task. It is typically run at the end of a deployment once everything else has succeeded. core:write_release_json Writes a JSON file to the location specified by the :release_json_path setting. This file will contain a JSON object with properties that describe the release. Here is an example: { \"branch\": \"master\", \"author\": \"matt@example.com\", \"revision\": \"0d1cb3212e2f9c43aa49fb172d8d9c726163cecf\", \"revision_date\": \"2019-06-01 17:23:48 -0700\", \"deploy_date\": \"2019-06-05 19:00:26 -0700\", \"deploy_user\": \"mbrictson\" } core:log_revision Appends a message to a log file specified by the :revision_log_path setting. The message contains information about the release. Here is an example entry: 2019-06-05 19:00:26 -0700 - 0d1cb3212e2f9c43aa49fb172d8d9c726163cecf (master) deployed by mbrictson Helpers All of these methods are available on instances of Remote and accept the same options as Remote#run . remote.capture(*command, **options) \u2192 String Run the given command, returning the stdout of that command. If the command did not write to stdout, then return an empty String. Note that stderr is ignored, and an exception will be thrown if the command fails. remote.capture(\"echo\", \"hello\") # => \"hello\" remote.run?(*command, **options) \u2192 true or false Run the given command, returning true if the command succeeded (exit status of 0) or false otherwise. # If java is not installed in the $PATH remote.run?(\"which\", \"java\") # => false remote.write(text:, to:, append: false, **options) \u2192 Tomo::Result Write the given text (must be a String) to the remote path specified by to: . If append is false (the default), the remote file will completely replaced; if true , the file will be appended to. This is designed for small amounts of text (e.g. configuration files), not large or binary data. remote.write text: \"hello world!\\n\", to: paths.shared.join(\"greetings.txt\"), append: true remote.ln_sf(target, link, **options) \u2192 Tomo::Result Create a symlink on the remote host at the path specified at link that points to target . Deletes any existing file that already exists at the link path prior to creating the symlink. remote.ln_sf(paths.shared.join(\".env\"), paths.release.join(\".env\")) # $ ln -sf /var/www/my-app/shared/.env /var/www/my-app/releases/20190604204415/.env remote.ln_sfn(target, link, **options) \u2192 Tomo::Result Like ln_sf but also passes the -n flag, which allows an existing link to be deleted even if it is a symlink to a directory. remote.mkdir_p(*directories, **options) \u2192 Tomo::Result Creates one or more directories on the remote host. remote.mkdir_p(paths.current.dirname, paths.shared) # $ mkdir -p /var/www/my-app /var/www/my-app/shared remote.rm_rf(*paths, **options) \u2192 Tomo::Result Deletes one or more files or directories on the remote host. remote.rm_rf(paths.tmp) # $ rm -rf /tmp/tomo remote.list_files(directory=nil, **options) \u2192 [String] Lists non-hidden files in the specified directory. If directory is omitted, the default SSH login directory is used (typically the deploy user\u2019s home directory). The result will be an array of the directory contents. remote.list_files(\"/var/www/my-app\") # => [\"current\", \"releases\", \"revision.log\", shared\"] remote.command_available?(command_name, **options) \u2192 true or false Runs which on the remote host to determine whether the given command_name is an available executable. Returns true if an executable exists, false otherwise. remote.command_available?(\"java\") # => false remote.file?(file, **options) \u2192 true or false Uses the shell expression [ -f ] to test whether the given file exists on the remote host. Returns true if the path exists and is a normal file, false otherwise. remote.file?(\".bashrc\") # => true remote.executable?(file, **options) \u2192 true or false Uses the shell expression [ -x ] to test whether the given file exists on the remote host. Returns true if the path exists and is executable, false otherwise. remote.executable?(\"/usr/bin/git\") # => true remote.directory?(directory, **options) \u2192 true or false Uses the shell expression [ -d ] to test whether the given directory exists on the remote host. Returns true if the path exists and is a directory, false otherwise. remote.directory?(\"/opt\") # => true","title":"core"},{"location":"plugins/core/#core","text":"The core plugin provides tasks, settings, and helpers that are the fundamental building blocks for most tomo deployments. This plugin is always loaded and available, even if it is not explicitly declared in the configuration file.","title":"core"},{"location":"plugins/core/#settings","text":"Name Purpose Default application The name of the application being deployed \"default\" concurrency The maximum number of threads to use when deploying to multiple hosts at once 10 current_path Location of the symlink that points to the currently deployed release \"%<deploy_to>/current\" deploy_to The root directory under which all tomo data, releases, etc. are stored \"/var/www/%<application>\" keep_releases Number of releases to keep when pruning old releases with the core:clean_releases task 10 linked_dirs Array of directory names that will be symlinked from the shared directory into each release by the core:symlink_shared task [] linked_files Array of file names that will be symlinked from the shared directory into each release by the core:symlink_shared task [] releases_path Directory where the deploy command creates releases \"%<deploy_to>/releases\" release_json_path Path where the core:write_release_json task will write a JSON file describing the release \"%<release_path>/.tomo_release.json\" revision_log_path Path where the core:log_revision task will append a log message with the date and time of the release \"%<deploy_to>/revisions.log\" run_args A special read-only setting where tomo places any extra arguments that are passed to the run command [] shared_path Directory where files shared between releases are stored; used by core:symlink_shared \"%<deploy_to>/shared\" ssh_connect_timeout The number of seconds tomo will wait before it gives up when trying to open an SSH connection 5 ssh_executable The name (or full path) of the ssh executable \"ssh\" ssh_extra_opts An array of extra command line arguments that tomo will pass to every invocation of the ssh executable [\"-o\", \"PasswordAuthentication=no\"] ssh_forward_agent Whether to forward authentication when connecting via SSH; needed for seamless git+ssh true ssh_reuse_connections Whether to use ControlMaster to keep connections open across multiple invocations of ssh; setting this to false will slow down tomo significantly true ssh_strict_host_key_checking Use \"accept-new\" for a good compromise of security and convenience, true for most security, false for most convenience; note that older versions of ssh do not understand the \"accept-new\" option \"accept-new\" tmp_path Directory where the setup command stages temporary files \"/tmp/tomo\"","title":"Settings"},{"location":"plugins/core/#tasks","text":"","title":"Tasks"},{"location":"plugins/core/#coresetup_directories","text":"Creates the :deploy_to , :shared_path , and :releases_path directories so that other tasks that rely on these directories can work. This is one of the first tasks that should be run as part of setup .","title":"core:setup_directories"},{"location":"plugins/core/#coresymlink_shared","text":"Creates a symlink for each directory listed in the :linked_dirs setting and each file in :linked_files . The symlink will point to the directory or file of the same name inside the shared directory. This allows these directories and files to be shared across all releases. Note that if a directory or file already exists in the release, that directory or file will be deleted or overwritten prior to creating the link. For example, given this configuration: set linked_dirs: [\"public/assets\"] set linked_files: [\"config/database.yml\"] Calling this task will run: mkdir -p /var/www/my-app/shared/public/assets \\ /var/www/my-app/releases/20190604204415/public cd /var/www/my-app/releases/20190604204415 && rm -rf public/assets ln -sf /var/www/my-app/shared/public/assets \\ /var/www/my-app/releases/20190604204415/public/assets ln -sfn /var/www/my-app/shared/config/database.yml \\ /var/www/my-app/releases/20190604204415/config/database.yml core:symlink_shared is intended for use as a deploy task. If :linked_dirs and :linked_files are both empty, running this task has no effect.","title":"core:symlink_shared"},{"location":"plugins/core/#coresymlink_current","text":"Promotes the release that is currently being deployed to become the \u201ccurrent\u201d release by updating the current symlink. core:symlink_shared is intended for use as a deploy task. It is typically run after all build steps have completed ( bundler:install , rails:db_migrate , rails:assets_precompile , etc.).","title":"core:symlink_current"},{"location":"plugins/core/#coreclean_releases","text":"Deletes old releases while maintaining the most recent releases and keeping the current release. The total number of releases kept will be based on the :keep_releases setting. If this setting is absent or zero, running this task has no effect. If you are continuously deploying your application in an automated fashion, the releases can quickly fill up disk space if they are not pruned; hence the need for this task. core:clean_releases is intended for use as a deploy task. It is typically run at the end of a deployment once everything else has succeeded.","title":"core:clean_releases"},{"location":"plugins/core/#corewrite_release_json","text":"Writes a JSON file to the location specified by the :release_json_path setting. This file will contain a JSON object with properties that describe the release. Here is an example: { \"branch\": \"master\", \"author\": \"matt@example.com\", \"revision\": \"0d1cb3212e2f9c43aa49fb172d8d9c726163cecf\", \"revision_date\": \"2019-06-01 17:23:48 -0700\", \"deploy_date\": \"2019-06-05 19:00:26 -0700\", \"deploy_user\": \"mbrictson\" }","title":"core:write_release_json"},{"location":"plugins/core/#corelog_revision","text":"Appends a message to a log file specified by the :revision_log_path setting. The message contains information about the release. Here is an example entry: 2019-06-05 19:00:26 -0700 - 0d1cb3212e2f9c43aa49fb172d8d9c726163cecf (master) deployed by mbrictson","title":"core:log_revision"},{"location":"plugins/core/#helpers","text":"All of these methods are available on instances of Remote and accept the same options as Remote#run .","title":"Helpers"},{"location":"plugins/core/#remotecapture42command-4242options-string","text":"Run the given command, returning the stdout of that command. If the command did not write to stdout, then return an empty String. Note that stderr is ignored, and an exception will be thrown if the command fails. remote.capture(\"echo\", \"hello\") # => \"hello\"","title":"remote.capture(*command, **options) \u2192 String"},{"location":"plugins/core/#remoterun42command-4242options-true-or-false","text":"Run the given command, returning true if the command succeeded (exit status of 0) or false otherwise. # If java is not installed in the $PATH remote.run?(\"which\", \"java\") # => false","title":"remote.run?(*command, **options) \u2192 true or false"},{"location":"plugins/core/#remotewritetext-to-append-false-4242options-tomoresult","text":"Write the given text (must be a String) to the remote path specified by to: . If append is false (the default), the remote file will completely replaced; if true , the file will be appended to. This is designed for small amounts of text (e.g. configuration files), not large or binary data. remote.write text: \"hello world!\\n\", to: paths.shared.join(\"greetings.txt\"), append: true","title":"remote.write(text:, to:, append: false, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remoteln_sftarget-link-4242options-tomoresult","text":"Create a symlink on the remote host at the path specified at link that points to target . Deletes any existing file that already exists at the link path prior to creating the symlink. remote.ln_sf(paths.shared.join(\".env\"), paths.release.join(\".env\")) # $ ln -sf /var/www/my-app/shared/.env /var/www/my-app/releases/20190604204415/.env","title":"remote.ln_sf(target, link, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remoteln_sfntarget-link-4242options-tomoresult","text":"Like ln_sf but also passes the -n flag, which allows an existing link to be deleted even if it is a symlink to a directory.","title":"remote.ln_sfn(target, link, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remotemkdir_p42directories-4242options-tomoresult","text":"Creates one or more directories on the remote host. remote.mkdir_p(paths.current.dirname, paths.shared) # $ mkdir -p /var/www/my-app /var/www/my-app/shared","title":"remote.mkdir_p(*directories, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remoterm_rf42paths-4242options-tomoresult","text":"Deletes one or more files or directories on the remote host. remote.rm_rf(paths.tmp) # $ rm -rf /tmp/tomo","title":"remote.rm_rf(*paths, **options) \u2192 Tomo::Result"},{"location":"plugins/core/#remotelist_filesdirectorynil-4242options-string","text":"Lists non-hidden files in the specified directory. If directory is omitted, the default SSH login directory is used (typically the deploy user\u2019s home directory). The result will be an array of the directory contents. remote.list_files(\"/var/www/my-app\") # => [\"current\", \"releases\", \"revision.log\", shared\"]","title":"remote.list_files(directory=nil, **options) \u2192 [String]"},{"location":"plugins/core/#remotecommand_availablecommand_name-4242options-true-or-false","text":"Runs which on the remote host to determine whether the given command_name is an available executable. Returns true if an executable exists, false otherwise. remote.command_available?(\"java\") # => false","title":"remote.command_available?(command_name, **options) \u2192 true or false"},{"location":"plugins/core/#remotefilefile-4242options-true-or-false","text":"Uses the shell expression [ -f ] to test whether the given file exists on the remote host. Returns true if the path exists and is a normal file, false otherwise. remote.file?(\".bashrc\") # => true","title":"remote.file?(file, **options) \u2192 true or false"},{"location":"plugins/core/#remoteexecutablefile-4242options-true-or-false","text":"Uses the shell expression [ -x ] to test whether the given file exists on the remote host. Returns true if the path exists and is executable, false otherwise. remote.executable?(\"/usr/bin/git\") # => true","title":"remote.executable?(file, **options) \u2192 true or false"},{"location":"plugins/core/#remotedirectorydirectory-4242options-true-or-false","text":"Uses the shell expression [ -d ] to test whether the given directory exists on the remote host. Returns true if the path exists and is a directory, false otherwise. remote.directory?(\"/opt\") # => true","title":"remote.directory?(directory, **options) \u2192 true or false"},{"location":"plugins/env/","text":"env The env plugin manages environment variables on the remote host. It does this by creating an envrc file on the remote host and modifying the .bashrc of the deploy user so that the envrc is always loaded (for both interactive and non-interactive SSH sessions). There are two ways to specify the environment variables that are stored in the envrc file: Use env:set via the command line like tomo run env:set NAME[=VALUE] ... to explicitly set or modify environment variables Specify the :env_vars setting in the tomo configuration and then run the env:update task Note that in order for these tasks to work, you must first run env:setup to ensure the deploy user\u2019s .bashrc is properly configured to read from the envrc file that is managed by this plugin. Settings Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" env_path Location of the envrc file on the remote host \"%<deploy_to>/envrc\" env_vars A hash of environment variable names and values that will configured on the remote host; see env:update for details {} Tasks env:setup Performs an env:update and then modifies the deploy user\u2019s bashrc so that the envrc is automatically loaded for all future SSH sessions. Specifically, this is what is added to the top of the .bashrc file: if [ -f /var/www/my-app/envrc ]; then . /var/www/my-app/envrc fi env:setup is intended for use as a setup task. It must be run before other env tasks. env:update Ensures that all environment variables that are specified in the :env_vars setting are present in the envrc file on the remote host, modifying the envrc file if necessary. For example, given this config: set env_vars: { RAILS_ENV: \"production\", PUMA_THREADS: 20 } This task will ensure that the envrc file is updated to include: export RAILS=production export PUMA_THREADS=20 For environment variables that are used for secrets or other sensitive data, you can specify :prompt instead of the actual value. In this case tomo will prompt interactively for the value the first time it is needed. For example: set env_vars: { SECRET_KEY_BASE: :prompt } The first time env:update is run, tomo will prompt for the value: $ tomo deploy tomo deploy v0.1.0 \u2192 Connecting to user@app.example.com \u2022 env:update SECRET_KEY_BASE? Once the environment variable exists in the envrc file, tomo will no longer prompt for it. env:update is intended for use as a deploy task. It should be run at the beginning of a deploy to ensure that the environment has all the latest values before other tasks are run. env:set Set one or more environment variables in the remote envrc file. This task is intended for use with run and takes command-line arguments. There are two forms: # Set the remote envrc var named KEY to have VALUE $ tomo run env:set KEY=VALUE # Prompt interactively for the value of KEY and then set it in the remote envrc $ tomo run env:set KEY KEY? env:unset Remove one or more environment variables from the remote envrc file. This task is intended for use with run and takes command-line arguments. # Remove the remote envrc var named KEY $ tomo run env:unset KEY","title":"env"},{"location":"plugins/env/#env","text":"The env plugin manages environment variables on the remote host. It does this by creating an envrc file on the remote host and modifying the .bashrc of the deploy user so that the envrc is always loaded (for both interactive and non-interactive SSH sessions). There are two ways to specify the environment variables that are stored in the envrc file: Use env:set via the command line like tomo run env:set NAME[=VALUE] ... to explicitly set or modify environment variables Specify the :env_vars setting in the tomo configuration and then run the env:update task Note that in order for these tasks to work, you must first run env:setup to ensure the deploy user\u2019s .bashrc is properly configured to read from the envrc file that is managed by this plugin.","title":"env"},{"location":"plugins/env/#settings","text":"Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" env_path Location of the envrc file on the remote host \"%<deploy_to>/envrc\" env_vars A hash of environment variable names and values that will configured on the remote host; see env:update for details {}","title":"Settings"},{"location":"plugins/env/#tasks","text":"","title":"Tasks"},{"location":"plugins/env/#envsetup","text":"Performs an env:update and then modifies the deploy user\u2019s bashrc so that the envrc is automatically loaded for all future SSH sessions. Specifically, this is what is added to the top of the .bashrc file: if [ -f /var/www/my-app/envrc ]; then . /var/www/my-app/envrc fi env:setup is intended for use as a setup task. It must be run before other env tasks.","title":"env:setup"},{"location":"plugins/env/#envupdate","text":"Ensures that all environment variables that are specified in the :env_vars setting are present in the envrc file on the remote host, modifying the envrc file if necessary. For example, given this config: set env_vars: { RAILS_ENV: \"production\", PUMA_THREADS: 20 } This task will ensure that the envrc file is updated to include: export RAILS=production export PUMA_THREADS=20 For environment variables that are used for secrets or other sensitive data, you can specify :prompt instead of the actual value. In this case tomo will prompt interactively for the value the first time it is needed. For example: set env_vars: { SECRET_KEY_BASE: :prompt } The first time env:update is run, tomo will prompt for the value: $ tomo deploy tomo deploy v0.1.0 \u2192 Connecting to user@app.example.com \u2022 env:update SECRET_KEY_BASE? Once the environment variable exists in the envrc file, tomo will no longer prompt for it. env:update is intended for use as a deploy task. It should be run at the beginning of a deploy to ensure that the environment has all the latest values before other tasks are run.","title":"env:update"},{"location":"plugins/env/#envset","text":"Set one or more environment variables in the remote envrc file. This task is intended for use with run and takes command-line arguments. There are two forms: # Set the remote envrc var named KEY to have VALUE $ tomo run env:set KEY=VALUE # Prompt interactively for the value of KEY and then set it in the remote envrc $ tomo run env:set KEY KEY?","title":"env:set"},{"location":"plugins/env/#envunset","text":"Remove one or more environment variables from the remote envrc file. This task is intended for use with run and takes command-line arguments. # Remove the remote envrc var named KEY $ tomo run env:unset KEY","title":"env:unset"},{"location":"plugins/git/","text":"git The git plugin uses git running on the remote host to fetch the code of the app being deployed. This \u201cremote pull\u201d technique is currently the only deployment method officially supported by tomo. For this to work, the SSH key you use to connect to the remote host via tomo must match the key expected by the git host (e.g. by GitHub). Settings Name Purpose Default git_branch The branch of the repository to deploy \"master\" git_repo_path Directory on the remote host where a cache of the repository will be stored \"%<deploy_to>/git_repo\" git_exclusions An array of paths (similar to gitignore syntax) that will be excluded when the repository is copied into a release; it is recommend you exclude .tomo/ and other directories not needed in production, like spec/ [] git_env Environment variables that will be set when issuing git commands (hash) { GIT_SSH_COMMAND: \"ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no\" } git_url URL of the git repository; always use the SSH form like git@github.com:username/repo.git (not HTTPS) nil Tasks git:clone Performs the initial clone of the git repository. This is necessary before a deploy can be performed. The clone of the repository will be stored in the git_repo_path . The git_url setting must be specified for this task to work. git:clone is intended for use as a setup task. git:create_release Fetches the latest commits from git_branch and creates a release by copying the contents of that branch of repository into a new release inside the releases_path . Releases are numbered based on the timestamp of when the deploy takes place. git:create_release is intended for use as a deploy task. Helpers These helper methods become available on instances of Remote when the git plugin is loaded. They accept the same options as Remote#run . remote.git(*args, **options) \u2192 Tomo::Result Runs git with the environment variables specified by the git_env setting. remote.git(\"fetch\") # $ export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication=no\\ -o\\ StrictHostKeyChecking=no && git fetch","title":"git"},{"location":"plugins/git/#git","text":"The git plugin uses git running on the remote host to fetch the code of the app being deployed. This \u201cremote pull\u201d technique is currently the only deployment method officially supported by tomo. For this to work, the SSH key you use to connect to the remote host via tomo must match the key expected by the git host (e.g. by GitHub).","title":"git"},{"location":"plugins/git/#settings","text":"Name Purpose Default git_branch The branch of the repository to deploy \"master\" git_repo_path Directory on the remote host where a cache of the repository will be stored \"%<deploy_to>/git_repo\" git_exclusions An array of paths (similar to gitignore syntax) that will be excluded when the repository is copied into a release; it is recommend you exclude .tomo/ and other directories not needed in production, like spec/ [] git_env Environment variables that will be set when issuing git commands (hash) { GIT_SSH_COMMAND: \"ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no\" } git_url URL of the git repository; always use the SSH form like git@github.com:username/repo.git (not HTTPS) nil","title":"Settings"},{"location":"plugins/git/#tasks","text":"","title":"Tasks"},{"location":"plugins/git/#gitclone","text":"Performs the initial clone of the git repository. This is necessary before a deploy can be performed. The clone of the repository will be stored in the git_repo_path . The git_url setting must be specified for this task to work. git:clone is intended for use as a setup task.","title":"git:clone"},{"location":"plugins/git/#gitcreate_release","text":"Fetches the latest commits from git_branch and creates a release by copying the contents of that branch of repository into a new release inside the releases_path . Releases are numbered based on the timestamp of when the deploy takes place. git:create_release is intended for use as a deploy task.","title":"git:create_release"},{"location":"plugins/git/#helpers","text":"These helper methods become available on instances of Remote when the git plugin is loaded. They accept the same options as Remote#run .","title":"Helpers"},{"location":"plugins/git/#remotegit42args-4242options-tomoresult","text":"Runs git with the environment variables specified by the git_env setting. remote.git(\"fetch\") # $ export GIT_SSH_COMMAND=ssh\\ -o\\ PasswordAuthentication=no\\ -o\\ StrictHostKeyChecking=no && git fetch","title":"remote.git(*args, **options) \u2192 Tomo::Result"},{"location":"plugins/nvm/","text":"nvm The nvm plugin installs node and optionally yarn via nvm. This allows you to deploy an app with confidence that particular versions of these tools will be available on the host. This plugin is strongly recommended for Rails apps, which by default use webpacker and thus require node and yarn. Settings Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" nvm_version Version of nvm to install \"0.34.0\" nvm_node_version Version of node to install nil nvm_yarn_version Version of yarn to install nil Tasks nvm:install Installs nvm, uses nvm to install node, and makes the desired version of node the global default version for the deploy user. During installation, the user\u2019s bashrc file is modified so that nvm is automatically loaded for interactive and non-interactive shells. You must supply a value for the nvm_node_version setting for this task to work. If the nvm_yarn_version setting is specified, yarn is also installed globally via npm. This setting is optional. nvm:install is intended for use as a setup task.","title":"nvm"},{"location":"plugins/nvm/#nvm","text":"The nvm plugin installs node and optionally yarn via nvm. This allows you to deploy an app with confidence that particular versions of these tools will be available on the host. This plugin is strongly recommended for Rails apps, which by default use webpacker and thus require node and yarn.","title":"nvm"},{"location":"plugins/nvm/#settings","text":"Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" nvm_version Version of nvm to install \"0.34.0\" nvm_node_version Version of node to install nil nvm_yarn_version Version of yarn to install nil","title":"Settings"},{"location":"plugins/nvm/#tasks","text":"","title":"Tasks"},{"location":"plugins/nvm/#nvminstall","text":"Installs nvm, uses nvm to install node, and makes the desired version of node the global default version for the deploy user. During installation, the user\u2019s bashrc file is modified so that nvm is automatically loaded for interactive and non-interactive shells. You must supply a value for the nvm_node_version setting for this task to work. If the nvm_yarn_version setting is specified, yarn is also installed globally via npm. This setting is optional. nvm:install is intended for use as a setup task.","title":"nvm:install"},{"location":"plugins/puma/","text":"puma The puma plugin provides basic, zero-configuration support for the default Rails web server. Settings Name Purpose Default puma_control_token Auth token to use when connecting to the puma control server \"tomo\" puma_control_url Connection URL for the puma control server \"tcp://127.0.0.1:9293\" Tasks puma:restart Attempts to restart the puma web server via pumactl . If puma is not already running or has crashed, this task will gracefully perform a cold start of the server instead. The puma gem must be present in the Rails application Gemfile for this task to work. Puma is started with this command: bundle exec puma --daemon The config/puma.rb file within the Rails app is used for configuration. puma:restart is intended for use in a deploy , immediately following core:symlink_current to ensure that the new version of the Rails app is activated.","title":"puma"},{"location":"plugins/puma/#puma","text":"The puma plugin provides basic, zero-configuration support for the default Rails web server.","title":"puma"},{"location":"plugins/puma/#settings","text":"Name Purpose Default puma_control_token Auth token to use when connecting to the puma control server \"tomo\" puma_control_url Connection URL for the puma control server \"tcp://127.0.0.1:9293\"","title":"Settings"},{"location":"plugins/puma/#tasks","text":"","title":"Tasks"},{"location":"plugins/puma/#pumarestart","text":"Attempts to restart the puma web server via pumactl . If puma is not already running or has crashed, this task will gracefully perform a cold start of the server instead. The puma gem must be present in the Rails application Gemfile for this task to work. Puma is started with this command: bundle exec puma --daemon The config/puma.rb file within the Rails app is used for configuration. puma:restart is intended for use in a deploy , immediately following core:symlink_current to ensure that the new version of the Rails app is activated.","title":"puma:restart"},{"location":"plugins/rails/","text":"rails The rails plugin provides tasks for running rails and rake commands commonly used during setup and deployment, such as for precompiling assets and migrating the database. Make sure the RAILS_ENV environment variable is set prior to running rails tasks. The env plugin is the preferred mechanism for this. Settings None. Tasks rails:assets_precompile Builds the asset pipeline in preparation for deployment. This is necessary for Rails apps that use the asset pipeline, which is all new Rails apps by default. Running this task will execute this script: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake assets:precompile rails:assets_precompile is intended for use as a deploy task. It is typically run just prior to core:symlink_current to activate a new release. rails:console Starts an interactive Rails console via SSH to the remote host. This task is intended for use as a run task and accepts command-line arguments. The arguments are passed through to the console. For example: $ tomo run -- rails:console --sandbox Will run this remote script: cd /var/www/my-app/current && bundle exec rails console --sandbox rails:db_migrate Migrates the database by running: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake db:migrate rails:db_migrate is intended for use as a deploy task. It is typically run just after bundler:install prior to activating a new release. rails:db_seed Loads seed data into the database. Seeds should be written to be idempotent, such that it is safe to seed the database on each deploy. Typically seeds are used to load reference data need for the app to function, or for example to create an initial admin user. This task runs the following script: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake db:seed rails:db_seed is intended for use as a deploy task. Since seeds rely on the structure of the database, it is typically run just after rails:db_migrate . rails:db_create Runs bundle exec rake db:create to create the database. This task is intended for use as a setup task. It will be automatically skipped if the database already exists, so it is safe to re-run. rails:db_schema_load Runs bundle exec rake db:schema:load to load the schema from db/schema.rb into an existing database. This task is intended for use as a setup task after rails:db_create . It will be automatically skipped if the database already contains a schema, so it is safe to re-run. rails:db_structure_load Runs bundle exec rake db:structure:load to load the schema from db/structure.sql into an existing database. This task is intended for use as a setup task after rails:db_create . It will be automatically skipped if the database already contains a schema, so it is safe to re-run. Helpers These helper methods become available on instances of Remote when the rails plugin is loaded. They accept the same options as Remote#run . remote.rails(*args, **options) \u2192 Tomo::Result Runs bundle exec rails in within paths.release by default. remote.rails(\"routes\") # $ cd /var/www/my-app/releases/20190604204415 && bundle exec rails routes remote.rake(*args, **options) \u2192 Tomo::Result Runs bundle exec rake in within paths.release by default. remote.rake(\"db:migrate\") # $ cd /var/www/my-app/releases/20190604204415 && bundle exec rake db:migrate remote.rake?(*args, **options) \u2192 true or false Like rake but returns true if the command succeeds (exit status 0), otherwise false . remote.rake?(\"db:migrate\") # => true","title":"rails"},{"location":"plugins/rails/#rails","text":"The rails plugin provides tasks for running rails and rake commands commonly used during setup and deployment, such as for precompiling assets and migrating the database. Make sure the RAILS_ENV environment variable is set prior to running rails tasks. The env plugin is the preferred mechanism for this.","title":"rails"},{"location":"plugins/rails/#settings","text":"None.","title":"Settings"},{"location":"plugins/rails/#tasks","text":"","title":"Tasks"},{"location":"plugins/rails/#railsassets_precompile","text":"Builds the asset pipeline in preparation for deployment. This is necessary for Rails apps that use the asset pipeline, which is all new Rails apps by default. Running this task will execute this script: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake assets:precompile rails:assets_precompile is intended for use as a deploy task. It is typically run just prior to core:symlink_current to activate a new release.","title":"rails:assets_precompile"},{"location":"plugins/rails/#railsconsole","text":"Starts an interactive Rails console via SSH to the remote host. This task is intended for use as a run task and accepts command-line arguments. The arguments are passed through to the console. For example: $ tomo run -- rails:console --sandbox Will run this remote script: cd /var/www/my-app/current && bundle exec rails console --sandbox","title":"rails:console"},{"location":"plugins/rails/#railsdb_migrate","text":"Migrates the database by running: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake db:migrate rails:db_migrate is intended for use as a deploy task. It is typically run just after bundler:install prior to activating a new release.","title":"rails:db_migrate"},{"location":"plugins/rails/#railsdb_seed","text":"Loads seed data into the database. Seeds should be written to be idempotent, such that it is safe to seed the database on each deploy. Typically seeds are used to load reference data need for the app to function, or for example to create an initial admin user. This task runs the following script: cd /var/www/my-app/releases/<RELEASE_NUMBER> && bundle exec rake db:seed rails:db_seed is intended for use as a deploy task. Since seeds rely on the structure of the database, it is typically run just after rails:db_migrate .","title":"rails:db_seed"},{"location":"plugins/rails/#railsdb_create","text":"Runs bundle exec rake db:create to create the database. This task is intended for use as a setup task. It will be automatically skipped if the database already exists, so it is safe to re-run.","title":"rails:db_create"},{"location":"plugins/rails/#railsdb_schema_load","text":"Runs bundle exec rake db:schema:load to load the schema from db/schema.rb into an existing database. This task is intended for use as a setup task after rails:db_create . It will be automatically skipped if the database already contains a schema, so it is safe to re-run.","title":"rails:db_schema_load"},{"location":"plugins/rails/#railsdb_structure_load","text":"Runs bundle exec rake db:structure:load to load the schema from db/structure.sql into an existing database. This task is intended for use as a setup task after rails:db_create . It will be automatically skipped if the database already contains a schema, so it is safe to re-run.","title":"rails:db_structure_load"},{"location":"plugins/rails/#helpers","text":"These helper methods become available on instances of Remote when the rails plugin is loaded. They accept the same options as Remote#run .","title":"Helpers"},{"location":"plugins/rails/#remoterails42args-4242options-tomoresult","text":"Runs bundle exec rails in within paths.release by default. remote.rails(\"routes\") # $ cd /var/www/my-app/releases/20190604204415 && bundle exec rails routes","title":"remote.rails(*args, **options) \u2192 Tomo::Result"},{"location":"plugins/rails/#remoterake42args-4242options-tomoresult","text":"Runs bundle exec rake in within paths.release by default. remote.rake(\"db:migrate\") # $ cd /var/www/my-app/releases/20190604204415 && bundle exec rake db:migrate","title":"remote.rake(*args, **options) \u2192 Tomo::Result"},{"location":"plugins/rails/#remoterake42args-4242options-true-or-false","text":"Like rake but returns true if the command succeeds (exit status 0), otherwise false . remote.rake?(\"db:migrate\") # => true","title":"remote.rake?(*args, **options) \u2192 true or false"},{"location":"plugins/rbenv/","text":"rbenv The rbenv plugin provides a way to install and run a desired version of ruby. This is the recommended way to manage ruby for Rails apps. Settings Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" rbenv_ruby_version Version of ruby to install nil Tasks rbenv:install Installs rbenv, uses rbenv to install ruby, and makes the desired version of ruby the global default version for the deploy user. During installation, the user\u2019s bashrc file is modified so that rbenv is automatically loaded for interactive and non-interactive shells. Behind the scenes, rbenv installs ruby via ruby-build, which compiles ruby from source. This means installation can take several minutes. If the desired version of ruby is already installed, the compilation step will be skipped. You must supply a value for the rbenv_ruby_version setting for this task to work. rbenv:install is intended for use as a setup task.","title":"rbenv"},{"location":"plugins/rbenv/#rbenv","text":"The rbenv plugin provides a way to install and run a desired version of ruby. This is the recommended way to manage ruby for Rails apps.","title":"rbenv"},{"location":"plugins/rbenv/#settings","text":"Name Purpose Default bashrc_path Location of the deploy user\u2019s .bashrc file \".bashrc\" rbenv_ruby_version Version of ruby to install nil","title":"Settings"},{"location":"plugins/rbenv/#tasks","text":"","title":"Tasks"},{"location":"plugins/rbenv/#rbenvinstall","text":"Installs rbenv, uses rbenv to install ruby, and makes the desired version of ruby the global default version for the deploy user. During installation, the user\u2019s bashrc file is modified so that rbenv is automatically loaded for interactive and non-interactive shells. Behind the scenes, rbenv installs ruby via ruby-build, which compiles ruby from source. This means installation can take several minutes. If the desired version of ruby is already installed, the compilation step will be skipped. You must supply a value for the rbenv_ruby_version setting for this task to work. rbenv:install is intended for use as a setup task.","title":"rbenv:install"},{"location":"readme_images/","text":"The images in this directory can be regenerated using the record_console.rb script. For example: ./record_console.rb tomo deploy --help This will translate the output of the tomo deploy --help command into HTML and launch it in a browser. From there, press the Convert to PNG button to generate an image appropriately sized for a GitHub README.","title":"Home"},{"location":"tutorials/deploying-rails-from-scratch/","text":"Deploying Rails From Scratch Coming soon\u2026","title":"Deploying Rails From Scratch"},{"location":"tutorials/deploying-rails-from-scratch/#deploying-rails-from-scratch","text":"Coming soon\u2026","title":"Deploying Rails From Scratch"},{"location":"tutorials/publishing-a-plugin/","text":"Publishing a Plugin Coming soon\u2026","title":"Publishing a Plugin"},{"location":"tutorials/publishing-a-plugin/#publishing-a-plugin","text":"Coming soon\u2026","title":"Publishing a Plugin"},{"location":"tutorials/writing-custom-tasks/","text":"Writing Custom Tasks In this tutorial we will build a \u201ccron\u201d plugin to demonstrate how to write custom tasks in tomo. Here are the main takeaways: Use .tomo/plugins/*.rb to define plugins A task is any public Ruby method within a plugin Tasks can access the TaskLibrary API Use remote.run to execute scripts on the remote host Here\u2019s the final product: # .tomo/config.rb plugin \"./plugins/cron.rb\" # .tomo/plugins/cron.rb require \"erb\" def show remote.run \"crontab -l\", raise_on_error: false end def install crontab = merge_template(\"../templates/crontab.erb\") remote.run \"echo #{crontab.shellescape} | crontab -\", echo: \"echo [template:.tomo/templates/crontab.erb] | crontab -\" end private def merge_template(path) template = IO.read(File.expand_path(path, __dir__)) ERB.new(template).result(binding) end # ./templates/crontab.erb SHELL=/bin/bash 0 6 * * * . $HOME/.bashrc; cd <%= paths.current %>; bundle exec rails runner PeriodicTask.call > <%= paths.shared.join(\"log/periodic-task.log\") %> 2>&1 Before we get there, let\u2019s review the basics. What is a plugin? Plugins extend tomo by providing some or all of these three things: tasks, helpers, and default settings. Plugins are either built into tomo (e.g. git , rails ), provided by gems (e.g. tomo-plugin-rollbar ), or loaded from ./tomo/plugins/*.rb within a tomo project. This tutorial will focus on project-specific plugins, which are the easiest to write. Once you are ready to share your plugin amongst multiple projects (or with the larger tomo community), check out the Publishing a Plugin tutorial to learn how to package a plugin as a gem. What is a task? In tomo, a task is a plain Ruby method provided by a plugin. Task methods take zero arguments. Here is a trivial example: # .tomo/plugins/foo.rb # This defines a foo:hello task def hello logger.info \"hello, world!\" end The name of the plugin is set automatically based on the name of the .rb file, which in this case is \u201cfoo\u201d. Any public method defined in foo.rb becomes a tomo task. So the example above defines a foo:hello task that prints \u201chello, world!\u201d to the console. What can a task do? Behind the scenes, the Ruby methods you define in your plugin are actually methods on a subclass of TaskLibrary . That means you have full access to the TaskLibrary API within your task method, which includes: logger for printing output (as seen in the example above) remote for running scripts on the remote host settings for accessing project configuration paths for convenient access to filesystem paths on the remote host and more\u2026 For example, a simplified, annotated version of the git:clone task that is built into tomo looks like this: def clone # Halt tomo with an error message if the :git_url setting is nil/unspecified require_setting :git_url # Run \"mkdir -p\" on the remote host to create the parent directory # of the :git_repo_path setting remote.mkdir_p(paths.git_repo.dirname) # Run \"git clone ...\" on the remote host to clone the repo into :git_repo_path remote.run(\"git\", \"clone\", \"--mirror\", settings[:git_url], paths.git_repo) end When are tasks run? Tomo does not have hooks and tasks cannot invoke other tasks. That means that tasks only run when explicitly requested by the user. There are three ways to run a task: deploy setup run For deploy and setup, users invoke your task by including it in the deploy or setup list of tasks in .tomo/config.rb . Additionally, any task can be run on-demand from the command line, like this: $ tomo run foo:hello In the command line case, users can optionally pass arguments to a task. These arguments become available to the task via the :run_args setting. For example, the rails:console task supports command line arguments like this: def console # If this task is run like `tomo run -- rails:console --sandbox` # then settings[:run_args] will be [\"--sandbox\"] args = settings[:run_args] remote.chdir(paths.current) do remote.run(\"bundle\", \"exec\", \"rails\", \"console\", *args, attach: true) end end How do tasks connect to remote hosts? Notice that none of the examples in this tutorial makes any mention of opening/closing connections or specifying hosts or roles. That is because tomo takes care of connecting to remote hosts and automatically decides which tasks should run on which hosts based on project configuration. By the time a task method is invoked, any necessary SSH connection is already established; remote implicitly refers to that connection. In other words, as a tomo task author you only need to be concerned about what remote scripts to run, not where or how they are executed. For a more in-depth explanation of how configuration drives tomo\u2019s behavior, refer to the configuration docs . Tutorial Let\u2019s build something using this knowledge of how tomo tasks work. Objective Say we have a Rails app that needs to run code \u2013 PeriodicTask.call , for example \u2013 every day at 06:00. We\u2019d like to do this with a cron job and use tomo to install that cron job on the remote host. For troubleshooting purposes it would be nice to view the list of cron jobs with tomo as well. That sounds like two distinct tomo tasks: cron:install to install the cron job cron:show to list the currently installed cron jobs We want cron:install to be run when we initially set up the remote host. In other words, it should run as part of tomo setup . On the other hand, cron:show is a utility that we can use on the CLI when needed. cron:show We\u2019ll start by building the simpler of the two tasks: cron:show . First, let\u2019s try to run that task: $ tomo run cron:show tomo run v0.3.0 ERROR: cron:show is not a recognized task. To see a list of all available tasks, run tomo tasks. We haven\u2019t written the task yet, so this error makes sense. Let\u2019s build a skeleton of the cron:show task to fix this error. Create a .tomo/plugins/cron.rb task like this: # .tomo/plugins/cron.rb def show logger.info \"Hi\" end And don\u2019t forget to load the plugin in .tomo/config.rb : # .tomo/config.rb plugin \"./plugins/cron.rb\" Now we can try again: $ tomo run cron:show tomo run v0.3.0 \u2192 Connecting to deployer@app.example.com \u2022 cron:show Hi \u2714 Ran cron:show on deployer@app.example.com Great! To get a list of cron jobs, we need to run crontab -l on the remote host: def show remote.run \"crontab -l\" end One more try: $ tomo run cron:show tomo run v0.3.0 \u2192 Connecting to deployer@app.example.com \u2022 cron:show crontab -l no crontab for deployer ERROR: The following script failed on deployer@app.example.com (exit status 1). crontab -l You can manually re-execute the script via SSH as follows: ssh -o LogLevel\\=ERROR -A -o ConnectTimeout\\=5 -o StrictHostKeyChecking\\=accept-new -o ControlMaster\\=auto -o ControlPath\\=/var/folders/_v/j_5kgc6n1nz5pb7kfkzz3r5c0000gn/T/tomo_ssh_1f061db77f81ae9e -o ControlPersist\\=30s -o PasswordAuthentication\\=no deployer@app.example.com -- crontab\\ -l For more troubleshooting info, run tomo again using the --debug option. no crontab for deployer Uh oh. There are no cron jobs installed yet, so crontab -l exits with an error. By default, tomo assumes that any remote command the exits with an error status is considered fatal. In this case we just want to see the error output from the crontab command and continue without complaint; that\u2019s where the raise_on_error: false option comes into play: def show remote.run \"crontab -l\", raise_on_error: false end Now we\u2019re all good: $ tomo run cron:show tomo run v0.3.0 \u2192 Connecting to deployer@app.example.com \u2022 cron:show crontab -l no crontab for deployer \u2714 Ran cron:show on deployer@app.example.com cron:install Before we said that we want a cron:install task that runs as part of tomo setup . Let\u2019s start by adding that task to the list of setup tasks in .tomo/config.rb : # .tomo/config.rb setup do # ... other tasks omitted for brevity run \"cron:install\" end If we try to run tomo setup at this point, we\u2019ll get an error as expected: $ tomo setup tomo setup v0.3.0 ERROR: cron:install is not a recognized task. To see a list of all available tasks, run tomo tasks. Did you mean rbenv:install? Cron jobs can be installed by piping a list of cron definitions to crontab - (the - means to read the definitions from stdin). We can take advantage of this to write a simple cron:install task: def install crontab = <<~CRONTAB SHELL=/bin/bash 0 6 * * * . $HOME/.bashrc; cd /var/www/my-app/current; bundle exec rails runner PeriodicTask.call > /var/www/my-app/shared/log/periodic-task.log 2>&1 CRONTAB remote.run \"echo #{crontab.shellescape} | crontab -\" end Note that we are using shellescape as part of Ruby\u2019s built-in shellwords library to safely build the script. We can see what this task does without actually affecting the remote host by using --dry-run option: $ tomo run cron:install --dry-run tomo run v0.3.0 * \u2192 Connecting to deployer@app.example.com * \u2022 cron:install * echo SHELL\\=/bin/bash' * '0\\ 6\\ \\*\\ \\*\\ \\*\\ .\\ \\$HOME/.bashrc\\;\\ cd\\ /var/www/my-app/current\\;\\ bundle\\ exec\\ rails\\ runner\\ PeriodicTask.call\\ \\>\\ /var/www/my-app/shared/log/periodic-task.log\\ 2\\>\\&1' * ' | crontab - * Simulated cron:install on deployer@app.example.com (dry run) Looks good! But we if we made it more powerful with some erb templating? Templates There are no built-in templating mechanisms in tomo, but that\u2019s because tomo tasks are just Ruby, and we can implement a template with erb templates in just a few lines of code. First we can add a private method to our .tomo/plugins/cron.rb file. Private methods are not exposed as tomo tasks but give us the ability to organize our code. This private method reads in an erb template, evaluates it, and returns the rendered template as a string: require \"erb\" def show # ... end def install # ... end private def merge_template(path) template = IO.read(File.expand_path(path, __dir__)) ERB.new(template).result(binding) end Now we can use a template instead of a hard-coded cron job: def install crontab = merge_template(\"../templates/crontab.erb\") remote.run \"echo #{crontab.shellescape} | crontab -\" end The erb template has access to all the same APIs as our task methods; that means we can remove the hard-coded paths from our original cron job specification and use tomo\u2019s paths helper. So our erb template file ( .tomo/templates/crontab.erb ) could look like this: # ./templates/crontab.erb SHELL=/bin/bash 0 6 * * * . $HOME/.bashrc; cd <%= paths.current %>; bundle exec rails runner PeriodicTask.call > <%= paths.shared.join(\"log/periodic-task.log\") %> 2>&1 Let\u2019s check that it still works: $ tomo run cron:install --dry-run tomo run v0.3.0 * \u2192 Connecting to deployer@app.example.com * \u2022 cron:install * echo SHELL\\=/bin/bash' * '0\\ 6\\ \\*\\ \\*\\ \\*\\ .\\ \\$HOME/.bashrc\\;\\ cd\\ /var/www/my-app/current\\;\\ bundle\\ exec\\ rails\\ runner\\ PeriodicTask.call\\ \\>\\ /var/www/my-app/shared/log/periodic-task.log\\ 2\\>\\&1' * ' | crontab - * Simulated cron:install on deployer@app.example.com (dry run) That\u2019s great, but the output is really verbose. Do we really need to see the full contents of the crontab being echoed? What if our template becomes really large? In tomo, you can mute this output using echo: false , but you can also provide an echo string to show instead of the command. We can use this to echo an abbreviated version: def install crontab = merge_template(\"../templates/crontab.erb\") remote.run \"echo #{crontab.shellescape} | crontab -\", echo: \"echo [template:.tomo/templates/crontab.erb] | crontab -\" end And then try it: $ tomo run cron:install --dry-run tomo run v0.3.0 * \u2192 Connecting to deployer@app.example.com * \u2022 cron:install * echo [template:.tomo/templates/crontab.erb] | crontab - * Simulated cron:install on deployer@app.example.com (dry run) Ah, much cleaner! The result We now have a cron:install task that will automatically run as part of tomo setup , or can be run manually using tomo run cron:install . Let\u2019s try it for real: $ tomo setup ... [snip] ... \u2022 cron:install echo [template:.tomo/templates/crontab.erb] | crontab - \u2714 Performed setup of my-app on deployer@app.example.com And we can see what is installed with our cron:show task: $ tomo run cron:show tomo run v0.3.0 \u2192 Connecting to deployer@app.example.com \u2022 cron:show crontab -l SHELL=/bin/bash 0 6 * * * . $HOME/.bashrc; cd /home/deployer/apps/my-app/current; bundle exec rails runner PeriodicTask.call > /home/deployer/apps/my-app/shared/log/periodic-task.log 2>&1 \u2714 Ran cron:show on deployer@app.example.com Next steps This tutorial introduced you to writing custom tasks in tomo, but there is much more to explore. For next steps, check out these APIs: Tomo::TaskLibrary Tomo::Remote Tomo::Result Tomo::Paths core plugin helpers (additional methods mixed into the Remote API) And for inspiration, look no further than tomo itself, which has several built-in plugins in lib/tomo/plugin .","title":"Writing Custom Tasks"},{"location":"tutorials/writing-custom-tasks/#writing-custom-tasks","text":"In this tutorial we will build a \u201ccron\u201d plugin to demonstrate how to write custom tasks in tomo. Here are the main takeaways: Use .tomo/plugins/*.rb to define plugins A task is any public Ruby method within a plugin Tasks can access the TaskLibrary API Use remote.run to execute scripts on the remote host Here\u2019s the final product: # .tomo/config.rb plugin \"./plugins/cron.rb\" # .tomo/plugins/cron.rb require \"erb\" def show remote.run \"crontab -l\", raise_on_error: false end def install crontab = merge_template(\"../templates/crontab.erb\") remote.run \"echo #{crontab.shellescape} | crontab -\", echo: \"echo [template:.tomo/templates/crontab.erb] | crontab -\" end private def merge_template(path) template = IO.read(File.expand_path(path, __dir__)) ERB.new(template).result(binding) end # ./templates/crontab.erb SHELL=/bin/bash 0 6 * * * . $HOME/.bashrc; cd <%= paths.current %>; bundle exec rails runner PeriodicTask.call > <%= paths.shared.join(\"log/periodic-task.log\") %> 2>&1 Before we get there, let\u2019s review the basics.","title":"Writing Custom Tasks"},{"location":"tutorials/writing-custom-tasks/#what-is-a-plugin","text":"Plugins extend tomo by providing some or all of these three things: tasks, helpers, and default settings. Plugins are either built into tomo (e.g. git , rails ), provided by gems (e.g. tomo-plugin-rollbar ), or loaded from ./tomo/plugins/*.rb within a tomo project. This tutorial will focus on project-specific plugins, which are the easiest to write. Once you are ready to share your plugin amongst multiple projects (or with the larger tomo community), check out the Publishing a Plugin tutorial to learn how to package a plugin as a gem.","title":"What is a plugin?"},{"location":"tutorials/writing-custom-tasks/#what-is-a-task","text":"In tomo, a task is a plain Ruby method provided by a plugin. Task methods take zero arguments. Here is a trivial example: # .tomo/plugins/foo.rb # This defines a foo:hello task def hello logger.info \"hello, world!\" end The name of the plugin is set automatically based on the name of the .rb file, which in this case is \u201cfoo\u201d. Any public method defined in foo.rb becomes a tomo task. So the example above defines a foo:hello task that prints \u201chello, world!\u201d to the console.","title":"What is a task?"},{"location":"tutorials/writing-custom-tasks/#what-can-a-task-do","text":"Behind the scenes, the Ruby methods you define in your plugin are actually methods on a subclass of TaskLibrary . That means you have full access to the TaskLibrary API within your task method, which includes: logger for printing output (as seen in the example above) remote for running scripts on the remote host settings for accessing project configuration paths for convenient access to filesystem paths on the remote host and more\u2026 For example, a simplified, annotated version of the git:clone task that is built into tomo looks like this: def clone # Halt tomo with an error message if the :git_url setting is nil/unspecified require_setting :git_url # Run \"mkdir -p\" on the remote host to create the parent directory # of the :git_repo_path setting remote.mkdir_p(paths.git_repo.dirname) # Run \"git clone ...\" on the remote host to clone the repo into :git_repo_path remote.run(\"git\", \"clone\", \"--mirror\", settings[:git_url], paths.git_repo) end","title":"What can a task do?"},{"location":"tutorials/writing-custom-tasks/#when-are-tasks-run","text":"Tomo does not have hooks and tasks cannot invoke other tasks. That means that tasks only run when explicitly requested by the user. There are three ways to run a task: deploy setup run For deploy and setup, users invoke your task by including it in the deploy or setup list of tasks in .tomo/config.rb . Additionally, any task can be run on-demand from the command line, like this: $ tomo run foo:hello In the command line case, users can optionally pass arguments to a task. These arguments become available to the task via the :run_args setting. For example, the rails:console task supports command line arguments like this: def console # If this task is run like `tomo run -- rails:console --sandbox` # then settings[:run_args] will be [\"--sandbox\"] args = settings[:run_args] remote.chdir(paths.current) do remote.run(\"bundle\", \"exec\", \"rails\", \"console\", *args, attach: true) end end","title":"When are tasks run?"},{"location":"tutorials/writing-custom-tasks/#how-do-tasks-connect-to-remote-hosts","text":"Notice that none of the examples in this tutorial makes any mention of opening/closing connections or specifying hosts or roles. That is because tomo takes care of connecting to remote hosts and automatically decides which tasks should run on which hosts based on project configuration. By the time a task method is invoked, any necessary SSH connection is already established; remote implicitly refers to that connection. In other words, as a tomo task author you only need to be concerned about what remote scripts to run, not where or how they are executed. For a more in-depth explanation of how configuration drives tomo\u2019s behavior, refer to the configuration docs .","title":"How do tasks connect to remote hosts?"},{"location":"tutorials/writing-custom-tasks/#tutorial","text":"Let\u2019s build something using this knowledge of how tomo tasks work.","title":"Tutorial"},{"location":"tutorials/writing-custom-tasks/#objective","text":"Say we have a Rails app that needs to run code \u2013 PeriodicTask.call , for example \u2013 every day at 06:00. We\u2019d like to do this with a cron job and use tomo to install that cron job on the remote host. For troubleshooting purposes it would be nice to view the list of cron jobs with tomo as well. That sounds like two distinct tomo tasks: cron:install to install the cron job cron:show to list the currently installed cron jobs We want cron:install to be run when we initially set up the remote host. In other words, it should run as part of tomo setup . On the other hand, cron:show is a utility that we can use on the CLI when needed.","title":"Objective"},{"location":"tutorials/writing-custom-tasks/#cronshow","text":"We\u2019ll start by building the simpler of the two tasks: cron:show . First, let\u2019s try to run that task: $ tomo run cron:show tomo run v0.3.0 ERROR: cron:show is not a recognized task. To see a list of all available tasks, run tomo tasks. We haven\u2019t written the task yet, so this error makes sense. Let\u2019s build a skeleton of the cron:show task to fix this error. Create a .tomo/plugins/cron.rb task like this: # .tomo/plugins/cron.rb def show logger.info \"Hi\" end And don\u2019t forget to load the plugin in .tomo/config.rb : # .tomo/config.rb plugin \"./plugins/cron.rb\" Now we can try again: $ tomo run cron:show tomo run v0.3.0 \u2192 Connecting to deployer@app.example.com \u2022 cron:show Hi \u2714 Ran cron:show on deployer@app.example.com Great! To get a list of cron jobs, we need to run crontab -l on the remote host: def show remote.run \"crontab -l\" end One more try: $ tomo run cron:show tomo run v0.3.0 \u2192 Connecting to deployer@app.example.com \u2022 cron:show crontab -l no crontab for deployer ERROR: The following script failed on deployer@app.example.com (exit status 1). crontab -l You can manually re-execute the script via SSH as follows: ssh -o LogLevel\\=ERROR -A -o ConnectTimeout\\=5 -o StrictHostKeyChecking\\=accept-new -o ControlMaster\\=auto -o ControlPath\\=/var/folders/_v/j_5kgc6n1nz5pb7kfkzz3r5c0000gn/T/tomo_ssh_1f061db77f81ae9e -o ControlPersist\\=30s -o PasswordAuthentication\\=no deployer@app.example.com -- crontab\\ -l For more troubleshooting info, run tomo again using the --debug option. no crontab for deployer Uh oh. There are no cron jobs installed yet, so crontab -l exits with an error. By default, tomo assumes that any remote command the exits with an error status is considered fatal. In this case we just want to see the error output from the crontab command and continue without complaint; that\u2019s where the raise_on_error: false option comes into play: def show remote.run \"crontab -l\", raise_on_error: false end Now we\u2019re all good: $ tomo run cron:show tomo run v0.3.0 \u2192 Connecting to deployer@app.example.com \u2022 cron:show crontab -l no crontab for deployer \u2714 Ran cron:show on deployer@app.example.com","title":"cron:show"},{"location":"tutorials/writing-custom-tasks/#croninstall","text":"Before we said that we want a cron:install task that runs as part of tomo setup . Let\u2019s start by adding that task to the list of setup tasks in .tomo/config.rb : # .tomo/config.rb setup do # ... other tasks omitted for brevity run \"cron:install\" end If we try to run tomo setup at this point, we\u2019ll get an error as expected: $ tomo setup tomo setup v0.3.0 ERROR: cron:install is not a recognized task. To see a list of all available tasks, run tomo tasks. Did you mean rbenv:install? Cron jobs can be installed by piping a list of cron definitions to crontab - (the - means to read the definitions from stdin). We can take advantage of this to write a simple cron:install task: def install crontab = <<~CRONTAB SHELL=/bin/bash 0 6 * * * . $HOME/.bashrc; cd /var/www/my-app/current; bundle exec rails runner PeriodicTask.call > /var/www/my-app/shared/log/periodic-task.log 2>&1 CRONTAB remote.run \"echo #{crontab.shellescape} | crontab -\" end Note that we are using shellescape as part of Ruby\u2019s built-in shellwords library to safely build the script. We can see what this task does without actually affecting the remote host by using --dry-run option: $ tomo run cron:install --dry-run tomo run v0.3.0 * \u2192 Connecting to deployer@app.example.com * \u2022 cron:install * echo SHELL\\=/bin/bash' * '0\\ 6\\ \\*\\ \\*\\ \\*\\ .\\ \\$HOME/.bashrc\\;\\ cd\\ /var/www/my-app/current\\;\\ bundle\\ exec\\ rails\\ runner\\ PeriodicTask.call\\ \\>\\ /var/www/my-app/shared/log/periodic-task.log\\ 2\\>\\&1' * ' | crontab - * Simulated cron:install on deployer@app.example.com (dry run) Looks good! But we if we made it more powerful with some erb templating?","title":"cron:install"},{"location":"tutorials/writing-custom-tasks/#templates","text":"There are no built-in templating mechanisms in tomo, but that\u2019s because tomo tasks are just Ruby, and we can implement a template with erb templates in just a few lines of code. First we can add a private method to our .tomo/plugins/cron.rb file. Private methods are not exposed as tomo tasks but give us the ability to organize our code. This private method reads in an erb template, evaluates it, and returns the rendered template as a string: require \"erb\" def show # ... end def install # ... end private def merge_template(path) template = IO.read(File.expand_path(path, __dir__)) ERB.new(template).result(binding) end Now we can use a template instead of a hard-coded cron job: def install crontab = merge_template(\"../templates/crontab.erb\") remote.run \"echo #{crontab.shellescape} | crontab -\" end The erb template has access to all the same APIs as our task methods; that means we can remove the hard-coded paths from our original cron job specification and use tomo\u2019s paths helper. So our erb template file ( .tomo/templates/crontab.erb ) could look like this: # ./templates/crontab.erb SHELL=/bin/bash 0 6 * * * . $HOME/.bashrc; cd <%= paths.current %>; bundle exec rails runner PeriodicTask.call > <%= paths.shared.join(\"log/periodic-task.log\") %> 2>&1 Let\u2019s check that it still works: $ tomo run cron:install --dry-run tomo run v0.3.0 * \u2192 Connecting to deployer@app.example.com * \u2022 cron:install * echo SHELL\\=/bin/bash' * '0\\ 6\\ \\*\\ \\*\\ \\*\\ .\\ \\$HOME/.bashrc\\;\\ cd\\ /var/www/my-app/current\\;\\ bundle\\ exec\\ rails\\ runner\\ PeriodicTask.call\\ \\>\\ /var/www/my-app/shared/log/periodic-task.log\\ 2\\>\\&1' * ' | crontab - * Simulated cron:install on deployer@app.example.com (dry run) That\u2019s great, but the output is really verbose. Do we really need to see the full contents of the crontab being echoed? What if our template becomes really large? In tomo, you can mute this output using echo: false , but you can also provide an echo string to show instead of the command. We can use this to echo an abbreviated version: def install crontab = merge_template(\"../templates/crontab.erb\") remote.run \"echo #{crontab.shellescape} | crontab -\", echo: \"echo [template:.tomo/templates/crontab.erb] | crontab -\" end And then try it: $ tomo run cron:install --dry-run tomo run v0.3.0 * \u2192 Connecting to deployer@app.example.com * \u2022 cron:install * echo [template:.tomo/templates/crontab.erb] | crontab - * Simulated cron:install on deployer@app.example.com (dry run) Ah, much cleaner!","title":"Templates"},{"location":"tutorials/writing-custom-tasks/#the-result","text":"We now have a cron:install task that will automatically run as part of tomo setup , or can be run manually using tomo run cron:install . Let\u2019s try it for real: $ tomo setup ... [snip] ... \u2022 cron:install echo [template:.tomo/templates/crontab.erb] | crontab - \u2714 Performed setup of my-app on deployer@app.example.com And we can see what is installed with our cron:show task: $ tomo run cron:show tomo run v0.3.0 \u2192 Connecting to deployer@app.example.com \u2022 cron:show crontab -l SHELL=/bin/bash 0 6 * * * . $HOME/.bashrc; cd /home/deployer/apps/my-app/current; bundle exec rails runner PeriodicTask.call > /home/deployer/apps/my-app/shared/log/periodic-task.log 2>&1 \u2714 Ran cron:show on deployer@app.example.com","title":"The result"},{"location":"tutorials/writing-custom-tasks/#next-steps","text":"This tutorial introduced you to writing custom tasks in tomo, but there is much more to explore. For next steps, check out these APIs: Tomo::TaskLibrary Tomo::Remote Tomo::Result Tomo::Paths core plugin helpers (additional methods mixed into the Remote API) And for inspiration, look no further than tomo itself, which has several built-in plugins in lib/tomo/plugin .","title":"Next steps"}]}